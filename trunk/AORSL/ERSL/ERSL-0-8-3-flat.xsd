<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="refman/refman.xsl"?>
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified"
	targetNamespace="http://aor-simulation.org" xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:ers="http://aor-simulation.org" xmlns:h="http://www.w3.org/1999/xhtml"
	xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<!-- =================================================================== -->
	<xs:annotation>
		<xs:documentation>
			<dc:title>ERSL 0.8.3</dc:title>
		</xs:documentation>
	</xs:annotation>
	<xs:annotation>
		<xs:documentation xml:lang="en"><p>Created on 20100422, Copyright 2010 Gerd Wagner. See also the <a href="http://AOR-Simulation.org">AOR Simulation project website</a>.</p>
			<p><img href="ERS-Types.png" alt="ERS types"/></p>
		</xs:documentation>
	</xs:annotation>
	<!-- =================================================================== -->
	<xs:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="xml.xsd"/>
	<!-- =================================================================== -->
	<xs:import namespace="http://www.w3.org/2001/XInclude" schemaLocation="xinclude.xsd"/>
	<!-- =================================================================== -->
	<xs:import namespace="http://purl.org/dc/elements/1.1/" schemaLocation="dc.xsd"/>
	<!-- =================================================================== -->
	<xs:element name="documentation">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice maxOccurs="unbounded" minOccurs="0">
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:subject"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:creator"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:contributor"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:description"/>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="description"
					type="ers:AnyXHTML.type"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:source">
					<xs:annotation>
						<xs:documentation>A related resource from which the described resource is
							derived.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element minOccurs="0" ref="dc:created"/>
				<xs:element minOccurs="0" ref="dc:available"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:modified"/>
				<xs:element minOccurs="0" ref="dc:license"/>
				<xs:element form="qualified" minOccurs="0" name="informationModelDiagram" type="xs:anyURI"/>
				<xs:element form="qualified" minOccurs="0" name="processModelDiagram" type="xs:anyURI"/>
			</xs:choice>
			<xs:attribute default="en" ref="xml:lang" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType mixed="true" name="AnyXHTML.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:any maxOccurs="unbounded" minOccurs="0" namespace="http://www.w3.org/1999/xhtml"
				processContents="skip"/>
		</xs:sequence>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:group name="include">
		<!-- =================================================================== -->
		<xs:sequence>
			<xs:element ref="xi:include"/>
		</xs:sequence>
	</xs:group>
	<!-- =================================================================== -->
	<xs:attributeGroup name="include">
		<!-- =================================================================== -->
		<xs:attribute ref="xml:id" use="optional"/>
		<xs:attribute ref="xml:base" use="optional"/>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<!-- *** Property *** -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="Property" type="ers:Property.type"/>
	<xs:complexType name="Property.type">
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="type" type="ers:CanonicalName" use="required"/>
		<xs:attribute default="1" form="unqualified" name="upperMultiplicity"
			type="ers:UpperMultiplicity" use="optional"/>
		<xs:attribute default="1" form="unqualified" name="lowerMultiplicity"
			type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute default="false" form="unqualified" name="isStatic" type="xs:boolean"
			use="optional"/>
		<!-- 
		<xs:attribute name="isEmergent" type="xs:boolean" use="optional" default="false"/>
		-->
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** Attribute ** -->
	<!-- =================================================================== -->
	<xs:element name="Attribute" substitutionGroup="ers:Property" type="ers:Attribute.type"/>
	<xs:complexType name="Attribute.type">
		<xs:complexContent>
			<xs:extension base="ers:Attribute0.type">
				<xs:attribute form="unqualified" name="initialValue" type="xs:string" use="optional"/>
				<xs:attribute form="unqualified" name="minValue" type="xs:double" use="optional"/>
				<xs:attribute form="unqualified" name="maxValue" type="xs:double" use="optional"/>
				<!--<xs:assert test="@minValue le @maxValue"/>-->
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Attribute0.type">
		<xs:complexContent>
			<xs:restriction base="ers:Property.type">
				<xs:attribute form="unqualified" name="type" type="ers:PrimitiveDataType" use="required"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="PrimitiveDataType">
		<xs:restriction base="ers:CanonicalName">
			<xs:enumeration value="String"/>
			<xs:enumeration value="Integer"/>
			<xs:enumeration value="Float"/>
			<xs:enumeration value="Boolean"/>
			<xs:enumeration value="Date"/>
			<xs:enumeration value="Time"/>
			<xs:enumeration value="DateTime"/>
			<xs:enumeration value="Duration"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- =================================================================== -->
	<!-- *** ReferenceProperty ***  -->
	<!-- =================================================================== -->
	<xs:element name="ReferenceProperty" substitutionGroup="ers:Property"
		type="ers:ReferenceProperty.type"/>
	<xs:complexType name="ReferenceProperty.type">
		<xs:complexContent>
			<xs:extension base="ers:Property.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** ComplexDataProperty *** -->
	<!-- =================================================================== -->
	<xs:element name="ComplexDataProperty" substitutionGroup="ers:Property"
		type="ers:ReferenceProperty.type"/>
	<!-- =================================================================== -->
	<!-- *** EnumerationProperty *** -->
	<!-- =================================================================== -->
	<xs:element name="EnumerationProperty" substitutionGroup="ers:Property"
		type="ers:EnumerationProperty.type"/>
	<xs:complexType name="EnumerationProperty.type">
		<xs:complexContent>
			<xs:extension base="ers:Property.type">
				<xs:attribute form="unqualified" name="initialValue" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="Parameter" type="ers:Parameter.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Parameter.type">
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="type" type="ers:JavaTypeName" use="required"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:complexType name="OpaqueExpression">
		<!-- =================================================================== -->
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute form="unqualified" name="language" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="Java"/>
							<xs:enumeration value="JavaScript"/>
							<xs:enumeration value="PHP"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="Slot" type="ers:Slot.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Slot.type">
		<xs:choice>
			<xs:element minOccurs="0" ref="ers:RandomVariable"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
		</xs:choice>
		<xs:attribute form="unqualified" name="property" type="ers:PathName" use="required"/>
		<xs:attribute form="unqualified" name="value" type="xs:string" use="optional"/>
	</xs:complexType>
	<xs:complexType name="SimpleSlot">
		<xs:complexContent>
			<xs:restriction base="ers:Slot.type">
				<xs:attribute form="unqualified" name="property" type="ers:PathName" use="required"/>
				<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OpaqueExprSlot">
		<xs:complexContent>
			<xs:restriction base="ers:Slot.type">
				<xs:choice>
					<xs:element minOccurs="0" ref="ers:RandomVariable"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
				</xs:choice>
				<xs:attribute form="unqualified" name="property" type="ers:PathName" use="required"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="MultiValuedSlot">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice maxOccurs="unbounded" minOccurs="0">
				<xs:element form="qualified" name="Add">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" minOccurs="0" name="ItemRefExpr"
								type="ers:OpaqueExpression"/>
						</xs:sequence>
						<xs:attribute form="unqualified" name="itemVariable" type="ers:CanonicalName"
							use="optional"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Remove">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" minOccurs="0" name="ItemRefExpr"
								type="ers:OpaqueExpression"/>
						</xs:sequence>
						<xs:attribute form="unqualified" name="itemVariable" type="ers:CanonicalName"
							use="optional"/>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:attribute form="unqualified" name="property" type="ers:PathName" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="Code" type="ers:OpaqueExpression"/>
	<!-- =================================================================== -->
	<xs:element name="Text">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:string">
					<xs:attribute default="en" ref="xml:lang" use="optional"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="SelectionCondition" type="ers:OpaqueExpression"/>
	<!-- =================================================================== -->
	<xs:element name="ValueExpr" type="ers:OpaqueExpression"/>
	<!-- =================================================================== -->
	<xs:complexType name="ValueExpr.type">
		<xs:simpleContent>
			<xs:extension base="ers:OpaqueExpression">
				<!--
				<xs:attribute name="objectVariable" type="ers:CanonicalName" use="optional"/>
				<xs:attribute name="objectIdRef" type="xs:long" use="optional"/>
				<xs:attribute name="objectName" type="xs:NCName" use="optional"/>
			-->
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!-- ======================================================= -->
	<xs:element name="Enumeration" type="ers:Enumeration.type"/>
	<!-- ======================================================= -->
	<xs:complexType name="Enumeration.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:EnumerationLiteral"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
	</xs:complexType>
	<xs:element name="EnumerationLiteral" type="ers:JavaConstantName"/>
	<!-- =================================================================== -->
	<xs:element name="Function" type="ers:Function.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Function.type">
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:documentation"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Parameter"/>
			<xs:element form="qualified" maxOccurs="unbounded" name="Body" type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="resultType" type="ers:JavaTypeName" use="required"/>
		<xs:attribute default="false" form="unqualified" name="isStatic" type="xs:boolean"
			use="optional"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:complexType name="RandomVariable-OR-ValueExpr">
		<!-- =================================================================== -->
		<xs:choice>
			<xs:element minOccurs="0" ref="ers:RandomVariable"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
		</xs:choice>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="DiscreteRandomVariable-OR-ValueExpr">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:element minOccurs="0" ref="ers:DiscreteRandomVariable"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
		</xs:choice>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="RandomVariable" type="ers:RandomVariable.type"/>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="RandomVariable.type">
		<xs:choice>
			<xs:group ref="ers:ContinuousRandomVariable.elements"/>
			<xs:group ref="ers:DiscreteRandomVariable.elements"/>
			<xs:group ref="ers:IntRandomVariable.elements"/>
		</xs:choice>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="DiscreteRandomVariable">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:choice>
				<xs:group ref="ers:DiscreteRandomVariable.elements"/>
				<xs:group ref="ers:IntRandomVariable.elements"/>
			</xs:choice>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="ContinuousRandomVariable.elements">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:element form="qualified" name="Uniform" type="ers:Uniform.type">
				<xs:annotation>
					<xs:documentation xmlns="http://www.w3.org/1999/xhtml">Continuous propability distribution where each possible value has the same proability. See also <a href="http://en.wikipedia.org/wiki/Uniform_distribution_%28discrete%29">Wikipedia article</a>. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Triangular" type="ers:Triangular.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution used when only the minimum and
						maximum and an "inspired guess" of the modal value are known. See also <h:a
							href="http://en.wikipedia.org/wiki/Triangular_distribution">Wikipedia article</h:a>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Normal" type="ers:Normal.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution where the data clusters around a
						mean. See also <h:a href="http://en.wikipedia.org/wiki/Normal_distribution">Wikipedia
							article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Exponential" type="ers:Exponential.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution of the times between events in a
						Poisson process, i.e. a process in which events occur continuously and independently at
						a constant average rate. See also <h:a
							href="http://en.wikipedia.org/wiki/Exponential_distribution">Wikipedia article</h:a>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="LogNormal" type="ers:Normal.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution of a random variable whose logarithm
						is normally distributed. See also <h:a href="http://en.wikipedia.org/wiki/Log_normal"
							>Wikipedia article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Gamma" type="ers:Gamma.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution that can be used to model waiting
						times. See also <h:a href="http://en.wikipedia.org/wiki/Gamma_distribution">Wikipedia
							article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Erlang" type="ers:Erlang.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution. See also <h:a
							href="http://en.wikipedia.org/wiki/Erlang_distribution">Wikipedia
						article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Weibull" type="ers:Weibull.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution. See also <h:a
							href="http://en.wikipedia.org/wiki/Weibull_distribution">Wikipedia
						article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="IntRandomVariable.elements">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:element form="qualified" name="UniformInt" type="ers:Uniform.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Uniform propability distribution.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="TriangularInt" type="ers:Triangular.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Triangular propability distribution
						used when only the minimum and maximum and an "inspired guess" of the modal value are
						known. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="NormalInt" type="ers:Normal.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Normal propability distribution where
						the data clusters around a mean. See also <h:a
							href="http://en.wikipedia.org/wiki/Normal_distribution">Wikipedia
						article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="ExponentialInt" type="ers:Exponential.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Exponential propability distribution
						of the times between events in a Poisson process, i.e. a process in which events occur
						continuously and independently at a constant average rate. See also <h:a
							href="http://en.wikipedia.org/wiki/Exponential_distribution">Wikipedia article</h:a>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="LogNormalInt" type="ers:Normal.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous LogNormal propability distribution of
						a random variable whose logarithm is normally distributed. See also <h:a
							href="http://en.wikipedia.org/wiki/Log_normal">Wikipedia
						article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="GammaInt" type="ers:Gamma.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Gamma propability distribution that
						can be used to model waiting times. See also <h:a
							href="http://en.wikipedia.org/wiki/Gamma_distribution">Wikipedia
						article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="ErlangInt" type="ers:Erlang.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Erlang propability distribution. See
						also <h:a href="http://en.wikipedia.org/wiki/Erlang_distribution">Wikipedia
							article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="WeibullInt" type="ers:Weibull.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Weibull propability distribution. See
						also <h:a href="http://en.wikipedia.org/wiki/Weibull_distribution">Wikipedia
							article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="DiscreteRandomVariable.elements">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:element form="qualified" name="Binomial" type="ers:Binomial.type">
				<xs:annotation>
					<xs:documentation>Discrete propability distribution of the number of successes in a
						sequence of n independent yes/no experiments, each of which yields success with
						probability p. See also <h:a href="http://en.wikipedia.org/wiki/Binomial_distribution"
							>Wikipedia article</h:a>. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="NegBinomial" type="ers:NegBinomial.type">
				<xs:annotation>
					<xs:documentation>Discrete propability distribution of the number of failures before the
						r'th succes in a sequence of independent yes/no experiments, each of which yields
						success with probability p. See also the <h:a
							href="http://en.wikipedia.org/wiki/Negative_binomial_distribution">Wikipedia
							article</h:a>. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="HyperGeometric" type="ers:HyperGeometric.type">
				<xs:annotation>
					<xs:documentation>Discrete probability distribution that describes the number of successes
						in a sequence of n draws from a finite population without replacement. See also <h:a
							href="http://en.wikipedia.org/wiki/Hypergeometric_distribution">Wikipedia
							article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Poisson" type="ers:Poisson.type">
				<xs:annotation>
					<xs:documentation>Discrete propability distribution of a number of events occurring in a
						fixed period of time if these events occur with a known average rate lambda. See also
						the <h:a href="http://en.wikipedia.org/wiki/Poisson_distribution">Wikipedia
							article</h:a>. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Logarithmic" type="ers:Logarithmic.type">
				<xs:annotation>
					<xs:documentation>Discrete propability distribution. See also <h:a
							href="http://en.wikipedia.org/wiki/Logarithmic_distribution">Wikipedia article</h:a>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Uniform.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="LowerBoundExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="UpperBoundExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="lowerBound" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The lowest possible value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="upperBound" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The highest possible value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Triangular.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="LowerBoundExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="UpperBoundExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ModeExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="lowerBound" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The lowest possible value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="upperBound" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The highest possible value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="mode" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The value with the highest probability.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Normal.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="MeanExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="StandardDeviationExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="mean" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>Also called "expected value".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="standardDeviation" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>Also called "expected value".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Binomial.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="N-Expr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="P-Expr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="n" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Number of independent yes/no experiments.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="p" type="ers:Probability" use="optional">
			<xs:annotation>
				<xs:documentation>Success probability.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="NegBinomial.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="R-Expr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="P-Expr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="r" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Number of successes.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="p" type="ers:Probability" use="optional">
			<xs:annotation>
				<xs:documentation>Success probability.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Poisson.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="LambdaExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="lambda" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>
					<h:p>Average rate of event occurrences in the given interval.</h:p>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Exponential.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="LambdaExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="lambda" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>
					<h:p>Average rate of event occurrences in the given interval. </h:p>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Logarithmic.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="P-Expr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="p" type="ers:Probability" use="optional"> </xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="HyperGeometric.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
				name="TotalPopulationSizeExpr" type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
				name="SuccessesPopulationSizeExpr" type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="NumberOfDrawsExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="totalPopulationSize" type="xs:positiveInteger"
			use="optional"/>
		<xs:attribute form="unqualified" name="successPopulationSize" type="xs:positiveInteger"
			use="optional">
			<xs:annotation>
				<xs:documentation>Size of the population the elements of which represent
					success</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="numberOfDraws" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Sample size</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Gamma.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ShapeExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RateExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="shape" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>The shape paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="rate" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>The rate paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Erlang.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ShapeExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RateExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="shape" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>The shape paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="rate" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>The rate paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Weibull.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ShapeExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ScaleExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="shape" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>The shape paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="scale" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>The scale paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** Special Data Types  *** -->
	<!-- =================================================================== -->
	<xs:simpleType name="Probability">
		<xs:restriction base="xs:double">
			<xs:minExclusive value="0.0"/>
			<xs:maxExclusive value="1.0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PositiveDouble">
		<xs:restriction base="xs:double">
			<xs:minExclusive value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListOfBytes">
		<xs:list itemType="xs:unsignedByte"/>
	</xs:simpleType>
	<xs:simpleType name="ByteTriple.type">
		<xs:restriction base="ers:ListOfBytes">
			<xs:length value="3"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListOfInt">
		<xs:list itemType="xs:int"/>
	</xs:simpleType>
	<xs:simpleType name="IntTriple.type">
		<xs:restriction base="ers:ListOfInt">
			<xs:minLength value="1"/>
			<xs:maxLength value="3"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListOfLong">
		<xs:list itemType="xs:long"/>
	</xs:simpleType>
	<xs:simpleType name="ListOfDouble">
		<xs:list itemType="xs:double"/>
	</xs:simpleType>
	<xs:simpleType name="DoubleTriple.type">
		<xs:restriction base="ers:ListOfDouble">
			<xs:minLength value="1"/>
			<xs:maxLength value="3"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="UpperMultiplicity">
		<xs:restriction base="xs:string">
			<xs:pattern value="unbounded|([0-9])*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CanonicalName">
		<xs:restriction base="xs:string">
			<xs:pattern value="([A-Z]|[a-z]|_)([A-Z]|[a-z]|_|[0-9])*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PathName">
		<xs:restriction base="xs:string">
			<xs:pattern value="([A-Z]|[a-z]|_)([A-Z]|[a-z]|_|[0-9]|.)*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="JavaTypeName">
		<xs:restriction base="xs:string">
			<xs:pattern value="([A-Z]|[a-z]|_)([A-Z]|[a-z]|_|[0-9]|.)*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListOfCanonicalName">
		<xs:list itemType="ers:CanonicalName"/>
	</xs:simpleType>
	<xs:simpleType name="JavaConstantName">
		<xs:restriction base="xs:string">
			<xs:pattern value="([A-Z])([A-Z]|_|[0-9])*"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- =================================================================== -->
	<!-- *** Code Lists  *** -->
	<!-- =================================================================== -->
	<xs:simpleType name="LengthUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="mm"/>
			<xs:enumeration value="cm"/>
			<xs:enumeration value="m"/>
			<xs:enumeration value="km"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="WeightUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="mg"/>
			<xs:enumeration value="g"/>
			<xs:enumeration value="kg"/>
			<xs:enumeration value="t"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AreaUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="mm²"/>
			<xs:enumeration value="cm²"/>
			<xs:enumeration value="m²"/>
			<xs:enumeration value="ar"/>
			<xs:enumeration value="ha"/>
			<xs:enumeration value="km²"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="VolumeUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="mm³"/>
			<xs:enumeration value="cm³"/>
			<xs:enumeration value="liter"/>
			<xs:enumeration value="m³"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TimeUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ms"/>
			<xs:enumeration value="s"/>
			<xs:enumeration value="min"/>
			<xs:enumeration value="h"/>
			<xs:enumeration value="D"/>
			<xs:enumeration value="W"/>
			<xs:enumeration value="M"/>
			<xs:enumeration value="Y"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CurrencySymbol">
		<xs:restriction base="xs:string">
			<xs:enumeration value="USD($)"/>
			<xs:enumeration value="EUR(€)"/>
			<xs:enumeration value="GBP(£)"/>
			<xs:enumeration value="AUD($)"/>
			<xs:enumeration value="BRL(R$)"/>
			<xs:enumeration value="CAD($)"/>
			<xs:enumeration value="CLP($)">
				<xs:annotation>
					<xs:documentation>Chilean Peso</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="CNY">
				<xs:annotation>
					<xs:documentation>Chinese Yuan</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="JPY(¥)">
				<xs:annotation>
					<xs:documentation>Japanes Yen</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="INR(₨)">
				<xs:annotation>
					<xs:documentation>Indian rupee</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IDR">
				<xs:annotation>
					<xs:documentation>Rupiah (INDONESIA)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ILS(₪)">
				<xs:annotation>
					<xs:documentation>Israeli Sheqel</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="KRN(₩)">
				<xs:annotation>
					<xs:documentation>Won (KOREA)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MYR">
				<xs:annotation>
					<xs:documentation>Malaysian Ringgit</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PLN">
				<xs:annotation>
					<xs:documentation>Zloty (POLAND)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RON">
				<xs:annotation>
					<xs:documentation>New Leu (ROMANIA)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RUB">
				<xs:annotation>
					<xs:documentation>Russian Ruble</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ZAR">
				<xs:annotation>
					<xs:documentation>Rand (SOUTH AFRICA)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="TRY">
				<xs:annotation>
					<xs:documentation>Turkish Lira</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="MathUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="°">
				<xs:annotation>
					<xs:documentation>Degree</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RAD">
				<xs:annotation>
					<xs:documentation>Radians</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="%">
				<xs:annotation>
					<xs:documentation>Percent</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="‰">
				<xs:annotation>
					<xs:documentation>Permil</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PhysicalUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="mA">
				<xs:annotation>
					<xs:documentation>Milli-Ampere</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="A">
				<xs:annotation>
					<xs:documentation>Ampere</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="mV">
				<xs:annotation>
					<xs:documentation>Milli-Volt</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="V">
				<xs:annotation>
					<xs:documentation>Volt</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="°C">
				<xs:annotation>
					<xs:documentation>Degree Celsius</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="°F">
				<xs:annotation>
					<xs:documentation>Degree Fahrenheit</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="K">
				<xs:annotation>
					<xs:documentation>Degree Kelvin</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Ω">
				<xs:annotation>
					<xs:documentation>Ohm</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Hz">
				<xs:annotation>
					<xs:documentation>Hertz</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="C">
				<xs:annotation>
					<xs:documentation>Coulomb</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="F">
				<xs:annotation>
					<xs:documentation>Farad</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="N">
				<xs:annotation>
					<xs:documentation>Newton</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="J">
				<xs:annotation>
					<xs:documentation>Joule</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Pa">
				<xs:annotation>
					<xs:documentation>Pascal</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!-- =================================================================== -->
	<xs:element name="UserInterface" type="ers:UserInterface.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="UserInterface.type">
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:InitialStateUI"/>
			<xs:element minOccurs="0" ref="ers:StatisticsUI"/>
			<xs:element minOccurs="0" ref="ers:AnimationUI"/>
		</xs:sequence>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="StatisticsUI">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="StatisticsVariableUI">
					<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="ers:Label"/>
							<xs:element ref="ers:Hint"/>
							<xs:element form="qualified" minOccurs="0" name="Format">
								<xs:complexType>
									<xs:group ref="ers:Units.elemGrp"/>
									<xs:attribute form="unqualified" name="decimalPlaces" type="xs:nonNegativeInteger"
										use="required"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
						<xs:attribute form="unqualified" name="comparisonGroup" type="ers:CanonicalName"
							use="optional">
							<xs:annotation>
								<xs:documentation>This attribute allows to assign a user-defined comparison group
									name to a variable, such that all variables with this comparison group name will
									be charted in a single comparison chart.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="showChart" type="xs:boolean" use="optional">
							<xs:annotation>
								<xs:documentation>This attribute allows to specify that the variable's time series
									should be shown in a chart. It makes only sense for variables that have distinct
									values at different simulations steps such that their temporal variation is of
									interest.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
					name="FrequencyDistributionChart">
					<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
					<xs:annotation>
						<xs:documentation>An object property chart shows the relative frequencies of property
							values for the population/extension of an object type at the end of a simulation run.
							For a property of type Float, value intervals have to be defined with the help of the
							intervalBoundaries attribute.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attribute form="unqualified" name="objectPropertyStatisticsVariable"
							type="ers:CanonicalName" use="required"/>
						<xs:attribute form="unqualified" name="minValue" type="xs:double" use="optional"/>
						<xs:attribute form="unqualified" name="maxValue" type="xs:double" use="optional"/>
						<xs:attribute form="unqualified" name="intervalSize" type="xs:double" use="optional">
							<xs:annotation>
								<xs:documentation>The <h:code>intervalSize</h:code> attribute allows to define a
									sequence of intervals based on <h:code>minValue</h:code> and
										<h:code>maxValue</h:code>. E.g., the attribute settings minValue="10"
									intervalSize="2" maxValue="16" defines the 3 intervals (10,12], (12,14] and
									(14,16]. </xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="chartType" use="optional">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="BAR"/>
									<xs:enumeration value="PIE"/>
									<xs:enumeration value="PIE3D"/>
									<xs:enumeration value="AREA"/>
									<xs:enumeration value="LINE"/>
									<xs:enumeration value="STEP"/>
									<xs:enumeration value="STEP_AREA"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:group name="Units.elemGrp">
		<xs:choice>
			<xs:element form="qualified" name="Currency" type="ers:CurrencySymbol"/>
			<xs:element form="qualified" name="Length" type="ers:LengthUnit"/>
			<xs:element form="qualified" name="Weight" type="ers:WeightUnit"/>
			<xs:element form="qualified" name="Time" type="ers:TimeUnit"/>
			<xs:element form="qualified" name="Area" type="ers:AreaUnit"/>
			<xs:element form="qualified" name="Volume" type="ers:VolumeUnit"/>
			<xs:element form="qualified" name="Math" type="ers:MathUnit"/>
			<xs:element form="qualified" name="Physics" type="ers:PhysicalUnit"/>
		</xs:choice>
	</xs:group>
	<!-- =================================================================== -->
	<xs:element name="InitialStateUI">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:GlobalVariableUI"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:EventUI"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ObjectUI"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:AgentUI"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="AnimationUI">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" minOccurs="0" name="DisplayDescription"
					type="ers:AnyXHTML.type"/>
				<!-- <xs:element ref="ers:Scales" minOccurs="0"/> -->
				<xs:element form="qualified" name="Views">
					<xs:complexType>
						<xs:sequence>
							<xs:element minOccurs="0" ref="ers:SpaceView"/>
							<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ObjectView"/>
							<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:PhysicalObjectView"/>
							<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:EventAppearance"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute form="unqualified" name="introSoundFile" type="xs:anyURI" use="optional">
				<xs:annotation>
					<xs:documentation>The source file can be mp3 or midi. It is identified by its extension
						(.mp3 or .mid). The file is searched first in the project folder under "media/sounds".
						If the file is not found then it is searched in the global media/sounds folder. If still
						not found, then no sound is played. Note that the path is relative to the media/sounds
						folder (of the project or the global one). </xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="EventUI">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:PropertyUI"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="eventType" type="ers:CanonicalName"/>
			<xs:attributeGroup ref="ers:EntityUI.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:attributeGroup name="EntityUI.attributes">
		<!-- =================================================================== -->
		<xs:attribute form="unqualified" name="nmrOfInstances" use="optional">
			<xs:simpleType>
				<xs:restriction base="xs:integer">
					<xs:minInclusive value="1"/>
					<xs:maxInclusive value="7"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:element name="ObjectUI">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:PropertyUI"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName"/>
			<xs:attributeGroup ref="ers:EntityUI.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="AgentUI">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:PropertyUI"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:SelfBeliefPropertyUI"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:BeliefEntityUI"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="agentType" type="ers:CanonicalName"/>
			<xs:attributeGroup ref="ers:EntityUI.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="PropertyUI" type="ers:PropertyUI.type"/>
	<xs:element name="SelfBeliefPropertyUI" type="ers:PropertyUI.type"/>
	<xs:element name="BeliefPropertyUI" type="ers:PropertyUI.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="PropertyUI.type">
		<xs:sequence>
			<xs:element ref="ers:Label"/>
			<xs:element ref="ers:Hint"/>
			<xs:element minOccurs="0" ref="ers:Unit"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="property" type="ers:CanonicalName" use="required"/>
		<xs:attributeGroup ref="ers:inputFieldLength.attrGrp"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="inputFieldLength.attrGrp">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="inputFieldLength" use="optional">
			<xs:annotation>
				<xs:documentation>The length of the property input field in cm. </xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:float">
					<xs:minExclusive value="0.0"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Unit">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:group ref="ers:Units.elemGrp"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Label">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:Text"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Hint">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:Text"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="FlyOver">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:Text"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="GlobalVariableUI">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:sequence>
					<xs:element ref="ers:Label"/>
					<xs:element ref="ers:Hint"/>
					<xs:element minOccurs="0" ref="ers:Unit"/>
				</xs:sequence>
			</xs:sequence>
			<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
			<xs:attributeGroup ref="ers:inputFieldLength.attrGrp"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="BeliefEntityUI">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:BeliefPropertyUI"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="beliefEntityType" type="ers:CanonicalName"/>
			<xs:attributeGroup ref="ers:EntityUI.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="SpaceView" type="ers:SpaceView.type">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>
				<h:p>A space view allows to define in which way the space model will be visualized. If no
					space view is defined, the default visualization applies. By default, the entire display
					area will be used. The space parameters <h:code>xMax</h:code> and <h:code>yMax</h:code>
					(representing spatial distance units such as mm or m) are mapped to the space view
					parameters displayWidth and displayHeight (representing screen pixels). For physical
					objects in a non-discrete space, the resulting scale factors scaleX =
						displayWidth/<h:code>xMax</h:code> and scaleY = displayHeight/<h:code>yMax</h:code> are
					applied to the position coordinates <h:code>x</h:code> and <h:code>y</h:code> (of the
					object's center), as well as to the physical extension parameters <h:code>width</h:code>
					and <h:code>height</h:code>.</h:p>
				<h:p>In the case of a discrete space model, object view shapes are positioned by placing
					them somewhere in the cell corresponding to the object's coordinates. The physical size
					and shape of an object are not significant, since these space models abtsracts away from
					them.</h:p>
				<h:p>For more information about the concepts of color and opacity, and the related
					attributes <h:code>stroke</h:code>, <h:code>fill</h:code>, <h:code>opacity</h:code> and
						<h:code>fill-opacity</h:code>, see also the <h:a
						href="http://www.w3.org/TR/SVGTiny12/painting.html#ColorProperty">SVG
						specification</h:a>. </h:p>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="SpaceView.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:sequence>
				<xs:element form="qualified" minOccurs="0" name="OneDimensionalSpaceView2D"
					type="ers:OneDimensionalSpaceView2D.type">
					<xs:annotation>
						<xs:documentation>A 2D visualization of a 1D space, which can be visualized in 3 ways:
							as a horizontal, vertical or circular track, using a birds-eye view.
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element form="qualified" minOccurs="0" name="OneDimensionalSpaceView3D"
					type="ers:OneDimensionalSpaceView3D.type">
					<xs:annotation>
						<xs:documentation>A 3D visualization of a 1D space, which can be visualized in 3 ways:
							as a horizontal, vertical or circular track, using a birds-eye view.
						</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:sequence>
				<xs:element form="qualified" minOccurs="0" name="TwoDimensionalSpaceView2D"
					type="ers:TwoDimensionalSpaceView2D.type">
					<xs:annotation>
						<xs:documentation>A 2D visualization of a 2D space. </xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element form="qualified" minOccurs="0" name="TwoDimensionalSpaceView3D"
					type="ers:TwoDimensionalSpaceView3D.type">
					<xs:annotation>
						<xs:documentation>A 3D visualization of a 2D space. </xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:sequence>
				<xs:element form="qualified" minOccurs="0" name="TwoDimensionalGridSpaceView2D"
					type="ers:TwoDimensionalGridSpaceView2D.type">
					<xs:annotation>
						<xs:documentation>A 2D visualization of a 2D grid space, which allows to define grid
							cell property maps for visualizing grid cell properties (by mapping them to one of the
							cell view properties <h:code>fill</h:code> and <h:code>fill-opacity</h:code>).
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element form="qualified" minOccurs="0" name="TwoDimensionalGridSpaceView3D"
					type="ers:TwoDimensionalGridSpaceView3D.type">
					<xs:annotation>
						<xs:documentation>A 3D visualization of a 2D grid space, which allows to define grid
							cell property maps for visualizing grid cell properties (by mapping them to one of the
							cell view properties <h:code>fill</h:code> and <h:code>fill-opacity</h:code>).
						</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
		</xs:choice>
		<xs:attribute form="unqualified" name="canvasColor" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the fill color of the drawing area around the space view.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="canvasColorRGB" type="ers:RGB.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the fill color of the drawing area around the space view.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="OneDimensionalSpaceView2D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="mode" type="ers:OneDimensionalMode.type" use="required">
			<xs:annotation>
				<xs:documentation>A 1D space can be visualized in 3 ways: as a horizontal, vertical or
					circular track, using a birds-eye view. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="trackWidth" type="ers:Pixel-OR-Percent.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>Defines the width of the track(s). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="trackColor" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the track(s). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="trackColorRGB" type="ers:RGB.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the track(s). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="OneDimensionalMode.type">
		<xs:restriction base="xs:string">
			<xs:enumeration value="horizontal"/>
			<xs:enumeration value="vertical"/>
			<xs:enumeration value="circular"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="OneDimensionalSpaceView3D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexContent>
			<xs:extension base="ers:OneDimensionalSpaceView2D.type">
				<xs:sequence>
					<xs:element minOccurs="0" ref="ers:Skybox"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="TwoDimensionalSpaceView2D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" minOccurs="0" name="OverlayGrid">
				<xs:complexType>
					<xs:attribute form="unqualified" name="numberOfGridCellsX" use="required">
						<xs:annotation>
							<xs:documentation xml:lang="en">The number of grid cells in X direction.
							</xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:integer">
								<xs:minInclusive value="2"/>
								<xs:maxInclusive value="150"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="numberOfGridCellsY" use="required">
						<xs:annotation>
							<xs:documentation xml:lang="en">The number of grid cells in X direction.
							</xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:integer">
								<xs:minInclusive value="2"/>
								<xs:maxInclusive value="100"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="gridOriginX" use="optional">
						<xs:annotation>
							<xs:documentation xml:lang="en">The horizontal pixel number of the left lower corner
								of the grid. </xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:integer">
								<xs:minInclusive value="0"/>
								<xs:maxInclusive value="1500"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="gridOriginY" use="optional">
						<xs:annotation>
							<xs:documentation xml:lang="en">The vertical pixel number of the left lower corner of
								the grid. </xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:integer">
								<xs:minInclusive value="0"/>
								<xs:maxInclusive value="1000"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="gridCellWidth" type="ers:GridCellSize.type"
						use="optional">
						<xs:annotation>
							<xs:documentation xml:lang="en">The width of a grid cell in pixels.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute form="unqualified" name="gridCellHeight" type="ers:GridCellSize.type"
						use="optional">
						<xs:annotation>
							<xs:documentation xml:lang="en">The height of a grid cell in pixels.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attributeGroup ref="ers:GridStroke.attributes"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="ers:SpaceViewBackground.attributes"/>
		<xs:attribute form="unqualified" name="borderColor" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the border line. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="borderColorRGB" type="ers:RGB.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the border line. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="GridCellSize.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:integer">
			<xs:minInclusive value="10"/>
			<xs:maxInclusive value="200"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="TwoDimensionalSpaceView3D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexContent>
			<xs:extension base="ers:TwoDimensionalSpaceView2D.type">
				<xs:sequence>
					<xs:element minOccurs="0" ref="ers:Skybox"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="TwoDimensionalGridSpaceView2D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="4" minOccurs="0"
				name="GridCellPropertyVisualizationMap">
				<xs:annotation>
					<xs:documentation>A function that maps an object property to a grid cell view property for
						visualizing it. The <h:code>mapType</h:code> attribute allows to specify the type of
						function: polynomial, casewise constant, equality-casewise or enumeration. A polynomial
						function has the form y = a<h:sub>3</h:sub>x<h:sup>3</h:sup> +
							a<h:sub>2</h:sub>x<h:sup>2</h:sup> + a<h:sub>1</h:sub>x + a<h:sub>0</h:sub>, where x
						is the object property and y is the grid cell view property. The casewise constant
						function is defined by y = v<h:sub>0</h:sub> if x &lt; a<h:sub>0</h:sub>, y =
							v<h:sub>1</h:sub> if a<h:sub>0</h:sub> &lt;= x &lt; a<h:sub>1</h:sub>, etc. A map may be
						defined by equality cases as y = v<h:sub>0</h:sub> if  x = a<h:sub>0</h:sub>, y =
							v<h:sub>1</h:sub> if x = a<h:sub>1</h:sub>, etc. Finally, a map may be defined on an
						enumeration property by equality cases as y = v<h:sub>0</h:sub> if  x = enumLit(1), y =
							v<h:sub>1</h:sub> if x = enumLit(2), etc. </xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:attribute form="unqualified" name="cellViewProperty" type="ers:CellViewProperty.type"
						use="required"/>
					<xs:attributeGroup ref="ers:Map.attrgrp"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="fill1" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The cells of a grid can be colored like a chess board (with
					colors <h:code>fill1</h:code> and <h:code>fill2</h:code>).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="fill1RGB" type="ers:RGB.type" use="optional"/>
		<xs:attribute form="unqualified" name="fill2" type="ers:Color.type" use="optional"/>
		<xs:attribute form="unqualified" name="fill2RGB" type="ers:RGB.type" use="optional"/>
		<!-- 
		<xs:attribute name="fillOpacity" type="ers:Probability" use="optional"/>
-->
		<xs:attributeGroup ref="ers:SpaceViewBackground.attributes"/>
		<xs:attributeGroup ref="ers:GridStroke.attributes"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="CellViewProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:NCName">
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<!-- 
				<xs:enumeration value="fillOpacity"/>
-->
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="TwoDimensionalGridSpaceView3D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexContent>
			<xs:extension base="ers:TwoDimensionalGridSpaceView2D.type">
				<xs:sequence>
					<xs:element minOccurs="0" ref="ers:Skybox"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Skybox">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="top" type="xs:anyURI" use="optional"/>
			<xs:attribute form="unqualified" name="bottom" type="xs:anyURI" use="optional"/>
			<xs:attribute form="unqualified" name="left" type="xs:anyURI" use="optional"/>
			<xs:attribute form="unqualified" name="right" type="xs:anyURI" use="optional"/>
			<xs:attribute form="unqualified" name="front" type="xs:anyURI" use="optional"/>
			<xs:attribute form="unqualified" name="back" type="xs:anyURI" use="optional"/>
			<!--			<xs:attribute name="cubicTexture" type="xs:anyURI" use="optional"/>
-->
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="SpaceViewBackground.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="backgroundColor" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the background color of the space view area with a color name.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="backgroundColorRGB" type="ers:RGB.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the background color of the space view area with a Red-Green-Blue
					value triple. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="backgroundImage" type="xs:anyURI" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">Allows to load an image as the background of the space view
					area. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="GridStroke.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="stroke" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the grid lines with a color name. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="strokeRGB" type="ers:RGB.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the grid lines with a Red-Green-Blue value triple.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="strokeWidth" type="ers:Pixel-OR-Percent.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>Defines the width of the grid stroke. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:attributeGroup name="Map.attrgrp">
		<!-- =================================================================== -->
		<xs:attribute form="unqualified" name="property" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="mapType" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="polynomial">
						<xs:annotation>
							<xs:documentation>A polynomial map with y = a<h:sub>3</h:sub>x<h:sup>3</h:sup> +
									a<h:sub>2</h:sub>x<h:sup>2</h:sup> + a<h:sub>1</h:sub>x + a<h:sub>0</h:sub>, where
								x is the physical object property and y is the shape property.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="caseWise">
						<xs:annotation>
							<xs:documentation>A casewise constant function with y = v<h:sub>0</h:sub> if  x &lt;
									a<h:sub>0</h:sub>, y = v<h:sub>1</h:sub> if  a<h:sub>0</h:sub> &lt;= x &lt;
									a<h:sub>1</h:sub>, etc.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="equalityCaseWise">
						<xs:annotation>
							<xs:documentation>A function defined by equality cases as y = v<h:sub>0</h:sub> if  x
								= a<h:sub>0</h:sub>, y = v<h:sub>1</h:sub> if x = a<h:sub>1</h:sub>,
								etc.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="enumerationMap">
						<xs:annotation>
							<xs:documentation>A function on an enumeration property defined by equality cases as y
								= v<h:sub>0</h:sub> if  x = enumLit(1), y = v<h:sub>1</h:sub> if x = enumLit(2),
								etc.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute form="unqualified" name="a0" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="a1" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="a2" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="a3" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="v0" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="v1" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="v2" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="v3" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="v4" type="xs:string" use="optional"/>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="ShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="z"/>
			<xs:enumeration value="width"/>
			<xs:enumeration value="height"/>
			<xs:enumeration value="depth"/>
			<xs:enumeration value="r"/>
			<xs:enumeration value="rx"/>
			<xs:enumeration value="ry"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="stroke-width"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fill-opacity"/>
			<xs:enumeration value="url"/>
			<xs:enumeration value="textureFile"/>
			<xs:enumeration value="surface-color"/>
			<xs:enumeration value="text"/>
			<xs:enumeration value="points"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- =================================================================== -->
	<xs:element name="PhysicalObjectView" type="ers:PhysicalObjectView.type">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Defines a view for physical objects.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="PhysicalObjectView.type">
		<xs:sequence>
			<xs:choice maxOccurs="2" minOccurs="1">
				<xs:choice minOccurs="0">
					<xs:element ref="ers:PhysicalShape2D"/>
					<xs:element form="qualified" name="PhysicalShape2dMap">
						<xs:complexType>
							<xs:sequence>
								<xs:element form="qualified" maxOccurs="unbounded" name="Case">
									<xs:complexType>
										<xs:sequence>
											<xs:element ref="ers:PhysicalShape2D"/>
										</xs:sequence>
										<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
									</xs:complexType>
								</xs:element>
							</xs:sequence>
							<xs:attribute form="unqualified" name="property" type="ers:CanonicalName"
								use="required"/>
						</xs:complexType>
					</xs:element>
				</xs:choice>
				<xs:element minOccurs="0" ref="ers:PhysicalShape3D"/>
			</xs:choice>
			<xs:group ref="ers:ViewAnnotation.elements"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:EmbeddedView">
				<xs:annotation>
					<xs:documentation>Allows defining nested views. Not yet implemented!</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="physicalObjectType" type="ers:CanonicalName"
			use="optional"/>
		<xs:attribute form="unqualified" name="physicalObjectIdRef" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="physicalObjectStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="physicalObjectEndID" type="xs:long" use="optional"/>
		<xs:attributeGroup ref="ers:ViewDisplay.attributes"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="ObjectView" type="ers:ObjectView.type">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Defines a view for non-physical objects.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="ObjectView.type">
		<xs:sequence>
			<xs:choice maxOccurs="2" minOccurs="1">
				<xs:choice minOccurs="0">
					<xs:element minOccurs="0" ref="ers:Shape2D"/>
					<xs:element form="qualified" minOccurs="0" name="Shape2dMap">
						<xs:complexType>
							<xs:sequence>
								<xs:element form="qualified" maxOccurs="unbounded" name="Case">
									<xs:complexType>
										<xs:sequence>
											<xs:element ref="ers:Shape2D"/>
										</xs:sequence>
										<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
									</xs:complexType>
								</xs:element>
							</xs:sequence>
							<xs:attribute form="unqualified" name="property" type="ers:CanonicalName"
								use="required"/>
						</xs:complexType>
					</xs:element>
				</xs:choice>
				<xs:element minOccurs="0" ref="ers:Shape3D"/>
			</xs:choice>
			<xs:group ref="ers:ViewAnnotation.elements"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:EmbeddedView">
				<xs:annotation>
					<xs:documentation>Allows defining nested views. Not yet implemented!</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="objectIdRef" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="objectStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="objectEndID" type="xs:long" use="optional"/>
		<xs:attributeGroup ref="ers:ViewDisplay.attributes"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="ViewAnnotation.elements">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" minOccurs="0" name="DisplayInfo">
				<xs:annotation>
					<xs:documentation>Allows to display either the value of an object property or a fixed
						piece of text content near the object.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Content"
							type="ers:OpaqueExpression"/>
					</xs:sequence>
					<xs:attribute form="unqualified" name="property" type="ers:CanonicalName" use="optional"/>
					<xs:attribute form="unqualified" name="content" type="xs:string" use="optional"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="ViewDisplay.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="displayID" type="xs:boolean" use="optional"/>
		<xs:attribute form="unqualified" name="displayName" type="xs:boolean" use="optional"/>
		<!--
			<xs:attribute name="scale" type="ers:CanonicalName" use="optional"/>
			<xs:attribute name="scaleValue" type="xs:NCName" use="optional"/>
		-->
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:element name="EmbeddedView">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Defines a subshape that is embedded in a view or in another embedded shape.
			</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:choice>
					<xs:element minOccurs="0" ref="ers:Shape2D"/>
					<xs:element form="qualified" minOccurs="0" name="Shape2dMap">
						<xs:complexType>
							<xs:sequence>
								<xs:element form="qualified" maxOccurs="unbounded" name="Case">
									<xs:complexType>
										<xs:sequence>
											<xs:element ref="ers:Shape2D"/>
										</xs:sequence>
										<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
									</xs:complexType>
								</xs:element>
							</xs:sequence>
							<xs:attribute form="unqualified" name="property" type="ers:CanonicalName"
								use="required"/>
						</xs:complexType>
					</xs:element>
				</xs:choice>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:EmbeddedView">
					<xs:annotation>
						<xs:documentation>Allows defining nested views.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:attribute form="unqualified" name="offsetX" type="ers:Pixel-OR-Percent.type"
				use="required"/>
			<xs:attribute form="unqualified" name="offsetY" type="ers:Pixel-OR-Percent.type"
				use="required"/>
			<xs:attribute form="unqualified" name="label" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="PhysicalShape2D">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice>
				<xs:element form="qualified" name="Square">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:SquareShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Rectangle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:RectangleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute default="CenterCenter" form="unqualified" name="positioning"
							use="optional">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="LeftBottom"/>
									<xs:enumeration value="LeftCenter"/>
									<xs:enumeration value="LeftTop"/>
									<xs:enumeration value="CenterTop"/>
									<xs:enumeration value="RightTop"/>
									<xs:enumeration value="RightCenter"/>
									<xs:enumeration value="RightBottom"/>
									<xs:enumeration value="CenterBottom"/>
									<xs:enumeration value="CenterCenter"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Triangle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:RectangleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Circle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:CircleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Ellipse">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:EllipseShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="RegularPolygon">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:PolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="numberOfPoints" use="required">
							<xs:simpleType>
								<xs:restriction base="xs:integer">
									<xs:minInclusive value="3"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Polygon">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:PolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Polyline">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:PolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
			</xs:choice>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="Shape2D">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice>
				<xs:element form="qualified" name="Square">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:SquareShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Rectangle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:RectangleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="height"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute default="CenterCenter" form="unqualified" name="positioning"
							use="optional">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="LeftBottom"/>
									<xs:enumeration value="LeftCenter"/>
									<xs:enumeration value="LeftTop"/>
									<xs:enumeration value="CenterTop"/>
									<xs:enumeration value="RightTop"/>
									<xs:enumeration value="RightCenter"/>
									<xs:enumeration value="RightBottom"/>
									<xs:enumeration value="CenterBottom"/>
									<xs:enumeration value="CenterCenter"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Triangle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:RectangleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="height"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Circle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:CircleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="r"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Ellipse">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:EllipseShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="rx"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="ry"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="RegularPolygon">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:PolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="numberOfPoints" use="required">
							<xs:simpleType>
								<xs:restriction base="xs:integer">
									<xs:minInclusive value="3"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute form="unqualified" name="diameter" type="xs:positiveInteger"
							use="optional"/>
						<xs:attribute form="unqualified" name="sideLength" type="xs:positiveInteger"
							use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Polygon">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:PolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="points" type="xs:string" use="required"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Polyline">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:PolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="points" type="xs:string" use="required"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:attribute form="unqualified" name="x" type="ers:PositiveInteger-OR-Pixel-OR-Percent.type"
				use="optional"/>
			<xs:attribute form="unqualified" name="y" type="ers:PositiveInteger-OR-Pixel-OR-Percent.type"
				use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="ShapeFillAttributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="fill" type="ers:Color.type" use="optional"/>
		<xs:attribute form="unqualified" name="fillRGB" type="ers:RGB.type" use="optional"/>
		<xs:attribute form="unqualified" name="fillOpacity" type="ers:Probability" use="optional"/>
		<xs:attribute form="unqualified" name="texture" type="xs:anyURI" use="optional"/>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="ShapeStrokeAttributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="stroke" type="ers:Color.type" use="optional"/>
		<xs:attribute form="unqualified" name="strokeRGB" type="ers:RGB.type" use="optional"/>
		<xs:attribute form="unqualified" name="strokeWidth" type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute form="unqualified" name="strokeOpacity" type="ers:Probability" use="optional"/>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="Color.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="white"/>
			<xs:enumeration value="black"/>
			<xs:enumeration value="lightgrey"/>
			<xs:enumeration value="grey"/>
			<xs:enumeration value="darkgrey"/>
			<xs:enumeration value="lightred"/>
			<xs:enumeration value="red"/>
			<xs:enumeration value="darkred"/>
			<xs:enumeration value="lightgreen"/>
			<xs:enumeration value="green"/>
			<xs:enumeration value="darkgreen"/>
			<xs:enumeration value="lightblue"/>
			<xs:enumeration value="blue"/>
			<xs:enumeration value="darkblue"/>
			<xs:enumeration value="lightyellow"/>
			<xs:enumeration value="yellow"/>
			<xs:enumeration value="orange"/>
			<xs:enumeration value="brown"/>
			<xs:enumeration value="pink"/>
			<xs:enumeration value="purple"/>
			<xs:enumeration value="aqua"/>
			<xs:enumeration value="purple"/>
			<xs:enumeration value="magenta"/>
			<xs:enumeration value="violet"/>
			<xs:enumeration value="fuchsia"/>
			<xs:enumeration value="lime"/>
			<xs:enumeration value="maroon"/>
			<xs:enumeration value="navi"/>
			<xs:enumeration value="olive"/>
			<xs:enumeration value="silver"/>
			<xs:enumeration value="teal"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="RGB.type">
		<xs:restriction base="ers:ListOfBytes">
			<xs:length value="3"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="SquareShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="width"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="RectangleShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="width"/>
			<xs:enumeration value="height"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="CircleShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="r"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="EllipseShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="rx"/>
			<xs:enumeration value="ry"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="PolygonShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="points"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ShapeSlot">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="shapeProperty" type="ers:ShapeProperty.type"
				use="required"/>
			<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ShapePropertyMap">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>Either a polynomial or a casewise constant function, or a function defined
				by equality cases (either of integers resp. strings, or of enumeration
				literals).</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute form="unqualified" name="shapeProperty" type="ers:ShapeProperty.type"
				use="required"/>
			<xs:attributeGroup ref="ers:Map.attrgrp"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="PhysicalShape3D">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice>
				<xs:element form="qualified" name="Cube">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:SquareShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:choice>
		</xs:complexType>
		<!-- 
			<xs:enumeration value="sphere"/>
			<xs:enumeration value="cuboid"/>
			<xs:enumeration value="regular_triangular_prism"/>
			<xs:enumeration value="pyramid"/>
			<xs:enumeration value="tetrahedra"/>
			<xs:enumeration value="cylinder"/>
			<xs:enumeration value="cone"/>
			<xs:enumeration value="mesh"/>
		-->
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="Shape3D"/>
	<!-- =================================================================== -->
	<!--	
	<xs:element name="Scales" type="ers:Scales.type"/>
	<xs:complexType name="Scales.type">
		<xs:sequence>
			<xs:element name="Scale" type="ers:Enumeration.type" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
-->
	<!-- =================================================================== -->
	<xs:element name="EventAppearance" type="ers:EventAppearance.type">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Associates all events of a certain type with some form of sound: either a
				MIDI note sequence or an MP3 sound file. Event properties may be sonified with the help of a
				SonificationMap.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="EventAppearance.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="16" minOccurs="0" name="MidiSound">
				<xs:complexType>
					<xs:sequence>
						<xs:element maxOccurs="3" minOccurs="0" ref="ers:SonificationMap"/>
					</xs:sequence>
					<xs:attribute form="unqualified" name="instrumentName" type="ers:Instrument.type"
						use="optional"/>
					<xs:attribute form="unqualified" name="instrumentNo" use="optional">
						<xs:simpleType>
							<xs:restriction base="xs:integer">
								<xs:minInclusive value="0"/>
								<xs:maxInclusive value="127"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="noteSequence" type="ers:NoteSequence.type"
						use="optional">
						<xs:annotation>
							<xs:documentation>         A note sequence is a list of note/duration/volume triples
								where the note is an integer between 0          (corresponding to a low C) and 127
								(in half-tones) and the duration (in ms) and          volume (in range 0 = mute to
								127 = MAX_VOLUME) are positive integers.          An example is "12/300/80
								14/200/90"        </xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="eventType" type="ers:CanonicalName" use="required"/>
		<!-- TO BE MOVED to AORSL -->
		<xs:attribute form="unqualified" name="messageType" type="ers:CanonicalName" use="optional"/>
		<!--  -->
		<xs:attribute form="unqualified" name="duration" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>The duration of the sound. If the sound source is a file and if no
					duration if specified, then the entire file is played. If deal with a sound file and a
					duration is specified with a value lower than the sound file duration then only the
					"duration" time is played from that file. If the source is a note sequence and no duration
					is specified, then the duration is computed as the sum of all note durations. If the
					source is a note sequence and a duration is defined then the duration of each note from
					sequence is multipled with a factor that ensures that the total notes duration equals with
					the value of the @duration attribute. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="soundFile" type="xs:anyURI" use="optional">
			<xs:annotation>
				<xs:documentation>The source file can be mp3 or midi. It is identified by its extension
					(.mp3 or .mid). The file is searched first in the project directory under "media/sounds".
					If the file is not found then it is searched in the media/sounds global directory. If
					still not found, then no sound is played. Note that the path is relativ to "media/sounds"
					(of the project or the global one). So a value @introSoundFile="/mySounds/background.mid"
					will be searched in "media/sounds/mySounds/background.mid" (global or the project one).
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="Instrument.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="PIANO_AcousticGrand"/>
			<xs:enumeration value="PIANO_BrightAcoustic"/>
			<xs:enumeration value="PIANO_ElectricGrand"/>
			<xs:enumeration value="PIANO_HonkyTonk"/>
			<xs:enumeration value="PIANO_EPiano1"/>
			<xs:enumeration value="PIANO_EPiano2"/>
			<xs:enumeration value="PIANO_Harpsichord"/>
			<xs:enumeration value="PIANO_Clav"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Celesta"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Glockenspiel"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_MusicBox"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Vibraphone"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Marimba"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Xylophone"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_TubularBells"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Dulcimer"/>
			<xs:enumeration value="ORGAN_DrawbarOrgan"/>
			<xs:enumeration value="ORGAN_PercussiveOrgan"/>
			<xs:enumeration value="ORGAN_RockOrgan"/>
			<xs:enumeration value="ORGAN_ChurchOrgan"/>
			<xs:enumeration value="ORGAN_ReedOrgan"/>
			<xs:enumeration value="ORGAN_Accoridan"/>
			<xs:enumeration value="ORGAN_Harmonica"/>
			<xs:enumeration value="ORGAN_TangoAccordian"/>
			<xs:enumeration value="GUITAR_AcousticGuitar_nylon"/>
			<xs:enumeration value="GUITAR_AcousticGuitar_steel"/>
			<xs:enumeration value="GUITAR_ElectricGuitar_jazz"/>
			<xs:enumeration value="GUITAR_ElectricGuitar_clean"/>
			<xs:enumeration value="GUITAR_ElectricGuitar_muted"/>
			<xs:enumeration value="GUITAR_OverdrivenGuitar"/>
			<xs:enumeration value="GUITAR_DistortionGuitar"/>
			<xs:enumeration value="GUITAR_GuitarHarmonics"/>
			<xs:enumeration value="BASS_AcousticBass"/>
			<xs:enumeration value="BASS_ElectricBass_finger"/>
			<xs:enumeration value="BASS_ElectricBass_pick"/>
			<xs:enumeration value="BASS_FretlessBass"/>
			<xs:enumeration value="BASS_SlapBass1"/>
			<xs:enumeration value="BASS_SlapBass2"/>
			<xs:enumeration value="BASS_SynthBass1"/>
			<xs:enumeration value="BASS_SynthBass2"/>
			<xs:enumeration value="STRINGS_Violin"/>
			<xs:enumeration value="STRINGS_Viola"/>
			<xs:enumeration value="STRINGS_Cello"/>
			<xs:enumeration value="STRINGS_Contrabass"/>
			<xs:enumeration value="STRINGS_TremoloStrings"/>
			<xs:enumeration value="STRINGS_PizzicatoStrings"/>
			<xs:enumeration value="STRINGS_OrchestralStrings"/>
			<xs:enumeration value="STRINGS_Timpani"/>
			<xs:enumeration value="ENSEMBLE_StringEnsemble1"/>
			<xs:enumeration value="ENSEMBLE_StringEnsemble2"/>
			<xs:enumeration value="ENSEMBLE_SynthStrings1"/>
			<xs:enumeration value="ENSEMBLE_SynthStrings2"/>
			<xs:enumeration value="ENSEMBLE_ChoirAahs"/>
			<xs:enumeration value="ENSEMBLE_VoiceOohs"/>
			<xs:enumeration value="ENSEMBLE_SynthVoice"/>
			<xs:enumeration value="ENSEMBLE_OrchestraHit"/>
			<xs:enumeration value="BRASS_Trumpet"/>
			<xs:enumeration value="BRASS_Trombone"/>
			<xs:enumeration value="BRASS_Tuba"/>
			<xs:enumeration value="BRASS_MutedTrumpet"/>
			<xs:enumeration value="BRASS_FrenchHorn"/>
			<xs:enumeration value="BRASS_BrassSection"/>
			<xs:enumeration value="BRASS_SynthBrass1"/>
			<xs:enumeration value="BRASS_SynthBrass2"/>
			<xs:enumeration value="REED_SopranoSax"/>
			<xs:enumeration value="REED_AltoSax"/>
			<xs:enumeration value="REED_TenorSax"/>
			<xs:enumeration value="REED_BaritoneSax"/>
			<xs:enumeration value="REED_Oboe"/>
			<xs:enumeration value="REED_EnglishHorn"/>
			<xs:enumeration value="REED_Bassoon"/>
			<xs:enumeration value="REED_Clarinet"/>
			<xs:enumeration value="PIPE_Piccolo"/>
			<xs:enumeration value="PIPE_Flute"/>
			<xs:enumeration value="PIPE_Recorder"/>
			<xs:enumeration value="PIPE_PanFlute"/>
			<xs:enumeration value="PIPE_BlownBottle"/>
			<xs:enumeration value="PIPE_Shakuhachi"/>
			<xs:enumeration value="PIPE_Whistle"/>
			<xs:enumeration value="PIPE_Ocarina"/>
			<xs:enumeration value="SYNTH_LEAD_Lead1"/>
			<xs:enumeration value="SYNTH_LEAD_Lead2"/>
			<xs:enumeration value="SYNTH_LEAD_Lead3"/>
			<xs:enumeration value="SYNTH_LEAD_Lead4"/>
			<xs:enumeration value="SYNTH_LEAD_Lead5"/>
			<xs:enumeration value="SYNTH_LEAD_Lead6"/>
			<xs:enumeration value="SYNTH_LEAD_Lead7"/>
			<xs:enumeration value="SYNTH_LEAD_Lead8"/>
			<xs:enumeration value="SYNTH_PAD_Pad1"/>
			<xs:enumeration value="SYNTH_PAD_Pad2"/>
			<xs:enumeration value="SYNTH_PAD_Pad3"/>
			<xs:enumeration value="SYNTH_PAD_Pad4"/>
			<xs:enumeration value="SYNTH_PAD_Pad5"/>
			<xs:enumeration value="SYNTH_PAD_Pad6"/>
			<xs:enumeration value="SYNTH_PAD_Pad7"/>
			<xs:enumeration value="SYNTH_PAD_Pad8"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX1"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX2"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX3"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX4"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX5"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX6"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX7"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX8"/>
			<xs:enumeration value="ETHNIC_Sitar"/>
			<xs:enumeration value="ETHNIC_Banjo"/>
			<xs:enumeration value="ETHNIC_Shamisen"/>
			<xs:enumeration value="ETHNIC_Koto"/>
			<xs:enumeration value="ETHNIC_Kalimba"/>
			<xs:enumeration value="ETHNIC_Bagpipe"/>
			<xs:enumeration value="ETHNIC_Fiddle"/>
			<xs:enumeration value="ETHNIC_Shanai"/>
			<xs:enumeration value="PERCUSSIVE_TinkleBell"/>
			<xs:enumeration value="PERCUSSIVE_Agogo"/>
			<xs:enumeration value="PERCUSSIVE_SteelDrums"/>
			<xs:enumeration value="PERCUSSIVE_Woodblock"/>
			<xs:enumeration value="PERCUSSIVE_TaikoDrum"/>
			<xs:enumeration value="PERCUSSIVE_MelodicTom"/>
			<xs:enumeration value="PERCUSSIVE_SynthDrum"/>
			<xs:enumeration value="PERCUSSIVE_ReverseCymbal"/>
			<xs:enumeration value="SOUND_EFFECTS_GuitarFretNoise"/>
			<xs:enumeration value="SOUND_EFFECTS_BreathNoise"/>
			<xs:enumeration value="SOUND_EFFECTS_Seashore"/>
			<xs:enumeration value="SOUND_EFFECTS_BirdTweet"/>
			<xs:enumeration value="SOUND_EFFECTS_TelephoneRing"/>
			<xs:enumeration value="SOUND_EFFECTS_Helicopter"/>
			<xs:enumeration value="SOUND_EFFECTS_Applause"/>
			<xs:enumeration value="SOUND_EFFECTS_Gunshot"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- =================================================================== -->
	<xs:element name="SonificationMap">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Either a casewise constant function or a polynomial function with y = a3x^3
				+ a2x^2 + a1x+ a0, where x is the event/object property and y is one of the four sound
				properties instrumentNo, note, duration, volume. The casewise constant function is defined
				by y = v0 if  x &lt; a0, y = v1 if  a0 &lt;= x &lt; a1, etc. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute form="unqualified" name="soundProperty" use="required">
				<xs:annotation>
					<xs:documentation>       The sound property that will be affected by this sonification
						map.        </xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="instrumentNo">
							<xs:annotation>
								<xs:documentation>          The instrument number (allowed resulting values ar in
									range of 0-127).         </xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="note">
							<xs:annotation>
								<xs:documentation>          The note number - resulting note value must be in range
									of 0-127.         </xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="duration">
							<xs:annotation>
								<xs:documentation>          The note duration. The resulting value must be positive
									or equal to 0 and is expressed in milliseconds.         </xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="volume">
							<xs:annotation>
								<xs:documentation>          The resulting value must be in range 0-127 (0 = mute,
									127 = MAX_VOLUME).         </xs:documentation>
							</xs:annotation>
						</xs:enumeration>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="ers:Map.attrgrp"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<!-- *** Special Data Types  *** -->
	<!-- =================================================================== -->
	<xs:simpleType name="PositiveInteger-OR-Pixel-OR-Percent.type">
		<xs:union memberTypes="ers:Pixel-OR-Percent.type xs:positiveInteger"/>
	</xs:simpleType>
	<xs:simpleType name="Pixel-OR-Percent.type">
		<xs:restriction base="xs:string">
			<xs:pattern value="\-?(([0-9])*px|[1-9]?[0-9]%)"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="NoteSequence.type">
		<xs:list itemType="ers:NoteDurationVolumeTriple"/>
	</xs:simpleType>
	<xs:simpleType name="NoteDurationVolumeTriple">
		<xs:annotation>
			<xs:documentation>     A note/duration/volume triple has the form N[[/D]/V] where N=0..127
				(note), D=Integer (duration), and V=0..127 (volume).    </xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern
				value="(([1-9]?|1[0-1])[0-9]|12[0-7])(/([1-9][0-9]*)(/((([1-9]?|1[0-1])[0-9]|12[0-7])))?)?"
			/>
		</xs:restriction>
	</xs:simpleType>
	<!-- =================================================================== -->
	<xs:attributeGroup name="SimulationScenario.attributes">
		<!-- =================================================================== -->
		<xs:attribute fixed="0.8.3" form="unqualified" name="version" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Indicates the AORSL version against which the
						<code>SimulationScenario</code> document must be validated.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="scenarioName" type="xs:NCName" use="required"/>
		<xs:attribute form="unqualified" name="scenarioTitle" type="xs:normalizedString" use="optional"/>
		<xs:attribute form="unqualified" name="simulationManagerDirectory" type="xs:string"
			use="optional">
			<xs:annotation>
				<xs:documentation>Indicates the file system directory in which the AOR-JavaSim program is
					located (this information is used for pretty printing).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- ======================================================================== -->
	<xs:element name="SimulationParameters" type="ers:SimulationParameters.type">
		<!-- ======================================================================== -->
		<xs:annotation>
			<xs:documentation>The attributes of the SimulationParameters element can be accessed within
				Java expressions in the form of, e.g.,
				<code>SimulationParameters.SIMULATION_STEPS</code>.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="SimulationParameters.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Parameter">
				<xs:complexType>
					<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
					<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="simulationSteps" type="xs:positiveInteger" use="required">
			<xs:annotation>
				<xs:documentation>Defines the duration of a simulation run as the number of simulation steps
					to be performed.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="1" form="unqualified" name="stepDuration" type="xs:positiveInteger"
			use="optional">
			<xs:annotation>
				<xs:documentation>This attribute is purely descriptive, and only meaningful for non-realtime
					simulation. In combination with the <code>timeUnit</code> attribute, it allows to specify
					the real (calendar time) duration that a simulation step is intended to
					represent.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="s" form="unqualified" name="timeUnit" type="ers:TimeUnit" use="optional">
			<xs:annotation>
				<xs:documentation>This attribute is purely descriptive, and only meaningful for non-realtime
					simulation. In combination with the <code>stepDuration</code> attribute, it allows to
					specify the real (calendar time) duration that a simulation step is intended to
					represent.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="stepTimeDelay" type="xs:nonNegativeInteger"
			use="optional">
			<xs:annotation>
				<xs:documentation>Defines how many miliseconds a simulation step takes (the simulator
					execution will pause accordingly). The purpose of this attribute is to allow slowing down
					a simulation run for making it better observable. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="randomSeed" type="xs:integer" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the start value for the random number generator. Allows to
					reproduce a run of a stochastic simulation model by using the same value as before.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="true" form="unqualified" name="randomOrderAgentSimulation"
			type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation>When this parameter is set to true, which is the default setting, the
					agent simulators will be executed in a random order. Otherwise, they will be executed in
					the order given by their definition sequence in the initial state definition.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<xs:attributeGroup name="SimulationModel.attributes">
		<!-- =================================================================== -->
		<xs:attribute form="unqualified" name="modelName" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="modelTitle" type="xs:normalizedString" use="optional"/>
		<xs:attribute default="false" form="unqualified" name="autoKinematics" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>Automatically update the spatial position and velocity of physical objects
					at each simulation step according to their velocity and acceleration. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="false" form="unqualified" name="autoGravitation" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>Simulate gravitation along the y-axis. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="false" form="unqualified" name="autoImpulse" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>Use impulse to update the velocities of objects participating in a
					collision. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="false" form="unqualified" name="autoCollision" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>Create a CollisionEvent when two physical objects collide.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="baseURI" type="xs:anyURI" use="optional">
			<xs:annotation>
				<xs:documentation>The base URI is used in the URIs of agent vocabulary elements.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="ers:include"/>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:element name="SimulationParameterDeclaration">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:documentation"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="type" type="ers:PrimitiveDataType" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="SpaceModel" type="ers:SpaceModel.type">
		<xs:annotation>
			<xs:documentation>The built-in space model properties such as <h:code>xMax</h:code> can be
				accessed with an expression of the form <h:code>Simulator.spaceModel.getXMax()</h:code>.
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<!-- =================================================================== -->
	<xs:complexType name="SpaceModel.type">
		<xs:annotation>
			<xs:documentation>The values of space model attributes can be accessed in Java expressions in
				the form of, e.g., <code>Simulator.spaceModel.getXMax()</code>. </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:element ref="ers:OneDimensional"/>
				<xs:element ref="ers:TwoDimensional"/>
				<xs:element ref="ers:TwoDimensional_LateralView"/>
				<xs:element ref="ers:TwoDimensionalGrid"/>
				<xs:element ref="ers:ThreeDimensional"/>
				<xs:element ref="ers:ThreeDimensionalGrid"/>
			</xs:choice>
		</xs:sequence>
		<xs:attributeGroup ref="ers:SpaceModel.attributes"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="SpaceModel.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute default="Euclidean" form="unqualified" name="geometry" use="optional">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="Euclidean"/>
					<xs:enumeration value="Toroidal"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute default="m" form="unqualified" name="spatialDistanceUnit" type="ers:LengthUnit"
			use="optional"/>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="OneDimensional">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute default="1" form="unqualified" name="multiplicity" use="optional">
				<xs:simpleType>
					<xs:restriction base="xs:integer">
						<xs:minInclusive value="1"/>
						<xs:maxInclusive value="4"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute default="false" form="unqualified" name="startCountingWithZero"
				type="xs:boolean" use="optional">
				<xs:annotation>
					<xs:documentation>In a multi-track space, count the first track as track number 0.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute default="false" form="unqualified" name="autoKinematics" type="xs:boolean"
				use="optional">
				<xs:annotation>
					<xs:documentation>Automatically update the spatial position and velocity of physical
						objects at each simulation step according to their velocity and acceleration.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute default="false" form="unqualified" name="autoCollisionHandling"
				type="xs:boolean" use="optional">
				<xs:annotation>
					<xs:documentation>Use impulse to update the velocities of objects participating in a
						collision. </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute default="false" form="unqualified" name="autoCollisionDetection"
				type="xs:boolean" use="optional">
				<xs:annotation>
					<xs:documentation>Create a CollisionEvent when two physical objects collide.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="TwoDimensional">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>This space model represents the x/z plane of the 3-dimensional coordinate
				system, that is the birds eye view.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:OverlayGrid"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="yMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute default="false" form="unqualified" name="autoKinematics" type="xs:boolean"
				use="optional">
				<xs:annotation>
					<xs:documentation>Automatically update the spatial position and velocity of physical
						objects at each simulation step according to their velocity and acceleration.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute default="false" form="unqualified" name="autoCollisionHandling"
				type="xs:boolean" use="optional">
				<xs:annotation>
					<xs:documentation>Use impulse to update the velocities of objects participating in a
						collision. </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute default="false" form="unqualified" name="autoCollisionDetection"
				type="xs:boolean" use="optional">
				<xs:annotation>
					<xs:documentation>Create a CollisionEvent when two physical objects collide.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="OverlayGrid">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="gridCellWidth" type="xs:double" use="required">
				<xs:annotation>
					<xs:documentation xml:lang="en">The width of a grid cell in spatial distance units.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute form="unqualified" name="gridCellHeight" type="xs:double" use="required">
				<xs:annotation>
					<xs:documentation xml:lang="en">The height of a grid cell in spatial distance units.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="TwoDimensional_LateralView">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>This space model represents the x/y plane of the 3-dimensional coordinate
				system, that is the lateral view. It allows to specify a value for gravitation, which is
				9.81 by default.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:OverlayGrid"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="yMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute default="9.81" form="unqualified" name="gravitation" type="xs:double"
				use="optional"/>
			<xs:attribute default="false" form="unqualified" name="autoKinematics" type="xs:boolean"
				use="optional">
				<xs:annotation>
					<xs:documentation>Automatically update the spatial position and velocity of physical
						objects at each simulation step according to their velocity and acceleration.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute default="false" form="unqualified" name="autoCollisionHandling"
				type="xs:boolean" use="optional">
				<xs:annotation>
					<xs:documentation>Use impulse to update the velocities of objects participating in a
						collision. </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute default="false" form="unqualified" name="autoCollisionDetection"
				type="xs:boolean" use="optional">
				<xs:annotation>
					<xs:documentation>Create a CollisionEvent when two physical objects collide.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="TwoDimensionalGrid">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>This discrete space, also called <h:em>grid space</h:em>, consists of cells
				for which properties and functions may be defined. The built-in cell properties
					<h:code>posX</h:code> and <h:code>posY</h:code> can be accessed with an expression of the
				form <h:code>Simulator.spaceModel.getGridCell(x,y).getPosX()</h:code>. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:group minOccurs="0" ref="ers:GridSpace.elements"/>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="yMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attributeGroup ref="ers:GridSpace.attributes"/>
			<xs:attribute default="false" form="unqualified" name="autoKinematics" type="xs:boolean"
				use="optional">
				<xs:annotation>
					<xs:documentation>Automatically update the spatial position and velocity of physical
						objects at each simulation step according to their velocity and acceleration.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ThreeDimensional">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>This discrete space consists of cells for which properties and functions may
				be defined. The built-in cell properties <h:code>posX</h:code>, <h:code>posY</h:code> and
					<h:code>posZ</h:code> can be accessed with an expression of the form
					<h:code>Simulator.spaceModel.getGridCell(x,y).getPosX()</h:code>. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="yMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="zMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute default="9.81" form="unqualified" name="gravitation" type="xs:double"
				use="optional"/>
			<xs:attribute default="false" form="unqualified" name="autoKinematics" type="xs:boolean"
				use="optional">
				<xs:annotation>
					<xs:documentation>Automatically update the spatial position and velocity of physical
						objects at each simulation step according to their velocity and acceleration.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute default="false" form="unqualified" name="autoCollisionHandling"
				type="xs:boolean" use="optional">
				<xs:annotation>
					<xs:documentation>Use impulse to update the velocities of objects participating in a
						collision. </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute default="false" form="unqualified" name="autoCollisionDetection"
				type="xs:boolean" use="optional">
				<xs:annotation>
					<xs:documentation>Create a CollisionEvent when two physical objects collide.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ThreeDimensionalGrid">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:group minOccurs="0" ref="ers:GridSpace.elements"/>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="yMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="zMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attributeGroup ref="ers:GridSpace.attributes"/>
			<xs:attribute default="9.81" form="unqualified" name="gravitation" type="xs:double"
				use="optional"/>
			<xs:attribute default="false" form="unqualified" name="autoKinematics" type="xs:boolean"
				use="optional">
				<xs:annotation>
					<xs:documentation>Automatically update the spatial position and velocity of physical
						objects at each simulation step according to their velocity and acceleration.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="GridSpace.elements">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="GridCellProperty"
				type="ers:Attribute.type">
				<xs:annotation>
					<xs:documentation>A discrete space, also called <h:em>grid space</h:em>, consists of cells
						that can have properties. These properties can be accessed with expressions of the form
							<h:code>Simulator.spaceModel.getGridCell(x,y).getProperty()</h:code>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="GridCellFunction"
				type="ers:Function.type">
				<xs:annotation>
					<xs:documentation>A discrete space, also called <h:em>grid space</h:em>, consists of cells
						for which functions can be defined (as methods of grid cell objects). These functions
						can be called with expressions of the form
							<h:code>Simulator.spaceModel.getGridCell(x,y).function(...)</h:code>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="GridSpace.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute default="unbounded" form="unqualified" name="gridCellMaxOccupancy" use="optional">
			<xs:annotation>
				<xs:documentation>The maximum of physical objects that will be placed on a grid cell at
					initialization time. Notice: this constraint is (currently) not checked at
					runtime.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:pattern value="unbounded|[1-9]\d*"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute default="false" form="unqualified" name="startCountingWithZero" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>Count the first cell as cell number 0. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:element name="Statistics" type="ers:Statistics.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Statistics.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Variable">
				<xs:annotation>
					<xs:documentation>A statistics variable is bound to a source, which is a value expression,
						a variable or an object property. It is updated in one of 3 possible ways: 1) by an
						UpdateVariable element in an environment rule, 2) at the end of the simulation run, 3)
						at the end of each simulation step by aggregating the value of ist
						source.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element form="qualified" minOccurs="0" name="Source">
							<xs:complexType>
								<xs:choice>
									<xs:element form="qualified" name="GlobalVariable">
										<xs:complexType>
											<xs:attribute form="unqualified" name="name" type="ers:CanonicalName"
												use="required"/>
										</xs:complexType>
									</xs:element>
									<xs:element form="qualified" name="StatisticsVariable">
										<xs:complexType>
											<xs:attribute form="unqualified" name="name" type="ers:CanonicalName"
												use="required"/>
										</xs:complexType>
									</xs:element>
									<xs:element form="qualified" name="ObjectProperty">
										<xs:complexType>
											<xs:attribute form="unqualified" name="property" type="ers:CanonicalName"
												use="required"/>
											<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName"
												use="required"/>
											<xs:attribute form="unqualified" name="objectIdRef" type="xs:long"
												use="optional"/>
										</xs:complexType>
									</xs:element>
									<xs:element form="qualified" name="ObjectTypeExtensionSize">
										<xs:complexType>
											<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName"
												use="required"/>
										</xs:complexType>
									</xs:element>
									<xs:element form="qualified" name="ResourceUtilization">
										<xs:complexType>
											<xs:attribute form="unqualified" name="activityType" type="ers:CanonicalName"
												use="required"/>
											<xs:attribute form="unqualified" name="resourceObjectType"
												type="ers:CanonicalName" use="required"/>
											<xs:attribute form="unqualified" name="resourceObjectIdRef" type="xs:long"
												use="optional"/>
										</xs:complexType>
									</xs:element>
									<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
								</xs:choice>
								<xs:attribute form="unqualified" name="aggregationFunction" use="optional">
									<xs:simpleType>
										<xs:restriction base="xs:string">
											<xs:enumeration value="max"/>
											<xs:enumeration value="min"/>
											<xs:enumeration value="avg"/>
											<xs:enumeration value="sum"/>
										</xs:restriction>
									</xs:simpleType>
								</xs:attribute>
								<xs:attribute form="unqualified" name="computeOnlyAtEnd" type="xs:boolean"
									use="optional"/>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
					<xs:attribute form="unqualified" name="displayName" type="xs:string" use="optional"/>
					<xs:attribute form="unqualified" name="dataType" use="required">
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:enumeration value="Integer"/>
								<xs:enumeration value="Float"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="initialValue" type="xs:string" use="optional"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="DataTypes">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Enumeration"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ComplexDataType"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:element name="ComplexDataType">
		<xs:complexType>
			<xs:choice>
				<xs:sequence>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Property"/>
					<xs:element form="qualified" maxOccurs="1" minOccurs="0" name="DefaultConstructor">
						<xs:complexType>
							<xs:sequence>
								<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Def"
									type="ers:OpaqueExpression"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Function"/>
				</xs:sequence>
				<xs:sequence>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ClassDef"
						type="ers:OpaqueExpression"/>
				</xs:sequence>
			</xs:choice>
			<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="superType" type="ers:CanonicalName" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="Globals">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="GlobalVariable">
					<xs:complexType>
						<xs:sequence>
							<xs:element minOccurs="0" ref="ers:documentation"/>
						</xs:sequence>
						<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
						<xs:attribute form="unqualified" name="dataType" type="ers:PrimitiveDataType"
							use="optional"/>
						<xs:attribute form="unqualified" name="refDataType" type="ers:CanonicalName"
							use="optional"/>
						<xs:attribute form="unqualified" name="initialValue" type="xs:string" use="optional">
							<xs:annotation>
								<xs:documentation>*** This attribute is not yet implemented! ***</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="minValue" type="xs:double" use="optional"/>
						<xs:attribute form="unqualified" name="maxValue" type="xs:double" use="optional"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="GlobalFunction"
					type="ers:Function.type"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<!-- *** EntityType *** -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="EntityType" type="ers:EntityType.type"/>
	<xs:complexType name="EntityType.type">
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:documentation"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="InitialAttributeValue">
				<xs:complexType>
					<xs:attribute form="unqualified" name="attribute" type="ers:CanonicalName" use="required"/>
					<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
				</xs:complexType>
			</xs:element>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Property"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Function"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="superType" type="ers:CanonicalName" use="optional"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** ObjectType *** -->
	<!-- =================================================================== -->
	<xs:element name="ObjectType" substitutionGroup="ers:EntityType" type="ers:ObjectType.type">
		<xs:key name="ObjectType-PropertyKey">
			<xs:selector xpath="ers:Attribute | ers:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="ObjectType.type">
		<xs:complexContent>
			<xs:extension base="ers:EntityType.type">
				<xs:sequence>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ComponentType"
						type="ers:ComponentType.type"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ComponentType.type">
		<xs:complexContent>
			<xs:extension base="ers:ObjectType.type">
				<xs:attribute default="0" form="unqualified" name="minOccurs" type="xs:nonNegativeInteger"
					use="optional"/>
				<xs:attribute default="unbounded" form="unqualified" name="maxOccurs"
					type="ers:UpperMultiplicity" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** PhysicalObjectType *** -->
	<!-- =================================================================== -->
	<xs:element name="PhysicalObjectType" substitutionGroup="ers:ObjectType"
		type="ers:PhysicalObjectType.type">
		<xs:key name="PhysicalObjectType-PropertyKey">
			<xs:selector xpath="ers:Attribute | ers:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="PhysicalObjectType.type">
		<xs:complexContent>
			<xs:extension base="ers:ObjectType.type">
				<xs:attribute default="false" form="unqualified" name="idPerceivable" type="xs:boolean"
					use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** EventType *** -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="EventType" substitutionGroup="ers:EntityType"
		type="ers:EventType.type"/>
	<xs:complexType name="EventType.type">
		<xs:complexContent>
			<xs:extension base="ers:EntityType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** Environment Event Types *** -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="EnvironmentEventType" substitutionGroup="ers:EventType"
		type="ers:EnvironmentEventType.type"/>
	<xs:complexType name="EnvironmentEventType.type">
		<xs:complexContent>
			<xs:extension base="ers:EventType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- *** CausedEventType *** -->
	<xs:element name="CausedEventType" substitutionGroup="ers:EnvironmentEventType"
		type="ers:CausedEventType.type">
		<xs:key name="CausedEventType-PropertyKey">
			<xs:selector xpath="ers:Attribute | ers:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="CausedEventType.type">
		<xs:complexContent>
			<xs:extension base="ers:EnvironmentEventType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- *** ExogeneousEventType *** -->
	<xs:element name="ExogenousEventType" substitutionGroup="ers:EnvironmentEventType"
		type="ers:ExogenousEventType.type">
		<xs:key name="ExogenousEventType-PropertyKey">
			<xs:selector xpath="ers:Attribute | ers:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="ExogenousEventType.type">
		<xs:complexContent>
			<xs:extension base="ers:EnvironmentEventType.type">
				<xs:sequence>
					<xs:element minOccurs="0" ref="ers:Periodicity"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:StopCondition"/>
				</xs:sequence>
				<xs:attribute form="unqualified" name="periodicity" type="xs:positiveInteger" use="optional"
				/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="Periodicity" type="ers:DiscreteRandomVariable-OR-ValueExpr"/>
	<xs:element name="StopCondition" type="ers:OpaqueExpression"/>
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="Entity" type="ers:Entity.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Entity.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="type" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="id" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="name" type="xs:NCName" use="optional"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="Object" substitutionGroup="ers:Entity" type="ers:Object.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Object.type">
		<xs:complexContent>
			<xs:extension base="ers:Entity.type">
				<xs:sequence>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectID"
						type="ers:OpaqueExpression"/>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Component"
						type="ers:Object.type"/>
				</xs:sequence>
				<xs:attribute form="unqualified" name="addToCollection" type="ers:CanonicalName"
					use="optional">
					<xs:annotation>
						<xs:documentation>Can be used to add the newly created object to a collection defined in
							the simulation  model.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName"
					use="optional">
					<xs:annotation>
						<xs:documentation>Allows to define an object variable that can be used in the following
							object creation statements for accessing properies and functions of that
							object.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="PhysicalObject" substitutionGroup="ers:Object" type="ers:PhysicalObject.type">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>A physical object is considered a rigid body in the sense of physics. See
				also <h:a href="http://en.wikipedia.org/wiki/Rigid_body">Wikipedia</h:a>.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="PhysicalObject.type">
		<xs:complexContent>
			<xs:extension base="ers:Object.type">
				<xs:attributeGroup ref="ers:PhysicalObject.attributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:attributeGroup name="PhysicalObject.attributes">
		<!-- =================================================================== -->
		<xs:attribute default="false" form="unqualified" name="hasRandomPosition" type="xs:boolean"
			use="optional"/>
		<xs:attribute default="false" form="unqualified" name="ignorePositionConstraint"
			type="xs:boolean" use="optional"/>
		<xs:attribute default="0" form="unqualified" name="m" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The mass of a physical object in gram.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="materialType">
			<xs:annotation>
				<xs:documentation>The material type determines the restitution and friction of a physical
					object.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="Wood"/>
					<xs:enumeration value="Iron"/>
					<xs:enumeration value="Aluminium"/>
					<xs:enumeration value="Rubber"/>
					<xs:enumeration value="Stone"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="width" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The extension of a rectangular, or cuboid-shaped, physical object is given
					in terms of width, height and depth in the unit as defined in the space model
					(spatialDistanceUnit).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="height" type="xs:double" use="optional"/>
		<xs:attribute default="0" form="unqualified" name="depth" type="xs:double" use="optional"/>
		<xs:attribute form="unqualified" name="points" type="xs:string" use="optional"/>
		<xs:attribute default="rectangle" form="unqualified" name="shape2D" use="optional">
			<xs:annotation>
				<xs:documentation>The shape of a 2D object. In the case of a circle, its radius is given by
					the width attribute. In the case of a polygon, the points attribute provides the list of
					points.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="rectangle"/>
					<xs:enumeration value="circle"/>
					<xs:enumeration value="polygon"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute default="box" form="unqualified" name="shape3D" use="optional">
			<xs:annotation>
				<xs:documentation>The shape of a 3D object. In the case of a sphere, its radius is given by
					the width attribute. In the case of a cylinder or a cone, the radius is given by the width
					attribute and the height is given by the height attribute. </xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="box"/>
					<xs:enumeration value="sphere"/>
					<xs:enumeration value="cylinder"/>
					<xs:enumeration value="cone"/>
					<xs:enumeration value="mesh"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="pos" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The linear position of a physical object given in the unit as defined in
					the space model (spatialDistanceUnit).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="x" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The x coordinate of the linear position (first component of the pos
					vector) of a physical object given in the unit as defined in the space model
					(spatialDistanceUnit).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="y" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The y coordinate of the linear position (2nd component of the pos vector)
					of a physical object given in the unit as defined in the space model
					(spatialDistanceUnit).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="z" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The z coordinate of the linear position (3rd component of the pos vector)
					of a physical object given in the unit as defined in the space model
					(spatialDistanceUnit).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="v" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The vector v = (vx,vy,vz) is the linear velocity of a physical object in
					meter/seconds. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="vx" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the linear velocity vector v = (vx,vy,vz) in m/sec.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="vy" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the linear velocity vector v = (vx,vy,vz) in m/sec.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="vz" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the linear velocity vector v = (vx,vy,vz) in m/sec.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="a" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The vector a = (ax,ay,az) is the linear acceleration of a physical object
					in meter per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="ax" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the linear acceleration vector a = (ax,ay,az) in
					meter per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="ay" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the linear acceleration vector a = (ax,ay,az) in
					meter per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="az" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the linear acceleration vector a = (ax,ay,az) in
					meter per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rot2D" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The angular position of a 2D-physical object in radians (1 rad = 180/pi =
					57.2958 degrees).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rot2DinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The angular position of a 2D-physical object in degrees.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="rot" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The vector rot = ( rotX, rotY, rotZ) is the angular position of a
					3D-physical object in radians where 1 rad = 180/pi = 57.2958 degrees, see <h:a
						href="http://wiki.secondlife.com/wiki/Rotation">Second Life</h:a> and <h:a
						href="http://en.wikipedia.org/wiki/Yaw,_pitch_and_roll">Wikipedia</h:a>.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="rotInDegrees"
			type="ers:DoubleTriple.type" use="optional">
			<xs:annotation>
				<xs:documentation>The vector rotInDegrees = ( rotXinDegrees, rotYinDegrees, rotZinDegrees)
					is the angular position of a 3D-physical object in degrees, see <h:a
						href="http://wiki.secondlife.com/wiki/Rotation">Second Life</h:a> and <h:a
						href="http://en.wikipedia.org/wiki/Yaw,_pitch_and_roll">Wikipedia</h:a>.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotX" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular position vector rot = ( rotX, rotY,
					rotZ). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotXinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular position vector rotInDegrees = (
					rotXinDegrees, rotYinDegrees, rotZinDegrees). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotY" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular position vector rot = ( rotX, rotY,
					rotZ). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotYinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular position vector rotInDegrees = (
					rotXinDegrees, rotYinDegrees, rotZinDegrees). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotZ" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular position vector rot = ( rotX, rotY,
					rotZ). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotZinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular position vector rotInDegrees = (
					rotXinDegrees, rotYinDegrees, rotZinDegrees). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omega2D" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The rotational velocity of a 2D-physical object in radians per
					second.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omega2DinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The rotational velocity of a 2D-physical object in degrees per
					second.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="omega" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The vector omega = (omegaX,omegaY,omegaZ) is the angular velocity of a
					3D-physical object in radians per second. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaX" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular velocity vector (omegaX,omegaY,omegaZ)
					in radians per second. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaY" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular velocity vector (omegaX,omegaY,omegaZ) in
					radians per second. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaZ" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular velocity vector (omegaX,omegaY,omegaZ) in
					radians per second. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="omegaInDegrees"
			type="ers:DoubleTriple.type" use="optional">
			<xs:annotation>
				<xs:documentation>The vector omegaInDegrees =
					(omegaXinDegrees,omegaYinDegrees,omegaZinDegrees) is the angular velocity of a 3D-physical
					object in degrees per second. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaXinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular velocity omegaInDegrees =
					(omegaXinDegrees,omegaYinDegrees,omegaZinDegrees) in degrees per second.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaYinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular velocity vector omegaInDegrees =
					(omegaXinDegrees,omegaYinDegrees,omegaZinDegrees) in degrees per second.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaZinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular velocity vector omegaInDegrees =
					(omegaXinDegrees,omegaYinDegrees,omegaZinDegrees) in degrees per second.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alpha2D" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The rotational acceleration of a 2D-physical object in radians per second
					squared.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alpha2DinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The rotational acceleration of a 2D-physical object in degrees per second
					squared.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="alpha" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The vector alpha = (alphaX,alphaY,alphaZ) is the angular acceleration of a
					3D-physical object in radians per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaX" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular acceleration vector alpha =
					(alphaX,alphaY,alphaZ) in radians per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaY" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular acceleration vector alpha =
					(alphaX,alphaY,alphaZ) in radians per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaZ" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular acceleration vector alpha =
					(alphaX,alphaY,alphaZ) in radians per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="alphaInDegrees"
			type="ers:DoubleTriple.type" use="optional">
			<xs:annotation>
				<xs:documentation>The vector alphaInDegrees =
					(alphaXinDegrees,alphaYinDegrees,alphaZinDegrees) is the angular acceleration of a
					3D-physical object in degrees per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaXinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular acceleration vector alphaInDegrees =
					(alphaXinDegrees,alphaYinDegrees,alphaZinDegrees) in degrees per second squared.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaYinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular acceleration vector alphaInDegrees =
					(alphaXinDegrees,alphaYinDegrees,alphaZinDegrees) in degrees per second squared.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaZinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular acceleration vector alphaInDegrees =
					(alphaXinDegrees,alphaYinDegrees,alphaZinDegrees) in degrees per second squared.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:element abstract="true" name="AtomicEvent" substitutionGroup="ers:Entity"
		type="ers:AtomicEvent.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="AtomicEvent.type">
		<xs:complexContent>
			<xs:extension base="ers:Entity.type">
				<xs:attribute form="unqualified" name="occurrenceTime" type="xs:positiveInteger"
					use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element abstract="true" name="EnvironmentEvent" substitutionGroup="ers:AtomicEvent"
		type="ers:EnvironmentEvent.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="EnvironmentEvent.type">
		<xs:complexContent>
			<xs:extension base="ers:AtomicEvent.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="ExogenousEvent" substitutionGroup="ers:EnvironmentEvent"
		type="ers:ExogeneousEvent.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="ExogeneousEvent.type">
		<xs:complexContent>
			<xs:extension base="ers:EnvironmentEvent.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="CausedEvent" substitutionGroup="ers:EnvironmentEvent"
		type="ers:ExogeneousEvent.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="CausedEvent.type">
		<xs:complexContent>
			<xs:extension base="ers:EnvironmentEvent.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="Objects" type="ers:ObjectSet.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="ObjectSet.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeStartID"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeEndID"
				type="ers:OpaqueExpression"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="type" type="xs:string" use="required"/>
		<xs:attribute form="unqualified" name="rangeStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="rangeEndID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="creationLoopVar" type="ers:CanonicalName" use="optional"
		/>
	</xs:complexType>
	<!-- ***  Physical Objects  *** -->
	<xs:element name="PhysicalObjects" substitutionGroup="ers:Objects"
		type="ers:PhysicalObjectSet.type"/>
	<xs:complexType name="PhysicalObjectSet.type">
		<xs:complexContent>
			<xs:extension base="ers:ObjectSet.type">
				<xs:attributeGroup ref="ers:PhysicalObject.attributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="GridCells">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice>
				<xs:choice maxOccurs="unbounded">
					<xs:element form="qualified" name="GridCell" type="ers:GridCell.type"/>
					<xs:element form="qualified" name="GridCellSet" type="ers:GridCellSet.type"/>
				</xs:choice>
				<xs:element maxOccurs="unbounded" ref="ers:Slot"/>
			</xs:choice>
		</xs:complexType>
	</xs:element>
	<xs:complexType name="GridCell.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" ref="ers:Slot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="x" type="xs:double" use="required"/>
		<xs:attribute form="unqualified" name="y" type="xs:double" use="required"/>
	</xs:complexType>
	<xs:complexType name="GridCellSet.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" ref="ers:Slot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="startX" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute form="unqualified" name="endX" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute form="unqualified" name="startY" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute form="unqualified" name="endY" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute form="unqualified" name="creationLoopVar" type="ers:CanonicalName" use="optional"
		/>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="Collection" substitutionGroup="ers:Object" type="ers:Collection.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Collection.type">
		<xs:complexContent>
			<xs:extension base="ers:Collection.type0">
				<xs:attribute form="unqualified" name="itemType" type="ers:CanonicalName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Collection.type0">
		<xs:complexContent>
			<xs:restriction base="ers:Object.type">
				<xs:sequence>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
				</xs:sequence>
				<xs:attribute form="unqualified" name="id" type="xs:long" use="optional"/>
				<xs:attribute form="unqualified" name="name" type="xs:NCName" use="optional"/>
				<xs:attribute form="unqualified" name="type" use="required">
					<xs:simpleType>
						<xs:restriction base="ers:CanonicalName">
							<xs:enumeration value="FIFO_QUEUE"/>
							<xs:enumeration value="LIFO_QUEUE"/>
							<xs:enumeration value="SET"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<!-- ==================================================================== -->
	<xs:complexType name="TriggeringAtomicEventExpr.type">
		<xs:attribute form="unqualified" name="eventType" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="eventVariable" type="ers:CanonicalName" use="optional"/>
	</xs:complexType>
	<!-- ==================================================================== -->
	<xs:complexType name="TriggeringEnvironmentRuleEventExpr.type">
		<!-- ==================================================================== -->
		<xs:complexContent>
			<xs:extension base="ers:TriggeringAtomicEventExpr.type">
				<xs:attribute form="unqualified" name="activityType" type="ers:CanonicalName" use="optional"
				/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- ==================================================================== -->
	<xs:element name="ON-EACH-SIMULATION-STEP">
		<!-- ==================================================================== -->
		<xs:complexType/>
	</xs:element>
	<!-- ==================================================================== -->
	<xs:element name="Condition" type="ers:Condition.type"/>
	<!-- ==================================================================== -->
	<xs:complexType name="Condition.type">
		<xs:complexContent>
			<xs:extension base="ers:OpaqueExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="IF" type="ers:Condition.type"/>
	<xs:element name="ELSE-IF" type="ers:Condition.type"/>
	<!-- =================================================================== -->
	<xs:element name="EnvironmentRules">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:EnvironmentRule"/>
			</xs:sequence>
		</xs:complexType>
		<xs:key name="RuleName">
			<xs:selector xpath="ers:EnvironmentRule"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<!-- ==================================================================== -->
	<xs:element name="EnvironmentRule" type="ers:EnvironmentRule.type"/>
	<!-- ==================================================================== -->
	<xs:complexType name="EnvironmentRule.type">
		<xs:sequence>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:documentation"/>
				<xs:choice>
					<xs:element form="qualified" name="WHEN"
						type="ers:TriggeringEnvironmentRuleEventExpr.type"/>
					<xs:element ref="ers:ON-EACH-SIMULATION-STEP"/>
				</xs:choice>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:FOR"/>
				<xs:group maxOccurs="unbounded" minOccurs="0" ref="ers:FOR.grp"/>
				<xs:element form="qualified" minOccurs="0" name="DO" type="ers:EnvRuleDO.type"/>
				<xs:sequence minOccurs="0">
					<xs:element maxOccurs="unbounded" ref="ers:IF"/>
					<xs:element form="qualified" name="THEN" type="ers:EnvRuleDO.type"/>
					<xs:element form="qualified" minOccurs="0" name="ELSE" type="ers:EnvRuleDO.type"/>
				</xs:sequence>
			</xs:sequence>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="EnvRuleDO.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:UPDATE-ENV"/>
			<xs:element form="qualified" minOccurs="0" name="SCHEDULE-EVT" type="ers:ResEnvEvtExpr.type"/>
		</xs:sequence>
	</xs:complexType>
	<!-- ==================================================================== -->
	<xs:element name="InitializationRule">
		<!-- ==================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:documentation"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:FOR"/>
				<xs:group maxOccurs="unbounded" minOccurs="0" ref="ers:FOR.grp"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:IF"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:UpdateObject"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:UpdateObjects"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:UpdateGridCell"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:UpdateGridCells"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="FOR" type="ers:VariableDeclaration.type"/>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="VariableDeclaration.type">
		<xs:annotation>
			<xs:documentation>A FOR element declares either a data variable or an object variable using
				the corresponding subelements and attributes. A data variable must be bound to a value. An
				object variable can be bound to a single object or to an object type. In the latter case the
				FOR element defines a loop over all instances of the object type. It's an option to refine
				this loop by providing a selection condition. </xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0">
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectRef"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectIdRef"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="SelectionCondition"
				type="ers:OpaqueExpression"/>
		</xs:choice>
		<xs:attribute form="unqualified" name="dataVariable" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="dataType" type="ers:PrimitiveDataType" use="optional"/>
		<xs:attribute form="unqualified" name="refDataType" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="objectIdRef" type="xs:long" use="optional">
			<xs:annotation>
				<xs:documentation>If used without specifying an @objectType, then the object vaiable is
					declared to be of type Objekt, otherwise of @objectType.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="objectName" type="xs:NCName" use="optional">
			<xs:annotation>
				<xs:documentation>If used without specifying an @objectType, then the object vaiable is
					declared to be of type Objekt, otherwise of @objectType.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="rangeStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="rangeEndID" type="xs:long" use="optional"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="FOR.grp">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:element form="qualified" name="FOR-DataVariable" type="ers:FOR-DataVariable.type">
				<xs:annotation>
					<xs:documentation>Not yet implemented! Declares a data variable that must be bound to a
						value. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="FOR-ObjectVariable" type="ers:FOR-ObjectVariable.type">
				<xs:annotation>
					<xs:documentation>Not yet implemented! Declares an object variable, which may be bound to
						a single object or to an object type. In the latter case the element defines a loop over
						all instances of the object type. It's an option to refine this loop by providing a
						selection condition. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="FOR-ListItemVariable" type="ers:FOR-ListItemVariable.type">
				<xs:annotation>
					<xs:documentation>Not yet implemented!</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="FOR-DataVariable.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element maxOccurs="unbounded" ref="ers:ValueExpr"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="dataType" type="ers:PrimitiveDataType" use="optional"/>
		<xs:attribute form="unqualified" name="refDataType" type="ers:CanonicalName" use="optional"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="FOR-ObjectVariable.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectRef"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectIdRef"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="SelectionCondition"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="objectIdRef" type="xs:long" use="optional">
			<xs:annotation>
				<xs:documentation>If used without specifying an @objectType, then the object vaiable is
					declared to be of type Objekt, otherwise of @objectType.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="objectName" type="xs:NCName" use="optional">
			<xs:annotation>
				<xs:documentation>If used without specifying an @objectType, then the object vaiable is
					declared to be of type Objekt, otherwise of @objectType.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="rangeStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="rangeEndID" type="xs:long" use="optional"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="FOR-ListItemVariable.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ListExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="listItemType" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="listValuedGlobalVariable" type="ers:CanonicalName"
			use="optional"/>
	</xs:complexType>
	<!-- ==================================================================== -->
	<!-- *** SCHEDULE-EVT for Environment Rules *** -->
	<!-- ==================================================================== -->
	<xs:complexType name="ResEnvEvtExpr.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="CausedEventExpr">
				<xs:complexType>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Condition"/>
						<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Delay"/>
						<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
					</xs:sequence>
					<xs:attribute form="unqualified" name="eventType" type="ers:CanonicalName" use="required"/>
					<xs:attribute form="unqualified" name="delay" type="xs:positiveInteger" use="optional"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="Delay" type="ers:DiscreteRandomVariable-OR-ValueExpr"/>
	<!-- =========================================================== -->
	<xs:element name="UPDATE-ENV" type="ers:UpdateObjectiveStateExpr.type"/>
	<!-- =========================================================== -->
	<xs:complexType name="UpdateObjectiveStateExpr.type">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded" minOccurs="0">
				<xs:element ref="ers:UpdateGlobalVariable"/>
				<xs:element ref="ers:IncrementGlobalVariable"/>
				<xs:element ref="ers:RemoveObjectFromCollection"/>
				<xs:element ref="ers:UpdateObject"/>
				<xs:element ref="ers:UpdateGridCell"/>
				<xs:element ref="ers:UpdateGridCells"/>
				<xs:element ref="ers:AddObjectToCollection"/>
				<xs:element ref="ers:UpdateStatisticsVariable"/>
				<xs:element ref="ers:Create"/>
				<xs:element ref="ers:DestroyObject"/>
			</xs:choice>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:UpdateObjects"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:DestroyObjects"/>
		</xs:sequence>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateGlobalVariable" type="ers:UpdateGlobalVariable.type"/>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="UpdateGlobalVariable.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="value" type="xs:string" use="optional"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="IncrementGlobalVariable">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="value" type="xs:long" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateObject">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectRef">
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="ers:OpaqueExpression">
								<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName"
									use="required"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
				<xs:choice maxOccurs="unbounded" minOccurs="0">
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Increment"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Decrement"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:MultiValuedSlot"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName" use="optional"
			/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateGridCell">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="1" name="XCoordinate"
					type="ers:OpaqueExpression"/>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="1" name="YCoordinate"
					type="ers:OpaqueExpression"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Increment"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Decrement"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="gridCellVariable" type="ers:CanonicalName"
				use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateGridCells">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:SelectionCondition"/>
				<xs:choice>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Code"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Increment"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Decrement"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute form="unqualified" name="gridCellVariable" type="ers:CanonicalName"
				use="optional"/>
			<xs:attribute form="unqualified" name="startX" type="xs:nonNegativeInteger" use="optional"/>
			<xs:attribute form="unqualified" name="endX" type="xs:nonNegativeInteger" use="optional"/>
			<xs:attribute form="unqualified" name="startY" type="xs:nonNegativeInteger" use="optional"/>
			<xs:attribute form="unqualified" name="endY" type="xs:nonNegativeInteger" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateObjects">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeStartID"
					type="ers:OpaqueExpression"/>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeEndID"
					type="ers:OpaqueExpression"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Increment"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Decrement"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="rangeStartID" type="xs:long" use="optional"/>
			<xs:attribute form="unqualified" name="rangeEndID" type="xs:long" use="optional"/>
			<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="loopVariable" type="ers:CanonicalName" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="AddObjectToCollection">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ItemObjectRef"
					type="ers:OpaqueExpression"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="collectionName" type="ers:CanonicalName" use="optional"/>
			<xs:attribute form="unqualified" name="collectionID" type="xs:long" use="optional"/>
			<xs:attribute form="unqualified" name="collectionObjectVariable" type="ers:CanonicalName"
				use="optional"/>
			<xs:attribute form="unqualified" name="itemObjectVariable" type="ers:CanonicalName"
				use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="RemoveObjectFromCollection">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ItemObjectRef"
					type="ers:OpaqueExpression"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="collectionName" type="ers:CanonicalName" use="optional"/>
			<xs:attribute form="unqualified" name="collectionID" type="xs:long" use="optional"/>
			<xs:attribute form="unqualified" name="collectionObjectVariable" type="ers:CanonicalName"
				use="optional"/>
			<xs:attribute form="unqualified" name="itemObjectVariable" type="ers:CanonicalName"
				use="optional"/>
			<xs:attribute form="unqualified" name="destroyObject" type="xs:boolean" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Increment" type="ers:Increment.type"/>
	<xs:element name="Decrement" type="ers:Increment.type"/>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Increment.type">
		<xs:attribute form="unqualified" name="property" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="value" type="xs:long" use="required"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateStatisticsVariable">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:ValueExpr"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ==================================== -->
	<!-- *** Create & Destroy *** -->
	<!-- ==================================== -->
	<xs:element name="Create">
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Object"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Objects"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:element name="DestroyObject">
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectRef"
					type="ers:OpaqueExpression"/>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectIdRef"
					type="ers:OpaqueExpression"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName" use="optional"/>
			<xs:attribute form="unqualified" name="objectIdRef" type="xs:long" use="optional"/>
			<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName" use="optional"/>
			<xs:attribute form="unqualified" name="removeFromCollection" type="ers:CanonicalName"
				use="optional"/>
			<xs:attribute default="false" form="unqualified" name="deferred" type="xs:boolean"
				use="optional">
				<xs:annotation>
					<xs:documentation>If this attribute is set to true, the object will only be destroyed at
						the end of the rule execution after the resulting events have been
						created.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="DestroyObjects" type="ers:DestroyObjects.type"/>
	<xs:complexType name="DestroyObjects.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeStartID"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeEndID"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName"/>
		<xs:attribute form="unqualified" name="rangeStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="rangeEndID" type="xs:long" use="optional"/>
		<xs:attribute default="false" form="unqualified" name="deferred" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>If this attribute is set to true, the objects will only be destroyed at
					the end of the rule execution after the resulting events have been
					created.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- ************    Root element    *********************************** -->
	<xs:element name="SimulationScenario" type="ers:SimulationScenario.type">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>
				<h:p>Consists essentially of a <h:code>SimulationModel</h:code>, an <h:code>InitialState</h:code>, and a <h:code>UserInterface</h:code> (including a statistics user interface and an animation user interface).</h:p>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="SimulationScenario.type">
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:documentation"/>
			<xs:element ref="ers:SimulationParameters"/>
			<xs:choice>
				<xs:group ref="ers:include"/>
				<xs:element ref="ers:SimulationModel"/>
			</xs:choice>
			<xs:element ref="ers:InitialState"/>
			<xs:element minOccurs="0" ref="ers:UserInterface"/>
		</xs:sequence>
		<xs:attributeGroup ref="ers:SimulationScenario.attributes"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="SimulationModel">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:documentation"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:SimulationParameterDeclaration"/>
				<xs:element minOccurs="0" ref="ers:SpaceModel"/>
				<xs:element minOccurs="0" ref="ers:Statistics"/>
				<xs:element minOccurs="0" ref="ers:DataTypes"/>
				<xs:element minOccurs="0" ref="ers:Globals"/>
				<xs:element minOccurs="0" ref="ers:EntityTypes"/>
				<xs:element minOccurs="0" ref="ers:EnvironmentRules"/>
				<xs:element minOccurs="0" ref="ers:Collections"/>
			</xs:sequence>
			<xs:attributeGroup ref="ers:SimulationModel.attributes"/>
		</xs:complexType>
		<!-- =================================================================== -->
		<!-- KEY and KEYREF constraints  -->
		<!-- =================================================================== -->
		<xs:key name="ExternalEntityTypeKey">
			<xs:selector
				xpath="ers:EntityTypes/ers:ObjectType | ers:EntityTypes/ers:PhysicalObjectType | ers:EntityTypes/ers:CausedEventType | ers:EntityTypes/ers:ExogenousEventType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:key name="ObjectTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:ObjectType | ers:EntityTypes/ers:PhysicalObjectType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="ObjectTypeReference" refer="ers:ObjectTypeKey">
			<!--
				<xs:selector xpath="ers:EnvironmentRules/ers:EnvironmentRule/ers:VariableDeclaration[@objectType != 'Collection'] | ers:EnvironmentRules/ers:EnvironmentRule/ers:UPDATE-ENV/ers:UpdateObjects"/>
			-->
			<xs:selector xpath="ers:EnvironmentRules/ers:EnvironmentRule/ers:UPDATE-ENV/ers:UpdateObjects"/>
			<xs:field xpath="@objectType"/>
		</xs:keyref>
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:key name="ReferenceTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:ObjectType | ers:EntityTypes/ers:PhysicalObjectType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="ReferenceProperty-TypeReference" refer="ers:ReferenceTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:*/ers:ReferenceProperty"/>
			<xs:field xpath="@type"/>
		</xs:keyref>
		<!--
			The following keyref cannot be used as there are predfined superclass types (such as the agent type for sincere and trustful communication)
			<xs:keyref name="ObjectType-SuperTypeReference" refer="ers:ObjectTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:ObjectType | ers:EntityTypes/ers:PhysicalObjectType"/>
			<xs:field xpath="@superType"/>
			</xs:keyref>
		-->
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:key name="EnvironmentEventTypeKey">
			<xs:selector
				xpath="ers:EntityTypes/ers:ExogenousEventType | ers:EntityTypes/ers:CausedEventType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<!--
			The following keyref cannot be used as there are predfined event types such as OutMessageEvent
			<xs:keyref name="EnvironmentEventTypeReference" refer="ers:EnvironmentEventTypeKey">
			<xs:selector xpath="ers:EnvironmentRules/ers:EnvironmentRule/ers:TriggeringAtomicEventExpr"/>
			<xs:field xpath="@eventType"/>
			</xs:keyref>
		-->
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:key name="CausedEventTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:CausedEventType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<!--
			The following keyref cannot be used as there are predfined event types such as StopSimulation
			<xs:keyref name="CausedEventTypeReference" refer="ers:CausedEventTypeKey">
			<xs:selector xpath="ers:EnvironmentRules/ers:EnvironmentRule/ers:ResultingEventExpr/ers:CausedEventExpr"/>
			<xs:field xpath="@eventType"/>
			</xs:keyref>
		-->
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="EntityTypes">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:EnvironmentEventType"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ObjectType"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="Collections">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:Collection"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="InitialState">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:choice maxOccurs="unbounded" minOccurs="0">
					<xs:element maxOccurs="unbounded" minOccurs="0" name="GlobalVariable"
						type="ers:UpdateGlobalVariable.type"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Object"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ExogenousEvent"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:CausedEvent"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Objects"/>
					<xs:element minOccurs="0" ref="ers:GridCells"/>
				</xs:choice>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:InitializationRule"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
</xs:schema>
