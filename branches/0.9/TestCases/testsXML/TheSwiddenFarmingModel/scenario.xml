<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="prettyprint.xsl"?>
<SimulationScenario version="0.8.3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://aor-simulation.org ../../../../ext/aorsl/AORSL-0-8-3.xsd"
	xmlns="http://aor-simulation.org" xmlns:aors="http://aor-simulation.org"
	xmlns:dc="http://purl.org/dc/elements/1.1/" scenarioName="TheSwiddenFarmingModel"
	scenarioTitle="The Swidden Farming Model">

	<SimulationParameters simulationSteps="100" stepDuration="1" timeUnit="Y" randomSeed="10"/>

	<SimulationModel modelName="TheSwiddenFarmingModel"
		modelTitle="Swidden Farming is designed to explore the dynamics of agricultural land management strategies.
		Specifically, the model is designed to explore some of the factors affecting swidden (sometimes
		called slash-and-burn) agriculture.">

		<documentation>
			<dc:creator>Martin MÃ¼ller</dc:creator>
			<dc:created>2010-03-21</dc:created>
			<dc:description>Swidden Farming is designed to explore the dynamics of agricultural land management strategies.
				Specifically, the model is designed to explore some of the factors affecting swidden (sometimes
				called slash-and-burn) agriculture.</dc:description>
		</documentation>
		
		<SpaceModel geometry="Toroidal" spatialDistanceUnit="m">
			<TwoDimensionalGrid xMax="60" yMax="50" gridCellMaxOccupancy="1">
				<GridCellProperty type="Integer" name="vegetation"/>
				<GridCellProperty name="fertility" type="Float"/>
				<GridCellProperty name="farmstead" type="Boolean"/>
				<GridCellProperty name="field" type="Boolean"/>
				<GridCellProperty name="owner" type="Integer"/>
				<GridCellProperty name="fallow" type="Integer"/>
			</TwoDimensionalGrid>
		</SpaceModel>
	
	<EntityTypes>
		
		<!-- events triggered by agents -->
		<ActionEventType name="UpdateMyEnergy"/>
		<ActionEventType name="FindTheBestField"/>
		<ActionEventType name="RemoveDead"/>
		<ActionEventType name="ShouldIMove" />
		<ActionEventType name="CreateNewHousehold" />
		
		<!-- events that take place independantly -->
		<ExogenousEventType name="UpdateGrid">
			<Periodicity><ValueExpr language="Java">1</ValueExpr></Periodicity>
		</ExogenousEventType>
		<ExogenousEventType name="BadYear">
			<Periodicity>
				<DiscreteRandomVariable><UniformInt lowerBound="1" upperBound="21" /></DiscreteRandomVariable>
			</Periodicity>
		</ExogenousEventType>
		
		<!-- the household -->
		<PhysicalAgentType name="Household">
			
			<Attribute type="Boolean" name="housed"/>
			<Attribute type="Integer" name="energy"/>
			<Attribute type="Integer" name="myFieldX" />
			<Attribute type="Integer" name="myFieldY" />
			
			<PeriodicTimeEventType name="UpdateMyself">
				<Periodicity><ValueExpr language="Java">1</ValueExpr></Periodicity>
			</PeriodicTimeEventType>
			
			<ReactionRule name="UpdateMyselfRule">
				<documentation>
					<dc:description>triggers the environment-rules necessary for updating</dc:description>
				</documentation>
				<WHEN eventType="UpdateMyself"/>
				<DO>
					<SCHEDULE-EVT>
						<ActionEventExpr actionEventType="RemoveDead" />
						<ActionEventExpr actionEventType="ShouldIMove" />
						<ActionEventExpr actionEventType="FindTheBestField" />
						<ActionEventExpr actionEventType="UpdateMyEnergy" />
						<ActionEventExpr actionEventType="CreateNewHousehold" />
					</SCHEDULE-EVT>
				</DO>
			</ReactionRule>
			
		</PhysicalAgentType>
		
		<!-- a helper object -->
		<ObjectType name="Helper">
			
			<Attribute type="Boolean" name="calcOK"/>
			<Attribute type="Integer" name="divisor"/>
			
			<Function name="updateEnergy" resultType="Boolean">
				<Parameter name="h" type="Household"/>
				<Body language="Java">
					<![CDATA[
						
						int harvest = 30;					//harvesing income (before deductions)
						int farm_cost = 10;					//harvesting costs this much energy
						float tree_clearing_cost = 80.0f;	//highest amount of energy needed to clear a patch (patch is forest)
						float fertility_loss = 0.05f;
						
						int maxX = (int)Simulator.spaceModel.getXMax();
				        int maxY = (int)Simulator.spaceModel.getYMax();
				        long id = h.getId();
				        
						for(int i=1; i<= maxX; i++ ){
						
						  for(int j=1; j<=maxY; j++){
						       
						      if((id == Simulator.spaceModel.getGridCell(i, j).getOwner()) && (Simulator.spaceModel.getGridCell(i, j).isField() == true)){
						          
						          int currentEnergy = (int)h.getEnergy();
						          float fertility = (float)Simulator.spaceModel.getGridCell(i, j).getFertility();
						          
						          float veg_clear_cost = (float)(tree_clearing_cost * (Simulator.spaceModel.getGridCell(i, j).getVegetation()/50));
						          int netReturn = (int)java.lang.Math.round(harvest * (fertility / this.divisor) - farm_cost - veg_clear_cost);

						          h.setEnergy(currentEnergy + netReturn);
						          Simulator.spaceModel.getGridCell(i, j).setFertility(Simulator.spaceModel.getGridCell(i, j).getFertility() - fertility_loss);
						          
						          return true;
						          
						      }//if
						  }//for
						}//for
						
						return false;
					
					]]>
					
				</Body>
			</Function>
			
			<Function name="findBestField" resultType="Boolean">
				<Parameter name="h" type="Household"/>
				<Body language="Java">
					<![CDATA[
					
						int swidden_radius = 3;
						
				        long id = h.getId();
				        int xMax = (int)h.getX() + swidden_radius;
						int yMax = (int)h.getY() + swidden_radius;
						int xMin = (int)h.getX() - swidden_radius;
						int yMin = (int)h.getY() - swidden_radius;
						
						if(xMax > (int)Simulator.spaceModel.getXMax()) xMax = (int)Simulator.spaceModel.getXMax();
						if(yMax > (int)Simulator.spaceModel.getYMax()) yMax = (int)Simulator.spaceModel.getYMax();
						if(xMin < 1) xMin = 1;
						if(yMin < 1) yMin = 1;
						
						float maxFert = 0.0f;
						int minVeg = 999;
						
						for(int i = xMin; i<=xMax; i++){
							
							for(int j = yMin; j<=yMax; j++){
								
								if((Simulator.spaceModel.getGridCell( i, j).getFertility() > maxFert) && 
									(Simulator.spaceModel.getGridCell( i, j).getVegetation() < minVeg) && 
									(Simulator.spaceModel.getGridCell( i, j).isFarmstead() == false) &&
									((Simulator.spaceModel.getGridCell( i, j).getOwner() == 0) || (Simulator.spaceModel.getGridCell( i, j).getOwner() == id))){
									
									minVeg = (int)Simulator.spaceModel.getGridCell( i, j).getVegetation();
									maxFert = (float)Simulator.spaceModel.getGridCell( i, j).getFertility();
									
									try{
										Simulator.spaceModel.getGridCell( (int)h.getMyFieldX(), (int)h.getMyFieldY()).setField(false);
									}catch(java.lang.NullPointerException n){}
									
									h.setMyFieldX(i);
									h.setMyFieldY(j);
									
									Simulator.spaceModel.getGridCell( i, j).setField(true);
									Simulator.spaceModel.getGridCell( i, j).setOwner(id);
									
								}
								
							}
							
						}
						
						return true;
						
					]]>
			
				</Body>
			</Function>
			
			<Function name="findNewHomestead" resultType="Boolean">
				<Parameter name="h" type="Household"/>
				<Body language="Java">
					<![CDATA[
					
						int xMax = (int) Simulator.spaceModel.getXMax();
						int yMax = (int) Simulator.spaceModel.getYMax();					
						int tempX, tempY; 
						int search = 0;
						int noOfCells = xMax * yMax;
						Position location = null;
						Boolean found = false;
						int owner;
						
						tempX = tempY = 1;
						
						while (search++ <= noOfCells*noOfCells && !found) {
							
							tempX = (int)Simulator.spaceModel.newX(h, tempX);
							tempY = (int)Simulator.spaceModel.newY(h, tempY); 
							
							owner = (int)Simulator.spaceModel.getGridCell(tempX, tempY).getOwner();
							
							if ( !( tempX == h.getX() && tempY == h.getY()) 
									&& owner == 0) {
									
								location = new Position( tempX, tempY);
								found = true;
								
								//clear away all "owned" fields so that they can be used by others
								for(int i = 1; i<=xMax; i++){
									for(int j = 1; j<=yMax; j++){
										
										if(Simulator.spaceModel.getGridCell( i, j).getOwner() == h.getId()){
											
											Simulator.spaceModel.getGridCell( i, j).setOwner(0);
											Simulator.spaceModel.getGridCell( i, j).setField(false);
											Simulator.spaceModel.getGridCell( i, j).setFarmstead(false);
											
										}
									}
								}
								
								//occupy new territory
								Simulator.spaceModel.getGridCell( tempX, tempY).setOwner(h.getId());
								Simulator.spaceModel.getGridCell( tempX, tempY).setFarmstead(true);
								h.setX(tempX);
								h.setY(tempY);
								
							}//if
							
							tempX++;
							tempY++;
							
						}//while
						
						return true;
						
					]]>
				</Body>
			</Function>
			
			<Function name="regrow" resultType="Boolean">
				<Body language="Java">
					<![CDATA[
						
						float regrow = 0.025f;
						
						int xMax = (int)Simulator.spaceModel.getXMax();
				        int yMax = (int)Simulator.spaceModel.getYMax();
						
						for(int i = 1; i<=xMax; i++){
							
							for(int j = 1; j<=yMax; j++){
							
								if((Simulator.spaceModel.getGridCell( i, j).isField() == false) && (Simulator.spaceModel.getGridCell( i, j).isFarmstead() == false)){
									
									Simulator.spaceModel.getGridCell( i, j).setFertility(Simulator.spaceModel.getGridCell( i, j).getFertility() + regrow);
									if(Simulator.spaceModel.getGridCell( i, j).getFertility() > 1) Simulator.spaceModel.getGridCell( i, j).setFertility(1);
									
									Simulator.spaceModel.getGridCell( i, j).setVegetation(Simulator.spaceModel.getGridCell( i, j).getVegetation() + 1);
									if(Simulator.spaceModel.getGridCell( i, j).getVegetation() > 50) Simulator.spaceModel.getGridCell( i, j).setVegetation(50);
								}
							
							}
						}
						
						return true;
						
					]]>
				</Body>
			</Function>
			
		</ObjectType>
		
	</EntityTypes>
		
	<EnvironmentRules>
		
		<!-- Find the field with the possibly best income -->
		<EnvironmentRule name="FindTheBestFieldRule">
			<WHEN eventType="FindTheBestField" eventVariable="e"/>
			<FOR objectVariable="h" objectType="Household">
				<ObjectRef language="Java">e.getActor()</ObjectRef>
			</FOR>
			<FOR objectVariable="helper" objectType="Helper">
				<ObjectIdRef language="Java">999</ObjectIdRef>
			</FOR>
			<DO>
				<UPDATE-ENV>
					<UpdateObject objectVariable="helper">
						<Slot property="calcOK"><ValueExpr language="Java">helper.findBestField(h)</ValueExpr></Slot>
					</UpdateObject>
				</UPDATE-ENV>
			</DO>
		</EnvironmentRule>
		
		<!-- Remove households with 0 or less enegry -->
		<EnvironmentRule name="RemoveDeadRule">
			<WHEN eventType="RemoveDead" eventVariable="e"/>
			<FOR objectVariable="h" objectType="Household">
				<ObjectRef language="Java">e.getActor()</ObjectRef>
			</FOR>
			<IF language="Java">h.getEnergy() &lt;= 0</IF>
			<THEN>
				<UPDATE-ENV>
					<DestroyObject objectType="Household" objectVariable="h" />
				</UPDATE-ENV>
			</THEN>
		</EnvironmentRule>
		
		<!-- Modify the Condition here to change the move threshould -->
		<EnvironmentRule name="ShouldIMoveRule">
			<WHEN eventType="ShouldIMove" eventVariable="e"/>
			<FOR objectVariable="h" objectType="Household">
				<ObjectRef language="Java">e.getActor()</ObjectRef>
			</FOR>
			<FOR objectVariable="helper" objectType="Helper">
				<ObjectIdRef language="Java">999</ObjectIdRef>
			</FOR>
			<IF language="Java">(h.getEnergy() &lt;= 30)||(h.isHoused() == false)</IF>
			<THEN>
				<UPDATE-ENV>
					<UpdateObject objectVariable="helper">
						<Slot property="calcOK"><ValueExpr language="Java">helper.findNewHomestead(h)</ValueExpr></Slot>
					</UpdateObject>
				</UPDATE-ENV>
			</THEN>
		</EnvironmentRule>
		
		<!-- update the agent's energy -->
		<EnvironmentRule name="UpdateMyEnergyRule">
			<WHEN eventType="UpdateMyEnergy" eventVariable="e"/>
			<FOR objectVariable="h" objectType="Household">
				<ObjectRef language="Java">e.getActor()</ObjectRef>
			</FOR>
			<FOR objectVariable="helper" objectType="Helper">
				<ObjectIdRef language="Java">999</ObjectIdRef>
			</FOR>
			<DO>
				<UPDATE-ENV>
					<UpdateObject objectVariable="helper">
						<Slot property="calcOK"><ValueExpr language="Java">helper.updateEnergy(h)</ValueExpr></Slot>
					</UpdateObject>
				</UPDATE-ENV>
			</DO>
		</EnvironmentRule>
		
		<!-- each round change the divisor back to "1" -->
		<EnvironmentRule name="updateGridRule">
			<WHEN eventType="UpdateGrid" eventVariable="e"/>
			<FOR objectVariable="helper" objectType="Helper">
				<ObjectIdRef language="Java">999</ObjectIdRef>
			</FOR>
			<DO>
				<UPDATE-ENV>
					<UpdateObject objectVariable="helper">
						<Slot property="divisor"><ValueExpr language="Java">1</ValueExpr></Slot>
						<Slot property="calcOK"><ValueExpr language="Java">helper.regrow()</ValueExpr></Slot>
					</UpdateObject>
				</UPDATE-ENV>
			</DO>
		</EnvironmentRule>
		
		<!-- if it's a bad year divisor becomes "2" -->
		<EnvironmentRule name="badYearRule">
			<WHEN eventType="BadYear" eventVariable="e"/>
			<FOR objectVariable="helper" objectType="Helper">
				<ObjectIdRef language="Java">999</ObjectIdRef>
			</FOR>
			<DO>
				<UPDATE-ENV>
					<UpdateObject objectVariable="helper">
						<Slot property="divisor"><ValueExpr language="Java">2</ValueExpr></Slot>
					</UpdateObject>
				</UPDATE-ENV>
			</DO>
		</EnvironmentRule>
		
	</EnvironmentRules>
		
		
	</SimulationModel>
	
		<InitialState>
			
			<!-- init the helper -->
			<Object type="Helper" id="999" name="helper" />
			
			<!-- first init of events -->
			<ExogenousEvent occurrenceTime="1" type="UpdateGrid" />
			<ExogenousEvent occurrenceTime="1" type="RemoveDeadHouseholds" />
			<ExogenousEvent occurrenceTime="50" type="BadYear" />
			
			<GridCells>
				<Slot xsi:type="aors:SimpleSlot" property="owner" value="0"/>
				<Slot xsi:type="aors:SimpleSlot" property="farmstead" value="false"/>
				<Slot xsi:type="aors:SimpleSlot" property="fertility" value="1.0"/>
				<Slot xsi:type="aors:SimpleSlot" property="field" value="false"/>
				<Slot xsi:type="aors:SimpleSlot" property="fallow" value="0"/>
				<Slot xsi:type="aors:OpaqueExprSlot" property="vegetation">
					<RandomVariable><UniformInt lowerBound="1" upperBound="50" /></RandomVariable>
				</Slot>
			</GridCells>
			
			<PhysicalAgents type="Household" rangeStartID="1" rangeEndID="50" hasRandomPosition="true">
				<Slot xsi:type="aors:SimpleSlot" property="energy" value="100"/>
				<Slot xsi:type="aors:SimpleSlot" property="housed" value="true"/>
				<PeriodicTimeEvent occurrenceTime="1" type="UpdateMyself"/>
			</PhysicalAgents>
			
			<InitializationRule name="InitRule">
				<documentation>
					<dc:description>Create initial values for the grid cell property "owner" and "farmstead" according 
						to the Household that is initially occupying the cell.</dc:description>
				</documentation>
				<FOR objectVariable="h" objectType="Household" rangeStartID="1" rangeEndID="50" />
				<UpdateGridCell>
					<XCoordinate language="Java">(int) h.getX()</XCoordinate>
					<YCoordinate language="Java">(int) h.getY()</YCoordinate>
					<Slot xsi:type="aors:OpaqueExprSlot" property="owner">
						<ValueExpr language="Java">(int) h.getId()</ValueExpr>
					</Slot>
					<Slot xsi:type="aors:SimpleSlot" property="farmstead" value="true" />
				</UpdateGridCell>
			</InitializationRule>
			
		</InitialState>
		
	<Views>
		
		<SpaceView>
			<Grid>
				<VisualizationMap cellViewProperty="fill" cellProperty="fertility" caseWise="true" v0="lightred" a0="0.0" v1="yellow" a1="0.5" v2="lightgreen" a2="0.8" v3="green" a3="1.0"/>
			</Grid>
		</SpaceView>
		
		<View physicalObjectType="Household" shape2D="circle">
			<ShapeSlot shapeProperty="r" value="5"/>
			<!-- <ShapeSlot shapeProperty="fill" value="this.getEnergy()"/>  -->
			<VisualizationMap property="energy" shapeProperty="fill" caseWise="true" v0="green" a0="100" v1="lightgreen" a1="80" v2="yellow" a2="60" v3="red" a3="30" v4="black" />
		</View>
		
	</Views>
	

</SimulationScenario>
