<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="ersl/refman/refman.xsl"?>
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified"
	targetNamespace="http://aor-simulation.org" xmlns:aors="http://aor-simulation.org"
	xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:ers="http://aor-simulation.org"
	xmlns:h="http://www.w3.org/1999/xhtml" xmlns:saxon="http://saxon.sf.net/"
	xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<!--xs:import namespace="http://www.w3.org/1999/XSL/Transform" schemaLocation="http://www.w3.org/2007/schema-for-xslt20.xsd"/-->
	<xs:annotation>
		<xs:documentation>
			<dc:title>AORSL 0.8.4</dc:title>
		</xs:documentation>
	</xs:annotation>
	<xs:annotation id="preface">
		<xs:documentation xml:lang="en">
			<h:img alt="AORS-UpperLevelCategories" href="AORS-UpperLevelCategories.gif"
				style="float:right"/>
			<h:p>Created on 20110407, Copyright 2007-2011 Gerd Wagner, some rights reserved         (<h:a
					href="http://creativecommons.org/licenses/by-sa/3.0/" rel="nofollow">Creative Commons 3.0
					BY-SA</h:a>).         With contributions by Mircea Diaconescu, Daniel Draeger, Thomas
				Grundmann and Jens Werner.         See also the <h:a href="http://AOR-Simulation.org"
					>project website</h:a>.</h:p>
			<h:p>The main element of an AORSL file is <h:strong>
					<h:code><h:a href="#SimulationScenario">SimulationScenario</h:a></h:code>
				</h:strong>, which essentially consists of a <h:code><h:a href="#SimulationModel"
						>SimulationModel</h:a></h:code>,         an <h:code><h:a href="#InitialState"
						>InitialState</h:a></h:code>,         and a <h:code><h:a href="#UserInterface"
						>UserInterface</h:a></h:code> element.</h:p>
		</xs:documentation>
	</xs:annotation>
	<!-- Open issues
		- Allow InitialAttributeValue also for SelfBeliefAttributes
	-->
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<xs:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="ERSL/xml.xsd"/>
	<!-- =================================================================== -->
	<xs:import namespace="http://www.w3.org/2001/XInclude" schemaLocation="ERSL/xinclude.xsd"/>
	<!-- =================================================================== -->
	<xs:import namespace="http://purl.org/dc/elements/1.1/" schemaLocation="ERSL/dc.xsd"/>
	<!-- =================================================================== -->
	<xs:element name="documentation">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice maxOccurs="unbounded" minOccurs="0">
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:title"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:subject"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:creator"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:contributor"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:description"/>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="shortDescription"
					type="ers:AnyXHTML.type"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:description"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:source">
					<xs:annotation>
						<xs:documentation>A related resource from which the described resource is
							derived.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element minOccurs="0" ref="dc:created"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="dc:modified"/>
				<xs:element minOccurs="0" ref="dc:license"/>
				<xs:element form="qualified" minOccurs="0" name="informationModelDiagram" type="xs:anyURI"/>
				<xs:element form="qualified" minOccurs="0" name="processModelDiagram" type="xs:anyURI"/>
			</xs:choice>
			<xs:attribute default="en" ref="xml:lang" use="optional"/>
		</xs:complexType>
	</xs:element>
	<xs:element name="description" type="ers:AnyXHTML.type"/>
	<!-- =================================================================== -->
	<xs:group name="include">
		<!-- =================================================================== -->
		<xs:sequence>
			<xs:element ref="xi:include"/>
		</xs:sequence>
	</xs:group>
	<!-- =================================================================== -->
	<xs:attributeGroup name="include">
		<!-- =================================================================== -->
		<xs:attribute ref="xml:id" use="optional"/>
		<xs:attribute ref="xml:base" use="optional"/>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:attributeGroup name="lang_optional">
		<!-- =================================================================== -->
		<xs:attribute ref="xml:lang" use="optional"/>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:attributeGroup name="lang_default_en">
		<!-- =================================================================== -->
		<xs:attribute default="en" ref="xml:lang" use="optional"/>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:attributeGroup name="lang_mandatory">
		<!-- =================================================================== -->
		<xs:attribute ref="xml:lang" use="required"/>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<!-- *** Property *** -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="Property" type="ers:Property.type"/>
	<xs:complexType name="Property.type">
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:description"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="type" type="ers:PathName" use="required"/>
		<xs:attribute default="1" form="unqualified" name="upperMultiplicity"
			type="ers:UpperMultiplicity" use="optional">
			<xs:annotation>
				<xs:documentation>If set to "unbounded", the property/attribute will be multi-valued,
					i.e. its value will be a list/array, for which the following access methods can be used:
					addFirst(), addLast(),    removeFirst(), removeLast(), get(i) and set(i,value). A
					multi-valued reference property allows to implement a     non-functional association. It
					can also be used for representing a first-in-first-out queue.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="1" form="unqualified" name="lowerMultiplicity"
			type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute default="false" form="unqualified" name="isStatic" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>A 'static' property is a type-level attribute that can be accessed via the
					type's class name.      E.g. if p is defined as a static property of some type T, then you
					can use the expressions T.getP() and T.setP(...)     for accessing it. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!-- 
		<xs:attribute name="isEmergent" type="xs:boolean" use="optional" default="false"/>
		<xs:assert test="@lowerMultiplicity le @upperMultiplicity" saxon:message="Property/@lowerMultiplicity must be less than Property/@upperMultiplicity!"/>
		-->
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** Attribute ** -->
	<!-- =================================================================== -->
	<xs:element name="Attribute" substitutionGroup="ers:Property" type="ers:Attribute.type">
		<xs:annotation>
			<xs:documentation> The values of an attribute are plain data literals (integers, strings,
				etc.),     i.e. its type is a primitive datatype.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="Attribute.type">
		<xs:complexContent>
			<xs:extension base="ers:Attribute0.type">
				<xs:attribute form="unqualified" name="initialValue" type="xs:string" use="optional"/>
				<xs:attribute form="unqualified" name="minValue" type="xs:double" use="optional"/>
				<xs:attribute form="unqualified" name="maxValue" type="xs:double" use="optional"/>
				<!--
				<xs:assert test="not(@minValue) or not(@maxValue) or (@minValue le @maxValue)" saxon:message="Attribute/@minValue must be less than Attribute/@maxValue!"/>
-->
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Attribute0.type">
		<xs:complexContent>
			<xs:restriction base="ers:Property.type">
				<xs:attribute form="unqualified" name="type" type="ers:PrimitiveDataType" use="required"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="PrimitiveDataType">
		<xs:restriction base="ers:PathName">
			<xs:enumeration value="String"/>
			<xs:enumeration value="Integer"/>
			<xs:enumeration value="Float"/>
			<xs:enumeration value="Boolean"/>
			<xs:enumeration value="Date"/>
			<xs:enumeration value="Time"/>
			<xs:enumeration value="DateTime"/>
			<xs:enumeration value="Duration"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- =================================================================== -->
	<!-- *** ReferenceProperty ***  -->
	<!-- =================================================================== -->
	<xs:element name="ReferenceProperty" substitutionGroup="ers:Property"
		type="ers:ReferenceProperty.type">
		<xs:annotation>
			<xs:documentation>The values of a reference property are object references, i.e. its type is
				an object type.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="ReferenceProperty.type">
		<xs:complexContent>
			<xs:extension base="ers:Property.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** ComplexDataProperty *** -->
	<!-- =================================================================== -->
	<xs:element name="ComplexDataProperty" substitutionGroup="ers:Property"
		type="ers:ReferenceProperty.type">
		<xs:annotation>
			<xs:documentation>The values of a complex data property are complex data structures such as
				lists,     i.e. its type is a complex data type.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<!-- =================================================================== -->
	<!-- *** CollectionValuedProperty *** 
	<xs:element name="CollectionValuedProperty" type="ers:CollectionValuedProperty.type" substitutionGroup="ers:Property">
		<xs:annotation><xs:documentation>For referencing a Collection Type.</xs:documentation></xs:annotation>		
	</xs:element>
	<xs:complexType name="CollectionValuedProperty.type">
		<xs:complexContent>
			<xs:extension base="ers:CollectionValuedProperty0.type">
				<xs:attribute name="itemType" type="ers:PathName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CollectionValuedProperty0.type">
		<xs:complexContent>
			<xs:restriction base="ers:Property.type">
				<xs:attribute name="type" use="required">
					<xs:simpleType>
						<xs:restriction base="ers:PathName">
							<xs:enumeration value="List"/>
							<xs:enumeration value="Set"/>
						</xs:restriction>
					</xs:simpleType>										
				</xs:attribute>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	-->
	<!-- =================================================================== -->
	<!-- *** EnumerationProperty *** -->
	<!-- =================================================================== -->
	<xs:element name="EnumerationProperty" substitutionGroup="ers:Property"
		type="ers:EnumerationProperty.type">
		<xs:annotation>
			<xs:documentation>The values of an enumeration property are enumeration literals (such as
				Sex.MALE),     i.e. its type is an enumeration datatype.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="EnumerationProperty.type">
		<xs:complexContent>
			<xs:extension base="ers:Property.type">
				<xs:attribute form="unqualified" name="initialValue" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="Parameter" type="ers:Parameter.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Parameter.type">
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="type" type="ers:JavaTypeName" use="required"/>
		<xs:attribute form="unqualified" name="itemType" type="ers:JavaTypeName" use="optional">
			<xs:annotation>
				<xs:documentation>The type of the items of a collection/list. Requires that type="List".
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:complexType name="OpaqueExpression">
		<!-- =================================================================== -->
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute form="unqualified" name="language" use="required">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="Java"/>
							<xs:enumeration value="JavaScript"/>
							<xs:enumeration value="PHP"/>
							<xs:enumeration value="Java JavaScript"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="Slot" type="ers:Slot.type"/>
	<!-- =================================================================== -->
	<xs:annotation>
		<xs:documentation>Allows to set the value of a property. </xs:documentation>
	</xs:annotation>
	<xs:complexType name="Slot.type">
		<xs:complexContent>
			<xs:extension base="ers:RandomVariable-OR-ValueExpr">
				<xs:choice>
					<xs:element minOccurs="0" ref="ers:ObjectValueExpr"/>
				</xs:choice>
				<xs:attribute form="unqualified" name="property" type="ers:PathName" use="required"/>
				<xs:attribute form="unqualified" name="value" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="MultiValuedSlot">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Allows to change the value of a multi-valued property.     This includes
				adding/removing items to/from the list, and assigning a new value to a specific list item.
			</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:group maxOccurs="unbounded" ref="ers:ChangeMultiValuedProperty.group"/>
			<xs:attribute form="unqualified" name="property" type="ers:PathName" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="ChangeMultiValuedProperty.group">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:element form="qualified" name="AddFirst" type="ers:AddItem.type">
				<xs:annotation>
					<xs:documentation>For adding a value as a new FIRST item to the list. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="AddLast" type="ers:AddItem.type">
				<xs:annotation>
					<xs:documentation>For adding a value as a new LAST item to the list. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="AddAll">
				<xs:annotation>
					<xs:documentation>For adding an entire list/array of vlues. </xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ListExpr"
							type="ers:OpaqueExpression">
							<xs:annotation>
								<xs:documentation>An expression that evaluates to a type-conform list to be appended
									to the list. </xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:attribute form="unqualified" name="listVariable" type="ers:CanonicalName"
						use="optional">
						<xs:annotation>
							<xs:documentation>A variable that holds an object reference to the list/array to be
								added. </xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element form="qualified" name="RemoveFirst">
				<xs:annotation>
					<xs:documentation>For removing the FIRST item from the list. </xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:attribute form="unqualified" name="itemVariable" type="ers:CanonicalName"
						use="optional">
						<xs:annotation>
							<xs:documentation>A variable holding an object reference to the item that was removed
								from the list. </xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element form="qualified" name="RemoveLast">
				<xs:annotation>
					<xs:documentation>For removing the LAST item from the list. </xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:attribute form="unqualified" name="itemVariable" type="ers:CanonicalName"
						use="optional">
						<xs:annotation>
							<xs:documentation>A variable holding an object reference to the item that was removed
								from the list. </xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element form="qualified" name="Remove">
				<xs:annotation>
					<xs:documentation>For removing a specific item from the list. </xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ItemExpr"
							type="ers:OpaqueExpression">
							<xs:annotation>
								<xs:documentation>An expression that evaluates to a type-conform value to be removed
									from the list. </xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:attribute form="unqualified" name="itemVariable" type="ers:CanonicalName"
						use="optional">
						<xs:annotation>
							<xs:documentation>A variable that holds an object reference to the item to be removed.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element form="qualified" name="Set">
				<xs:annotation>
					<xs:documentation>For assigning a new value to an item at a specific index in the
						array/list. </xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ItemExpr"
							type="ers:OpaqueExpression"/>
					</xs:sequence>
					<xs:attribute form="unqualified" name="indexValue" type="xs:int" use="required">
						<xs:annotation>
							<xs:documentation>The item index at which the new value is to be assigned.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute form="unqualified" name="itemVariable" type="ers:CanonicalName"
						use="optional">
						<xs:annotation>
							<xs:documentation>A variable holding an object reference that is to be assigned.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute form="unqualified" name="itemValue" type="xs:string" use="optional">
						<xs:annotation>
							<xs:documentation>A literal value to be assigned (in the case where the list item type
								is a primitive datatype). </xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element form="qualified" name="Insert">
				<xs:annotation>
					<xs:documentation>For inserting a new item at a specific index in the array/list.
					</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ItemExpr"
							type="ers:OpaqueExpression"/>
					</xs:sequence>
					<xs:attribute form="unqualified" name="indexValue" type="xs:int" use="required">
						<xs:annotation>
							<xs:documentation>The item index at which the new value is to be assigned.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute form="unqualified" name="itemVariable" type="ers:CanonicalName"
						use="optional">
						<xs:annotation>
							<xs:documentation>A variable holding an object reference that is to be assigned.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute form="unqualified" name="itemValue" type="xs:string" use="optional">
						<xs:annotation>
							<xs:documentation>A literal value to be assigned (in the case where the list item type
								is a primitive datatype). </xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="AddItem.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ItemExpr"
				type="ers:OpaqueExpression">
				<xs:annotation>
					<xs:documentation>An expression that evaluates to a type-conform value to be added as a
						new item. </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="itemVariable" type="ers:CanonicalName" use="optional">
			<xs:annotation>
				<xs:documentation>A variable holding an object reference to be added as a new item.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="itemValue" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>A literal value to be added as a new item (in the case where the list item
					type is a primitive datatype). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="Code" type="ers:OpaqueExpression"/>
	<!-- =================================================================== -->
	<xs:element name="Text">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="xs:string">
					<xs:attributeGroup ref="ers:lang_default_en"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="HtmlText">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:any maxOccurs="unbounded" minOccurs="0" namespace="http://www.w3.org/1999/xhtml"
					processContents="skip"/>
			</xs:sequence>
			<xs:attribute default="en" ref="xml:lang" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType mixed="true" name="AnyXHTML.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:any maxOccurs="unbounded" minOccurs="0" namespace="http://www.w3.org/1999/xhtml"
				processContents="skip"/>
		</xs:sequence>
		<xs:attributeGroup ref="ers:lang_default_en"/>
	</xs:complexType>
	<!-- ==================================================================== -->
	<xs:element name="Condition" type="ers:Condition.type"/>
	<!-- ==================================================================== -->
	<xs:complexType name="Condition.type">
		<xs:simpleContent>
			<xs:extension base="ers:OpaqueExpression"/>
		</xs:simpleContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="ValueExpr" type="ers:OpaqueExpression"/>
	<!-- =================================================================== -->
	<xs:complexType name="ValueExpr.type">
		<xs:simpleContent>
			<xs:extension base="ers:OpaqueExpression"> </xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="PropertyValueExpr">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Allows to specify a property value expression of the form e.p, or e.getP(),
				by providing     an entity variable e and a property p. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute form="unqualified" name="entityVariable" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="property" type="ers:CanonicalName" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="GlobalVariableValueExpr">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Allows to specify a global variable value expression of the form Global.p
				by providing a variable name p. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="ObjectValueExpr">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Allows to specify an object value expression of the form o by providing
				an object variable o. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName" use="required"
			/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="Selection">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:Condition"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="copyToList" type="ers:PathName" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ======================================================= -->
	<xs:element name="Enumeration" type="ers:Enumeration.type"/>
	<!-- ======================================================= -->
	<xs:complexType name="Enumeration.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:EnumerationLiteral"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
	</xs:complexType>
	<xs:element name="EnumerationLiteral" type="ers:JavaConstantName"/>
	<!-- =================================================================== -->
	<xs:element name="Function" type="ers:Function.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Function.type">
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:documentation"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Parameter"/>
			<xs:element form="qualified" maxOccurs="unbounded" name="Body" type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="resultType" type="ers:JavaTypeName" use="required"/>
		<xs:attribute default="false" form="unqualified" name="isStatic" type="xs:boolean"
			use="optional"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:complexType name="RandomVariable-OR-ValueExpr">
		<!-- =================================================================== -->
		<xs:choice>
			<xs:element minOccurs="0" ref="ers:RandomVariable"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
			<xs:element minOccurs="0" ref="ers:PropertyValueExpr"/>
			<xs:element minOccurs="0" ref="ers:GlobalVariableValueExpr"/>
		</xs:choice>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="DiscreteRandomVariable-OR-ValueExpr">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:element minOccurs="0" ref="ers:DiscreteRandomVariable"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
			<xs:element minOccurs="0" ref="ers:PropertyValueExpr"/>
			<xs:element minOccurs="0" ref="ers:GlobalVariableValueExpr"/>
		</xs:choice>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="RandomVariable" type="ers:RandomVariable.type"/>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="RandomVariable.type">
		<xs:choice>
			<xs:group ref="ers:ContinuousRandomVariable.elements"/>
			<xs:group ref="ers:DiscreteRandomVariable.elements"/>
			<xs:group ref="ers:IntRandomVariable.elements"/>
		</xs:choice>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="DiscreteRandomVariable">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:choice>
				<xs:group ref="ers:DiscreteRandomVariable.elements"/>
				<xs:group ref="ers:IntRandomVariable.elements"/>
			</xs:choice>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="ContinuousRandomVariable.elements">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:element form="qualified" name="Uniform" type="ers:Uniform.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution where each possible value has the
						same proability. See also <h:a
							href="http://en.wikipedia.org/wiki/Uniform_distribution_%28discrete%29">Wikipedia
							article</h:a>. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Triangular" type="ers:Triangular.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution used when only the minimum and
						maximum and an "inspired guess" of the modal value are known. See also <h:a
							href="http://en.wikipedia.org/wiki/Triangular_distribution">Wikipedia article</h:a>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Normal" type="ers:Normal.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution where the data clusters around a
						mean. See also <h:a href="http://en.wikipedia.org/wiki/Normal_distribution">Wikipedia
							article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Exponential" type="ers:Exponential.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution of the times between events in a
						Poisson process, i.e. a process in which events occur continuously and independently at
						a constant average rate. See also <h:a
							href="http://en.wikipedia.org/wiki/Exponential_distribution">Wikipedia article</h:a>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="LogNormal" type="ers:Normal.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution of a random variable whose logarithm
						is normally distributed. See also <h:a href="http://en.wikipedia.org/wiki/Log_normal"
							>Wikipedia article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Gamma" type="ers:Gamma.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution that can be used to model waiting
						times. See also <h:a href="http://en.wikipedia.org/wiki/Gamma_distribution">Wikipedia
							article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Erlang" type="ers:Erlang.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution. See also <h:a
							href="http://en.wikipedia.org/wiki/Erlang_distribution">Wikipedia
						article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Weibull" type="ers:Weibull.type">
				<xs:annotation>
					<xs:documentation>Continuous propability distribution. See also <h:a
							href="http://en.wikipedia.org/wiki/Weibull_distribution">Wikipedia
						article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="IntRandomVariable.elements">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:element form="qualified" name="UniformInt" type="ers:Uniform.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Uniform propability distribution.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="TriangularInt" type="ers:Triangular.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Triangular propability distribution
						used when only the minimum and maximum and an "inspired guess" of the modal value are
						known. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="NormalInt" type="ers:Normal.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Normal propability distribution where
						the data clusters around a mean. See also <h:a
							href="http://en.wikipedia.org/wiki/Normal_distribution">Wikipedia
						article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="ExponentialInt" type="ers:Exponential.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Exponential propability distribution
						of the times between events in a Poisson process, i.e. a process in which events occur
						continuously and independently at a constant average rate. See also <h:a
							href="http://en.wikipedia.org/wiki/Exponential_distribution">Wikipedia article</h:a>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="LogNormalInt" type="ers:Normal.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous LogNormal propability distribution of
						a random variable whose logarithm is normally distributed. See also <h:a
							href="http://en.wikipedia.org/wiki/Log_normal">Wikipedia
						article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="GammaInt" type="ers:Gamma.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Gamma propability distribution that
						can be used to model waiting times. See also <h:a
							href="http://en.wikipedia.org/wiki/Gamma_distribution">Wikipedia
						article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="ErlangInt" type="ers:Erlang.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Erlang propability distribution. See
						also <h:a href="http://en.wikipedia.org/wiki/Erlang_distribution">Wikipedia
							article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="WeibullInt" type="ers:Weibull.type">
				<xs:annotation>
					<xs:documentation>Discrete variant of the continuous Weibull propability distribution. See
						also <h:a href="http://en.wikipedia.org/wiki/Weibull_distribution">Wikipedia
							article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="DiscreteRandomVariable.elements">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:element form="qualified" name="Binomial" type="ers:Binomial.type">
				<xs:annotation>
					<xs:documentation>Discrete propability distribution of the number of successes in a
						sequence of n independent yes/no experiments, each of which yields success with
						probability p. See also <h:a href="http://en.wikipedia.org/wiki/Binomial_distribution"
							>Wikipedia article</h:a>. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="NegBinomial" type="ers:NegBinomial.type">
				<xs:annotation>
					<xs:documentation>Discrete propability distribution of the number of failures before the
						r'th succes in a sequence of independent yes/no experiments, each of which yields
						success with probability p. See also the <h:a
							href="http://en.wikipedia.org/wiki/Negative_binomial_distribution">Wikipedia
							article</h:a>. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="HyperGeometric" type="ers:HyperGeometric.type">
				<xs:annotation>
					<xs:documentation>Discrete probability distribution that describes the number of successes
						in a sequence of n draws from a finite population without replacement. See also <h:a
							href="http://en.wikipedia.org/wiki/Hypergeometric_distribution">Wikipedia
							article</h:a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Poisson" type="ers:Poisson.type">
				<xs:annotation>
					<xs:documentation>Discrete propability distribution of a number of events occurring in a
						fixed period of time if these events occur with a known average rate lambda. See also
						the <h:a href="http://en.wikipedia.org/wiki/Poisson_distribution">Wikipedia
							article</h:a>. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="Logarithmic" type="ers:Logarithmic.type">
				<xs:annotation>
					<xs:documentation>Discrete propability distribution. See also <h:a
							href="http://en.wikipedia.org/wiki/Logarithmic_distribution">Wikipedia article</h:a>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Uniform.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="LowerBoundExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="UpperBoundExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="lowerBound" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The lowest possible value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="upperBound" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The highest possible value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Triangular.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="LowerBoundExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="UpperBoundExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ModeExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="lowerBound" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The lowest possible value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="upperBound" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The highest possible value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="mode" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The value with the highest probability.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Normal.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="MeanExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="StandardDeviationExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="mean" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>Also called "expected value".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="standardDeviation" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>Also called "expected value".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Binomial.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="N-Expr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="P-Expr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="n" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Number of independent yes/no experiments.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="p" type="ers:Probability" use="optional">
			<xs:annotation>
				<xs:documentation>Success probability.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="NegBinomial.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="R-Expr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="P-Expr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="r" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Number of successes.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="p" type="ers:Probability" use="optional">
			<xs:annotation>
				<xs:documentation>Success probability.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Poisson.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="LambdaExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="lambda" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>
					<h:p>Average rate of event occurrences in the given interval.</h:p>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Exponential.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="LambdaExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="lambda" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>
					<h:p>Average rate of event occurrences in the given interval. </h:p>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Logarithmic.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="P-Expr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="p" type="ers:Probability" use="optional"> </xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="HyperGeometric.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
				name="TotalPopulationSizeExpr" type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
				name="SuccessesPopulationSizeExpr" type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="NumberOfDrawsExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="totalPopulationSize" type="xs:positiveInteger"
			use="optional"/>
		<xs:attribute form="unqualified" name="successPopulationSize" type="xs:positiveInteger"
			use="optional">
			<xs:annotation>
				<xs:documentation>Size of the population the elements of which represent
					success</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="numberOfDraws" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Sample size</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Gamma.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ShapeExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RateExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="shape" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>The shape paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="rate" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>The rate paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Erlang.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ShapeExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RateExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="shape" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>The shape paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="rate" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>The rate paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Weibull.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ShapeExpr"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ScaleExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="shape" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>The shape paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="scale" type="ers:PositiveDouble" use="optional">
			<xs:annotation>
				<xs:documentation>The scale paramter</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** Special Data Types  *** -->
	<!-- =================================================================== -->
	<xs:simpleType name="CoordinatePairSequence.type">
		<xs:list itemType="ers:CoordinatePair.type"/>
	</xs:simpleType>
	<xs:simpleType name="CoordinatePair.type">
		<xs:annotation>
			<xs:documentation>A comma-separated pair of floating point numbers. </xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern
				value="(((\-?)[1-9](\d)+)|((\-?)\d))(\.\d+)?,(((\-?)[1-9](\d)+)|((\-?)\d))(\.\d+)?"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="Probability">
		<xs:restriction base="xs:double">
			<xs:minExclusive value="0.0"/>
			<xs:maxExclusive value="1.0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PositiveDouble">
		<xs:restriction base="xs:double">
			<xs:minExclusive value="0"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListOfBytes">
		<xs:list itemType="xs:unsignedByte"/>
	</xs:simpleType>
	<xs:simpleType name="ByteTriple.type">
		<xs:restriction base="ers:ListOfBytes">
			<xs:length value="3"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListOfInt">
		<xs:list itemType="xs:int"/>
	</xs:simpleType>
	<xs:simpleType name="IntTriple.type">
		<xs:restriction base="ers:ListOfInt">
			<xs:minLength value="1"/>
			<xs:maxLength value="3"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListOfLong">
		<xs:list itemType="xs:long"/>
	</xs:simpleType>
	<xs:simpleType name="ListOfDouble">
		<xs:list itemType="xs:double"/>
	</xs:simpleType>
	<xs:simpleType name="DoubleTriple.type">
		<xs:restriction base="ers:ListOfDouble">
			<xs:minLength value="1"/>
			<xs:maxLength value="3"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="UpperMultiplicity">
		<xs:restriction base="xs:string">
			<xs:pattern value="unbounded|([0-9])*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CanonicalName">
		<xs:annotation>
			<xs:documentation>A simple string consisting of letters, digits and the underscore sign,
				only.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern
				value="(_|(((_([A-Z]|[a-z]|[0-9]))|([A-Z]|[a-z]))(_([A-Z]|[a-z]|[0-9])|([A-Z]|[a-z]|[0-9]))*)_?)"
			/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PathName">
		<xs:annotation>
			<xs:documentation>A path name such as "name1.name2".</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern value="([A-Z]|[a-z]|_)([A-Z]|[a-z]|_|[0-9]|.)*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="JavaTypeName">
		<xs:restriction base="xs:string">
			<xs:pattern value="([A-Z]|[a-z]|_)([A-Z]|[a-z]|_|[0-9]|.)*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListOfCanonicalName">
		<xs:list itemType="ers:CanonicalName"/>
	</xs:simpleType>
	<xs:simpleType name="JavaConstantName">
		<xs:restriction base="xs:string">
			<xs:pattern value="([A-Z])([A-Z]|_|[0-9])*"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListOfLanguages">
		<xs:list itemType="xs:language"/>
	</xs:simpleType>
	<!-- =================================================================== -->
	<!-- *** Code Lists  *** -->
	<!-- =================================================================== -->
	<xs:simpleType name="LengthUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="mm"/>
			<xs:enumeration value="cm"/>
			<xs:enumeration value="m"/>
			<xs:enumeration value="km"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="WeightUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="mg"/>
			<xs:enumeration value="g"/>
			<xs:enumeration value="kg"/>
			<xs:enumeration value="t"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="AreaUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="mm"/>
			<xs:enumeration value="cm"/>
			<xs:enumeration value="m"/>
			<xs:enumeration value="ar"/>
			<xs:enumeration value="ha"/>
			<xs:enumeration value="km"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="VolumeUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="mm"/>
			<xs:enumeration value="cm"/>
			<xs:enumeration value="liter"/>
			<xs:enumeration value="m"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="TimeUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ms"/>
			<xs:enumeration value="s"/>
			<xs:enumeration value="min"/>
			<xs:enumeration value="h"/>
			<xs:enumeration value="D"/>
			<xs:enumeration value="W"/>
			<xs:enumeration value="M"/>
			<xs:enumeration value="Y"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="CurrencySymbol">
		<xs:restriction base="xs:string">
			<xs:enumeration value="USD($)"/>
			<xs:enumeration value="EUR()"/>
			<xs:enumeration value="GBP()"/>
			<xs:enumeration value="AUD($)"/>
			<xs:enumeration value="BRL(R$)"/>
			<xs:enumeration value="CAD($)"/>
			<xs:enumeration value="CLP($)">
				<xs:annotation>
					<xs:documentation>Chilean Peso</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="CNY">
				<xs:annotation>
					<xs:documentation>Chinese Yuan</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="JPY()">
				<xs:annotation>
					<xs:documentation>Japanese Yen</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="INR()">
				<xs:annotation>
					<xs:documentation>Indian rupee</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IDR">
				<xs:annotation>
					<xs:documentation>Rupiah (INDONESIA)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ILS()">
				<xs:annotation>
					<xs:documentation>Israeli Sheqel</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="KRN()">
				<xs:annotation>
					<xs:documentation>Won (KOREA)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MYR">
				<xs:annotation>
					<xs:documentation>Malaysian Ringgit</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PLN">
				<xs:annotation>
					<xs:documentation>Zloty (POLAND)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RON">
				<xs:annotation>
					<xs:documentation>New Leu (ROMANIA)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RUB">
				<xs:annotation>
					<xs:documentation>Russian Ruble</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ZAR">
				<xs:annotation>
					<xs:documentation>Rand (SOUTH AFRICA)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="TRY">
				<xs:annotation>
					<xs:documentation>Turkish Lira</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PackagingUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="cans"/>
			<xs:enumeration value="crates"/>
			<xs:enumeration value="cups"/>
			<xs:enumeration value="bags"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="MathUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="">
				<xs:annotation>
					<xs:documentation>Degree</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RAD">
				<xs:annotation>
					<xs:documentation>Radians</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="%">
				<xs:annotation>
					<xs:documentation>Percent</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="">
				<xs:annotation>
					<xs:documentation>Permil</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PhysicalUnit">
		<xs:restriction base="xs:string">
			<xs:enumeration value="mA">
				<xs:annotation>
					<xs:documentation>Milli-Ampere</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="A">
				<xs:annotation>
					<xs:documentation>Ampere</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="mV">
				<xs:annotation>
					<xs:documentation>Milli-Volt</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="V">
				<xs:annotation>
					<xs:documentation>Volt</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="C">
				<xs:annotation>
					<xs:documentation>Degree Celsius</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="F">
				<xs:annotation>
					<xs:documentation>Degree Fahrenheit</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="K">
				<xs:annotation>
					<xs:documentation>Degree Kelvin</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="">
				<xs:annotation>
					<xs:documentation>Ohm</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Hz">
				<xs:annotation>
					<xs:documentation>Hertz</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="C">
				<xs:annotation>
					<xs:documentation>Coulomb</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="F">
				<xs:annotation>
					<xs:documentation>Farad</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="N">
				<xs:annotation>
					<xs:documentation>Newton</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="J">
				<xs:annotation>
					<xs:documentation>Joule</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Pa">
				<xs:annotation>
					<xs:documentation>Pascal</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="m/s">
				<xs:annotation>
					<xs:documentation>Velocity (metters per second)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="m/s">
				<xs:annotation>
					<xs:documentation>Acceleration (metters per second square)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!-- =================================================================== -->
	<xs:attributeGroup name="SimulationScenario.attributes">
		<!-- =================================================================== -->
		<xs:attribute fixed="0.8.4" form="unqualified" name="version" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Indicates the AORSL version against which the
						<h:code>SimulationScenario</h:code> document must be validated.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="scenarioName" type="xs:NCName" use="required"/>
		<xs:attribute form="unqualified" name="scenarioTitle" type="xs:normalizedString" use="optional"/>
		<!--xs:attribute name="prettyPrintCssLocation" type="xs:anyURI" use="optional"
          default="http://aor-javasim.googlecode.com/svn/trunk/PrettyPrint/css/prettyprint.css"/-->
		<!-- deprecated: will be replaced by prettyPrintCssLocation -->
		<xs:attribute form="unqualified" name="simulationManagerDirectory" type="xs:string"
			use="optional">
			<xs:annotation>
				<xs:documentation>Indicates the file system directory in which the AOR-JavaSim program is
					located (deprecated: will be replaced by prettyPrintCssLocation).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="false" form="unqualified" name="createSimulationLog" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>Allows to turn on the creation of a simulation log that is useful for
					debugging and special data analysis. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- ======================================================================== -->
	<xs:element name="SimulationParameters" type="ers:SimulationParameters.type">
		<!-- ======================================================================== -->
		<xs:annotation>
			<xs:documentation>The attributes of the SimulationParameters element can be accessed within
				Java expressions in the form of, e.g.,
					<h:code>SimulationParameters.SIMULATION_STEPS</h:code>.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="SimulationParameters.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Parameter">
				<xs:complexType>
					<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
					<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="simulationSteps" type="xs:positiveInteger" use="required">
			<xs:annotation>
				<xs:documentation>Defines the duration of a simulation run as the number of simulation steps
					to be performed.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="1" form="unqualified" name="stepDuration" type="xs:positiveInteger"
			use="optional">
			<xs:annotation>
				<xs:documentation>This attribute is purely descriptive, and only meaningful for non-realtime
					simulation. In combination with the <h:code>timeUnit</h:code> attribute, it allows to
					specify the real (calendar time) duration that a simulation step is intended to
					represent.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="s" form="unqualified" name="timeUnit" type="ers:TimeUnit" use="optional">
			<xs:annotation>
				<xs:documentation>This attribute is purely descriptive, and only meaningful for non-realtime
					simulation. In combination with the <h:code>stepDuration</h:code> attribute, it allows to
					specify the real (calendar time) duration that a simulation step is intended to
					represent.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="stepTimeDelay" type="xs:nonNegativeInteger"
			use="optional">
			<xs:annotation>
				<xs:documentation>Defines how many miliseconds a simulation step takes (the simulator
					execution will pause accordingly). The purpose of this attribute is to allow slowing down
					a simulation run for making it better observable. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="randomSeed" type="xs:integer" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the start value for the random number generator. Allows to
					reproduce a run of a stochastic simulation model by using the same value as before.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="true" form="unqualified" name="randomOrderAgentSimulation"
			type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation>When this parameter is set to true, which is the default setting, the
					agent simulators will be executed in a random order. Otherwise, they will be executed in
					the order given by their definition sequence in the initial state definition.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<xs:attributeGroup name="SimulationModel.basic-attributes">
		<!-- =================================================================== -->
		<xs:attribute form="unqualified" name="modelName" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="modelTitle" type="xs:normalizedString" use="optional"/>
		<xs:attribute form="unqualified" name="importPackages" type="ers:ListOfCanonicalName"
			use="optional"/>
		<xs:attributeGroup ref="ers:include"/>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:element name="SimulationParameterDeclaration">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:documentation"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="type" type="ers:PrimitiveDataType" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="SpaceModel" type="ers:SpaceModel.type">
		<xs:annotation>
			<xs:documentation>The built-in space model properties such as <h:code>xMax</h:code> can be
				accessed with an expression of the form <h:code>Simulator.spaceModel.getXMax()</h:code>.
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<!-- =================================================================== -->
	<xs:complexType name="SpaceModel.type">
		<xs:annotation>
			<xs:documentation>The values of space model attributes can be accessed in Java expressions in
				the form of, e.g., <h:code>Simulator.spaceModel.getXMax()</h:code>. </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:choice minOccurs="0">
				<xs:element ref="ers:OneDimensional"/>
				<xs:element ref="ers:TwoDimensional"/>
				<xs:element ref="ers:TwoDimensional_LateralView"/>
				<xs:element ref="ers:TwoDimensionalGrid"/>
				<xs:element ref="ers:ThreeDimensional"/>
				<xs:element ref="ers:ThreeDimensionalGrid"/>
			</xs:choice>
		</xs:sequence>
		<xs:attributeGroup ref="ers:SpaceModel.attributes"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="SpaceModel.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute default="Euclidean" form="unqualified" name="geometry" use="optional">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="Euclidean">
						<xs:annotation>
							<xs:documentation>Moving objects halt at the space border.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Toroidal">
						<xs:annotation>
							<xs:documentation>Moving objects leave the space at its border and reenter it at the
								opposite side. </xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute default="m" form="unqualified" name="spatialDistanceUnit" type="ers:LengthUnit"
			use="optional"/>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="OneDimensional">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required">
				<xs:annotation>
					<xs:documentation>The size of the one-dimensional space. </xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute default="1" form="unqualified" name="multiplicity" use="optional">
				<xs:annotation>
					<xs:documentation>The number of parallel one-dimensional space tracks. The default is 1.
					</xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:integer">
						<xs:minInclusive value="1"/>
						<xs:maxInclusive value="4"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute default="false" form="unqualified" name="startCountingWithZero"
				type="xs:boolean" use="optional">
				<xs:annotation>
					<xs:documentation>In a multi-track space, count the first track as track number 0.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attributeGroup ref="ers:ContinuousSpacePhysics.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="TwoDimensional">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>This space model represents the x/z plane of the 3-dimensional coordinate
				system, that is the birds eye view.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:OverlayGrid"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="yMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attributeGroup ref="ers:ContinuousSpacePhysics.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="OverlayGrid">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="gridCellWidth" type="xs:double" use="required">
				<xs:annotation>
					<xs:documentation xml:lang="en">The width of a grid cell in spatial distance units.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute form="unqualified" name="gridCellHeight" type="xs:double" use="required">
				<xs:annotation>
					<xs:documentation xml:lang="en">The height of a grid cell in spatial distance units.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="TwoDimensional_LateralView">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>This space model represents the x/y plane of the 3-dimensional coordinate
				system, that is the lateral view. It allows to specify a value for gravitation, which is
				9.81 by default.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:OverlayGrid"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="yMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute default="9.81" form="unqualified" name="gravitation" type="xs:double"
				use="optional"/>
			<xs:attributeGroup ref="ers:ContinuousSpacePhysics.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="TwoDimensionalGrid">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>This discrete space, also called <h:em>grid space</h:em>, consists of cells
				for which properties and functions may be defined. A cell object reference for the cell on
				position (x,y) can be obtained with the expression <h:code>c =
					Simulator.spaceModel.getGridCell(x,y)</h:code>. The ccordinates of a given cell
					<h:code>c</h:code> can be retrieved with the built-in cell properties
					<h:code>posX</h:code> and <h:code>posY</h:code> using an expression of the form
					<h:code>c.getPosX()</h:code>. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:group minOccurs="0" ref="ers:GridSpace.elements"/>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="yMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attributeGroup ref="ers:GridSpace.attributes"/>
			<xs:attribute default="false" form="unqualified" name="autoKinematics" type="xs:boolean"
				use="optional">
				<xs:annotation>
					<xs:documentation>Automatically update the spatial position and velocity of physical
						objects at each simulation step according to their velocity and acceleration.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ThreeDimensional">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="yMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="zMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute default="9.81" form="unqualified" name="gravitation" type="xs:double"
				use="optional"/>
			<xs:attributeGroup ref="ers:ContinuousSpacePhysics.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ThreeDimensionalGrid">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>This discrete space consists of cells for which properties and functions may
				be defined. The built-in cell properties <h:code>posX</h:code>, <h:code>posY</h:code> and
					<h:code>posZ</h:code> can be accessed with an expression of the form
					<h:code>Simulator.spaceModel.getGridCell(x,y,z).getPosX()</h:code>. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:group minOccurs="0" ref="ers:GridSpace.elements"/>
			<xs:attribute form="unqualified" name="xMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="yMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attribute form="unqualified" name="zMax" type="xs:nonNegativeInteger" use="required"/>
			<xs:attributeGroup ref="ers:GridSpace.attributes"/>
			<xs:attribute default="9.81" form="unqualified" name="gravitation" type="xs:double"
				use="optional"/>
			<xs:attribute default="false" form="unqualified" name="autoKinematics" type="xs:boolean"
				use="optional">
				<xs:annotation>
					<xs:documentation>Automatically update the spatial position and velocity of physical
						objects at each simulation step according to their velocity and acceleration.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="GridSpace.elements">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="GridCellProperty"
				type="ers:Attribute.type">
				<xs:annotation>
					<xs:documentation>A discrete space, also called <h:em>grid space</h:em>, consists of cells
						that can have properties. These properties can be accessed with expressions of the form
							<h:code>Simulator.spaceModel.getGridCell(x,y).getProperty()</h:code>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="GridCellFunction"
				type="ers:Function.type">
				<xs:annotation>
					<xs:documentation>A discrete space, also called <h:em>grid space</h:em>, consists of cells
						for which functions can be defined (as methods of grid cell objects). These functions
						can be called with expressions of the form
							<h:code>Simulator.spaceModel.getGridCell(x,y).function(...)</h:code>.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="ContinuousSpacePhysics.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute default="false" form="unqualified" name="autoKinematics" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>Automatically update the spatial position and velocity of physical objects
					at each simulation step according to their velocity and acceleration. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="false" form="unqualified" name="autoCollisionDetection" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>Create a CollisionEvent when two physical objects collide.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="false" form="unqualified" name="autoCollisionHandling" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>Use impulse to update the velocities of objects participating in a
					collision. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="GridSpace.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute default="unbounded" form="unqualified" name="gridCellMaxOccupancy" use="optional">
			<xs:annotation>
				<xs:documentation>The maximum of physical objects that will be placed on a grid cell at
					initialization time. Notice: this constraint is (currently) not checked at
					runtime.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:pattern value="unbounded|[1-9]\d*"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute default="false" form="unqualified" name="startCountingWithZero" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>Count the first cell as cell number 0. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:element name="Statistics" type="ers:Statistics.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Statistics.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Variable">
				<xs:annotation>
					<xs:documentation>A statistics variable is bound to a source, which is a value expression,
						a variable or an object property. It is updated in one of 3 possible ways: 1) by an
						UpdateVariable element in an environment rule, 2) at the end of the simulation run, 3)
						at the end of each simulation step by aggregating the value of ist
						source.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element form="qualified" minOccurs="0" name="Source">
							<xs:complexType>
								<xs:choice>
									<xs:element form="qualified" name="GlobalVariable">
										<xs:complexType>
											<xs:attribute form="unqualified" name="name" type="ers:CanonicalName"
												use="required"/>
										</xs:complexType>
									</xs:element>
									<xs:element form="qualified" name="StatisticsVariable">
										<xs:complexType>
											<xs:attribute form="unqualified" name="name" type="ers:CanonicalName"
												use="required"/>
										</xs:complexType>
									</xs:element>
									<xs:element form="qualified" name="ObjectProperty">
										<xs:complexType>
											<xs:attribute form="unqualified" name="property" type="ers:CanonicalName"
												use="required"/>
											<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName"
												use="required"/>
											<xs:attribute form="unqualified" name="objectIdRef" type="xs:long"
												use="optional"/>
										</xs:complexType>
									</xs:element>
									<xs:element form="qualified" name="ObjectTypeExtensionSize">
										<xs:complexType>
											<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName"
												use="required"/>
										</xs:complexType>
									</xs:element>
									<xs:element form="qualified" name="ResourceUtilization">
										<xs:complexType>
											<xs:attribute form="unqualified" name="activityType" type="ers:CanonicalName"
												use="required"/>
											<xs:attribute form="unqualified" name="resourceObjectType"
												type="ers:CanonicalName" use="required"/>
											<xs:attribute form="unqualified" name="resourceObjectIdRef" type="xs:long"
												use="optional"/>
										</xs:complexType>
									</xs:element>
									<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
								</xs:choice>
								<xs:attribute form="unqualified" name="aggregationFunction" use="optional">
									<xs:simpleType>
										<xs:restriction base="xs:string">
											<xs:enumeration value="max"/>
											<xs:enumeration value="min"/>
											<xs:enumeration value="avg"/>
											<xs:enumeration value="sum"/>
										</xs:restriction>
									</xs:simpleType>
								</xs:attribute>
								<xs:attribute form="unqualified" name="computeOnlyAtEnd" type="xs:boolean"
									use="optional"/>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
					<xs:attribute form="unqualified" name="dataType" use="required">
						<xs:simpleType>
							<xs:restriction base="xs:string">
								<xs:enumeration value="Integer"/>
								<xs:enumeration value="Float"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="initialValue" type="xs:string" use="optional"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="DataTypes">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Enumeration"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ComplexDataType"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:element name="ComplexDataType">
		<xs:complexType>
			<xs:choice>
				<xs:sequence>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Property"/>
					<xs:element form="qualified" maxOccurs="1" minOccurs="0" name="DefaultConstructor">
						<xs:complexType>
							<xs:sequence>
								<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Def"
									type="ers:OpaqueExpression"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Function"/>
				</xs:sequence>
				<xs:sequence>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ClassDef"
						type="ers:OpaqueExpression"/>
				</xs:sequence>
			</xs:choice>
			<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="superType" type="ers:CanonicalName" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="Globals">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="GlobalVariable">
					<xs:complexType>
						<xs:sequence>
							<xs:element minOccurs="0" ref="ers:documentation"/>
						</xs:sequence>
						<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
						<xs:attribute form="unqualified" name="dataType" type="ers:PrimitiveDataType"
							use="optional"/>
						<xs:attribute form="unqualified" name="refDataType" type="ers:PathName" use="optional">
							<xs:annotation>
								<xs:documentation>The name of a class.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="initialValue" type="xs:string" use="optional"/>
						<xs:attribute form="unqualified" name="minValue" type="xs:double" use="optional"/>
						<xs:attribute form="unqualified" name="maxValue" type="xs:double" use="optional"/>
						<xs:attribute default="1" form="unqualified" name="upperMultiplicity"
							type="ers:UpperMultiplicity" use="optional"/>
						<!--
						<xs:assert test="not(@minValue) or not(@maxValue) or (@minValue le @maxValue)" 
							saxon:message="Attribute/@minValue must be less than Attribute/@maxValue!"/>
-->
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="GlobalFunction"
					type="ers:Function.type"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<!-- *** EntityType *** -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="EntityType" type="ers:EntityType.type"/>
	<xs:complexType name="EntityType.type">
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:documentation"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
				name="InheritedAttributeSettings">
				<xs:complexType>
					<xs:attribute form="unqualified" name="attribute" type="ers:CanonicalName" use="required"/>
					<xs:attribute form="unqualified" name="initialValue" type="xs:string" use="optional"/>
					<xs:attribute form="unqualified" name="minValue" type="xs:string" use="optional"/>
					<xs:attribute form="unqualified" name="maxValue" type="xs:string" use="optional"/>
				</xs:complexType>
			</xs:element>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Property"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Function"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="superType" type="ers:CanonicalName" use="optional"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** ObjectType *** -->
	<!-- =================================================================== -->
	<xs:element name="ObjectType" substitutionGroup="ers:EntityType" type="ers:ObjectType.type">
		<xs:key name="ObjectType-PropertyKey">
			<xs:selector xpath="ers:Attribute | ers:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="ObjectType.type">
		<xs:complexContent>
			<xs:extension base="ers:EntityType.type">
				<xs:sequence>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ComponentType"
						type="ers:ComponentType.type"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ComponentType.type">
		<xs:complexContent>
			<xs:extension base="ers:ObjectType.type">
				<xs:attribute default="0" form="unqualified" name="minOccurs" type="xs:nonNegativeInteger"
					use="optional"/>
				<xs:attribute default="unbounded" form="unqualified" name="maxOccurs"
					type="ers:UpperMultiplicity" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** PhysicalObjectType *** -->
	<!-- =================================================================== -->
	<xs:element name="PhysicalObjectType" substitutionGroup="ers:ObjectType"
		type="ers:PhysicalObjectType.type">
		<xs:key name="PhysicalObjectType-PropertyKey">
			<xs:selector xpath="ers:Attribute | ers:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="PhysicalObjectType.type">
		<xs:complexContent>
			<xs:extension base="ers:ObjectType.type">
				<xs:attribute default="NORMAL" form="unqualified" name="physicsType" use="optional">
					<xs:annotation>
						<xs:documentation>Defines collision behavior and perceivability. </xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="NORMAL">
								<xs:annotation>
									<xs:documentation>Participates in collisions and is perceivable.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
							<xs:enumeration value="INFINITE_MASS">
								<xs:annotation>
									<xs:documentation>Not affected by collisions, but perceivable. </xs:documentation>
								</xs:annotation>
							</xs:enumeration>
							<xs:enumeration value="IMMATERIAL">
								<xs:annotation>
									<xs:documentation>Does not participate in collisions, but is perceivable.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
							<xs:enumeration value="PHANTOM">
								<xs:annotation>
									<xs:documentation>Does not participate in collisions, and is neither perceivable.
									</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute default="false" form="unqualified" name="idPerceivable" type="xs:boolean"
					use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** EventType *** -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="EventType" substitutionGroup="ers:EntityType"
		type="ers:EventType.type"/>
	<xs:complexType name="EventType.type">
		<xs:complexContent>
			<xs:extension base="ers:EntityType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** Environment Event Types *** -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="EnvironmentEventType" substitutionGroup="ers:EventType"
		type="ers:EnvironmentEventType.type"/>
	<xs:complexType name="EnvironmentEventType.type">
		<xs:complexContent>
			<xs:extension base="ers:EventType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- *** CausedEventType *** -->
	<xs:element name="CausedEventType" substitutionGroup="ers:EnvironmentEventType"
		type="ers:CausedEventType.type">
		<xs:key name="CausedEventType-PropertyKey">
			<xs:selector xpath="ers:Attribute | ers:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="CausedEventType.type">
		<xs:complexContent>
			<xs:extension base="ers:EnvironmentEventType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- *** ExogeneousEventType *** -->
	<xs:element name="ExogenousEventType" substitutionGroup="ers:EnvironmentEventType"
		type="ers:ExogenousEventType.type">
		<xs:key name="ExogenousEventType-PropertyKey">
			<xs:selector xpath="ers:Attribute | ers:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="ExogenousEventType.type">
		<xs:complexContent>
			<xs:extension base="ers:EnvironmentEventType.type">
				<xs:sequence>
					<xs:element minOccurs="0" ref="ers:Periodicity"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:StopCondition"/>
				</xs:sequence>
				<xs:attribute form="unqualified" name="periodicity" type="xs:positiveInteger" use="optional"
				/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="Periodicity" type="ers:DiscreteRandomVariable-OR-ValueExpr"/>
	<xs:element name="StopCondition" type="ers:OpaqueExpression"/>
	<!-- =================================================================== -->
	<xs:complexType name="ReactionRule.type">
		<xs:complexContent>
			<xs:extension base="aors:ReactionRule.type_Redefined0">
				<xs:attributeGroup ref="aors:ActionRulesUsage.attributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ReactionRule.type_Redefined0">
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:documentation"/>
			<xs:choice>
				<xs:element form="qualified" name="WHEN" type="aors:TriggeringAgentRuleEventExpr.type"/>
				<xs:element ref="ers:ON-EACH-SIMULATION-STEP"/>
			</xs:choice>
			<xs:choice maxOccurs="unbounded" minOccurs="0">
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="FOR"
					type="aors:DataVariable-OR-BeliefEntityVariable-Declaration.type"/>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="FOR-ListItemVariable"
					type="aors:FOR-AgentRuleListItemVariable.type"/>
			</xs:choice>
			<xs:element form="qualified" minOccurs="0" name="DO" type="aors:AgtRuleDO.type"/>
			<xs:sequence minOccurs="0">
				<xs:element maxOccurs="unbounded" ref="ers:IF"/>
				<xs:element form="qualified" name="THEN" type="aors:AgtRuleDO.type"/>
				<xs:element form="qualified" minOccurs="0" name="ELSE" type="aors:AgtRuleDO.type"/>
			</xs:sequence>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="agentVariable" type="ers:CanonicalName" use="optional"/>
	</xs:complexType>
	<!--xs:complexType name="AgentType.type">
      <xs:complexContent>
        <xs:extension base="aors:AgentType.type">
          <xs:sequence>
            <xs:element ref="aors:OutMessageActionRule" minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>    
    <xs:complexType name="PhysicalAgentType.type">
      <xs:complexContent>
        <xs:extension base="aors:PhysicalAgentType.type">
          <xs:sequence>
            <xs:element ref="aors:AbstractActionRule" minOccurs="0" maxOccurs="unbounded"/>
          </xs:sequence>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType-->
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="Entity" type="ers:Entity.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Entity.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="type" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="id" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="name" type="xs:NCName" use="optional"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="Object" substitutionGroup="ers:Entity" type="ers:Object.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="Object.type">
		<xs:complexContent>
			<xs:extension base="ers:Entity.type">
				<xs:sequence>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectID"
						type="ers:OpaqueExpression"/>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Component"
						type="ers:Object.type"/>
				</xs:sequence>
				<!--  DROPPED in 0.8.4
				<xs:attribute name="addToCollection" type="ers:CanonicalName" use="optional">
					<xs:annotation><xs:documentation>Can be used to add the newly created object to a collection defined in the simulation  model.</xs:documentation></xs:annotation>
				</xs:attribute>
-->
				<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName"
					use="optional">
					<xs:annotation>
						<xs:documentation>Allows to define an object variable that can be used in the following
							object creation statements for accessing properies and functions of that
							object.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="PhysicalObject" substitutionGroup="ers:Object" type="ers:PhysicalObject.type">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>A physical object is considered a rigid body in the sense of physics. See
				also <h:a href="http://en.wikipedia.org/wiki/Rigid_body">Wikipedia</h:a>.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="PhysicalObject.type">
		<xs:complexContent>
			<xs:extension base="ers:Object.type">
				<xs:attributeGroup ref="ers:PhysicalObject.attributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:attributeGroup name="PhysicalObject.attributes">
		<!-- =================================================================== -->
		<xs:attribute default="false" form="unqualified" name="hasRandomPosition" type="xs:boolean"
			use="optional"/>
		<xs:attribute default="false" form="unqualified" name="ignorePositionConstraint"
			type="xs:boolean" use="optional"/>
		<xs:attribute default="0" form="unqualified" name="m" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The mass of a physical object in gram.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="materialType">
			<xs:annotation>
				<xs:documentation>The material type determines the restitution and friction of a physical
					object.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="Wood"/>
					<xs:enumeration value="Iron"/>
					<xs:enumeration value="Aluminium"/>
					<xs:enumeration value="Rubber"/>
					<xs:enumeration value="Stone"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="width" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The spatial extension of a 2D rectangular (or 3D box-shaped) physical
					object is given in terms of width and height (and depth) in the unit as defined in the
					space model (spatialDistanceUnit). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="height" type="xs:double" use="optional"/>
		<xs:attribute default="0" form="unqualified" name="depth" type="xs:double" use="optional"/>
		<xs:attribute form="unqualified" name="points" type="ers:CoordinatePairSequence.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>Provides a list of points in counter-clockwise order in the syntax of a
					space-separated XML attribute value list such as points="1.5,2 -2,2 -2.5,1.5".
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="rectangle" form="unqualified" name="shape2D" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the shape of a 2D object. By default, this is a rectangle. In the
					case of a circle, its radius is given by the width attribute. In the case of a polygon,
					the points attribute provides the list of points in counter-clockwise order.
				</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="rectangle"/>
					<xs:enumeration value="circle"/>
					<xs:enumeration value="polygon"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute default="box" form="unqualified" name="shape3D" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the shape of a 3D object. By default, this is a box (cuboid). In
					the case of a sphere, its radius is given by the width attribute. In the case of a
					cylinder or a cone, the radius is given by the width attribute and the height is given by
					the height attribute. </xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="box"/>
					<xs:enumeration value="sphere"/>
					<xs:enumeration value="cylinder"/>
					<xs:enumeration value="cone"/>
					<xs:enumeration value="mesh"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="pos" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The linear position of a physical object given in the unit as defined in
					the space model (spatialDistanceUnit).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="x" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The x coordinate of the linear position (first component of the pos
					vector) of a physical object given in the unit as defined in the space model
					(spatialDistanceUnit).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="y" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The y coordinate of the linear position (2nd component of the pos vector)
					of a physical object given in the unit as defined in the space model
					(spatialDistanceUnit).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="z" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The z coordinate of the linear position (3rd component of the pos vector)
					of a physical object given in the unit as defined in the space model
					(spatialDistanceUnit).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="v" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The vector v = (vx,vy,vz) is the linear velocity of a physical object in
					meter/seconds. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="vx" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the linear velocity vector v = (vx,vy,vz) in m/sec.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="vy" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the linear velocity vector v = (vx,vy,vz) in m/sec.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="vz" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the linear velocity vector v = (vx,vy,vz) in m/sec.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="a" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The vector a = (ax,ay,az) is the linear acceleration of a physical object
					in meter per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="ax" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the linear acceleration vector a = (ax,ay,az) in
					meter per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="ay" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the linear acceleration vector a = (ax,ay,az) in
					meter per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="az" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the linear acceleration vector a = (ax,ay,az) in
					meter per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rot2D" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The angular position of a 2D-physical object in radians (1 rad = 180/pi =
					57.2958 degrees).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rot2DinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The angular position of a 2D-physical object in degrees.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="rot" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The vector rot = ( rotX, rotY, rotZ) is the angular position of a
					3D-physical object in radians where 1 rad = 180/pi = 57.2958 degrees, see <h:a
						href="http://wiki.secondlife.com/wiki/Rotation">Second Life</h:a> and <h:a
						href="http://en.wikipedia.org/wiki/Yaw,_pitch_and_roll">Wikipedia</h:a>.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="rotInDegrees"
			type="ers:DoubleTriple.type" use="optional">
			<xs:annotation>
				<xs:documentation>The vector rotInDegrees = ( rotXinDegrees, rotYinDegrees, rotZinDegrees)
					is the angular position of a 3D-physical object in degrees, see <h:a
						href="http://wiki.secondlife.com/wiki/Rotation">Second Life</h:a> and <h:a
						href="http://en.wikipedia.org/wiki/Yaw,_pitch_and_roll">Wikipedia</h:a>.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotX" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular position vector rot = ( rotX, rotY,
					rotZ). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotXinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular position vector rotInDegrees = (
					rotXinDegrees, rotYinDegrees, rotZinDegrees). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotY" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular position vector rot = ( rotX, rotY,
					rotZ). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotYinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular position vector rotInDegrees = (
					rotXinDegrees, rotYinDegrees, rotZinDegrees). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotZ" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular position vector rot = ( rotX, rotY,
					rotZ). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="rotZinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular position vector rotInDegrees = (
					rotXinDegrees, rotYinDegrees, rotZinDegrees). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omega2D" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The rotational velocity of a 2D-physical object in radians per
					second.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omega2DinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The rotational velocity of a 2D-physical object in degrees per
					second.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="omega" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The vector omega = (omegaX,omegaY,omegaZ) is the angular velocity of a
					3D-physical object in radians per second. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaX" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular velocity vector (omegaX,omegaY,omegaZ)
					in radians per second. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaY" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular velocity vector (omegaX,omegaY,omegaZ) in
					radians per second. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaZ" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular velocity vector (omegaX,omegaY,omegaZ) in
					radians per second. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="omegaInDegrees"
			type="ers:DoubleTriple.type" use="optional">
			<xs:annotation>
				<xs:documentation>The vector omegaInDegrees =
					(omegaXinDegrees,omegaYinDegrees,omegaZinDegrees) is the angular velocity of a 3D-physical
					object in degrees per second. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaXinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular velocity omegaInDegrees =
					(omegaXinDegrees,omegaYinDegrees,omegaZinDegrees) in degrees per second.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaYinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular velocity vector omegaInDegrees =
					(omegaXinDegrees,omegaYinDegrees,omegaZinDegrees) in degrees per second.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="omegaZinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular velocity vector omegaInDegrees =
					(omegaXinDegrees,omegaYinDegrees,omegaZinDegrees) in degrees per second.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alpha2D" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The rotational acceleration of a 2D-physical object in radians per second
					squared.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alpha2DinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The rotational acceleration of a 2D-physical object in degrees per second
					squared.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="alpha" type="ers:DoubleTriple.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>The vector alpha = (alphaX,alphaY,alphaZ) is the angular acceleration of a
					3D-physical object in radians per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaX" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular acceleration vector alpha =
					(alphaX,alphaY,alphaZ) in radians per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaY" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular acceleration vector alpha =
					(alphaX,alphaY,alphaZ) in radians per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaZ" type="xs:double" use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular acceleration vector alpha =
					(alphaX,alphaY,alphaZ) in radians per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0 0 0" form="unqualified" name="alphaInDegrees"
			type="ers:DoubleTriple.type" use="optional">
			<xs:annotation>
				<xs:documentation>The vector alphaInDegrees =
					(alphaXinDegrees,alphaYinDegrees,alphaZinDegrees) is the angular acceleration of a
					3D-physical object in degrees per second squared. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaXinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The first component of the angular acceleration vector alphaInDegrees =
					(alphaXinDegrees,alphaYinDegrees,alphaZinDegrees) in degrees per second squared.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaYinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 2nd component of the angular acceleration vector alphaInDegrees =
					(alphaXinDegrees,alphaYinDegrees,alphaZinDegrees) in degrees per second squared.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute default="0" form="unqualified" name="alphaZinDegrees" type="xs:double"
			use="optional">
			<xs:annotation>
				<xs:documentation>The 3rd component of the angular acceleration vector alphaInDegrees =
					(alphaXinDegrees,alphaYinDegrees,alphaZinDegrees) in degrees per second squared.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:element abstract="true" name="AtomicEvent" substitutionGroup="ers:Entity"
		type="ers:AtomicEvent.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="AtomicEvent.type">
		<xs:complexContent>
			<xs:extension base="ers:AtomicEvent-0.type">
				<xs:attribute form="unqualified" name="occurrenceTime" type="xs:positiveInteger"
					use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AtomicEvent-0.type">
		<xs:complexContent>
			<xs:restriction base="ers:Entity.type">
				<xs:sequence>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
				</xs:sequence>
				<xs:attribute form="unqualified" name="type" type="ers:CanonicalName" use="required"/>
				<xs:attribute form="unqualified" name="id" type="xs:long" use="prohibited"/>
				<xs:attribute form="unqualified" name="name" type="xs:NCName" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element abstract="true" name="EnvironmentEvent" substitutionGroup="ers:AtomicEvent"
		type="ers:EnvironmentEvent.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="EnvironmentEvent.type">
		<xs:complexContent>
			<xs:restriction base="ers:AtomicEvent.type">
				<xs:sequence>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
				</xs:sequence>
				<xs:attribute form="unqualified" name="type" type="ers:CanonicalName" use="required"/>
				<xs:attribute form="unqualified" name="occurrenceTime" type="xs:positiveInteger"
					use="required"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="ExogenousEvent" substitutionGroup="ers:EnvironmentEvent"
		type="ers:ExogeneousEvent.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="ExogeneousEvent.type">
		<xs:complexContent>
			<xs:extension base="ers:EnvironmentEvent.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="CausedEvent" substitutionGroup="ers:EnvironmentEvent"
		type="ers:ExogeneousEvent.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="CausedEvent.type">
		<xs:complexContent>
			<xs:extension base="ers:EnvironmentEvent.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="Objects" type="ers:ObjectSet.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="ObjectSet.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeStartID"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeEndID"
				type="ers:OpaqueExpression"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="type" type="xs:string" use="required"/>
		<xs:attribute form="unqualified" name="rangeStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="rangeEndID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="creationLoopVar" type="ers:CanonicalName" use="optional"
		/>
	</xs:complexType>
	<!-- ***  Physical Objects  *** -->
	<xs:element name="PhysicalObjects" substitutionGroup="ers:Objects"
		type="ers:PhysicalObjectSet.type"/>
	<xs:complexType name="PhysicalObjectSet.type">
		<xs:complexContent>
			<xs:extension base="ers:ObjectSet.type">
				<xs:attributeGroup ref="ers:PhysicalObject.attributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="GridCells">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice>
				<xs:choice maxOccurs="unbounded">
					<xs:element form="qualified" name="GridCell" type="ers:GridCell.type"/>
					<xs:element form="qualified" name="GridCellSet" type="ers:GridCellSet.type"/>
				</xs:choice>
				<xs:element maxOccurs="unbounded" ref="ers:Slot"/>
			</xs:choice>
		</xs:complexType>
	</xs:element>
	<xs:complexType name="GridCell.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" ref="ers:Slot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="x" type="xs:double" use="required"/>
		<xs:attribute form="unqualified" name="y" type="xs:double" use="required"/>
	</xs:complexType>
	<xs:complexType name="GridCellSet.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" ref="ers:Slot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="startX" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute form="unqualified" name="endX" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute form="unqualified" name="startY" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute form="unqualified" name="endY" type="xs:nonNegativeInteger" use="required"/>
		<xs:attribute form="unqualified" name="creationLoopVar" type="ers:CanonicalName" use="optional"
		/>
	</xs:complexType>
	<!-- DROPPED in 0.8.4 =================================================================== 
	<xs:element name="Collection" type="ers:Collection.type" substitutionGroup="ers:Object"/>
	<xs:complexType name="Collection.type">
		<xs:complexContent>
			<xs:extension base="ers:Collection.type0">
				<xs:attribute name="itemType" type="ers:CanonicalName" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="Collection.type0">
		<xs:complexContent>
			<xs:restriction base="ers:Object.type">
				<xs:sequence>
					<xs:element ref="ers:Slot" minOccurs="0" maxOccurs="unbounded"/>
				</xs:sequence>
				<xs:attribute name="id" type="xs:long" use="optional"/>
				<xs:attribute name="name" type="xs:NCName" use="optional"/>
				<xs:attribute name="type" use="required">
					<xs:simpleType>
						<xs:restriction base="ers:CanonicalName">
							<xs:enumeration value="FIFO_QUEUE"/>
							<xs:enumeration value="LIFO_QUEUE"/>
							<xs:enumeration value="SET"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	-->
	<!-- =================================================================== -->
	<!-- *** Agent *** -->
	<!-- =================================================================== -->
	<xs:element name="Agent" substitutionGroup="ers:Object" type="aors:Agent.type"/>
	<xs:complexType name="Agent.type">
		<xs:complexContent>
			<xs:extension base="ers:Object.type">
				<xs:group ref="aors:Agent.elements"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:group name="Agent.elements">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:SelfBeliefSlot"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:BeliefEntity"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:TimeEvent"/>
		</xs:sequence>
	</xs:group>
	<xs:element name="SelfBeliefSlot" type="ers:Slot.type"/>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- *** BeliefEntity  *** -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="BeliefEntity" type="aors:BeliefEntity.type"/>
	<xs:complexType name="BeliefEntity.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="IdRef"
				type="ers:OpaqueExpression"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:BeliefSlot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="type" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="idRef" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="name" type="xs:NCName" use="optional"/>
	</xs:complexType>
	<xs:element name="BeliefSlot" type="ers:Slot.type"/>
	<!-- =================================================================== -->
	<!-- *** PhysicalAgent  *** -->
	<!-- =================================================================== -->
	<xs:element name="PhysicalAgent" substitutionGroup="ers:PhysicalObject"
		type="aors:PhysicalAgent.type"/>
	<xs:complexType name="PhysicalAgent.type">
		<xs:complexContent>
			<xs:extension base="ers:PhysicalObject.type">
				<xs:group ref="aors:Agent.elements"/>
				<xs:attribute default="100" form="unqualified" name="perceptionRadius" type="xs:double"
					use="optional"/>
				<xs:attribute default="100" form="unqualified" name="perceptionAngle" type="xs:double"
					use="optional">
					<xs:annotation>
						<xs:documentation>The perception angle given in % (by default it's 100% = 360 degrees).
							NOT YET SUPPORTED!</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute form="unqualified" name="perceptionDirection" type="ers:DoubleTriple.type"
					use="optional">
					<xs:annotation>
						<xs:documentation>The drection in which the agent is perceiving. Only meaningful, if the
							perception angle is smaller than 360 degrees.  NOT YET SUPPORTED!</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element abstract="true" name="InternalEvent" substitutionGroup="ers:AtomicEvent"
		type="aors:InternalEvent.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="InternalEvent.type">
		<xs:complexContent>
			<xs:extension base="ers:AtomicEvent.type">
				<xs:sequence>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="OccurrenceTime"
						type="aors:OpaqueExpression"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element abstract="true" name="TimeEvent" substitutionGroup="aors:InternalEvent"
		type="aors:TimeEvent.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="TimeEvent.type">
		<xs:complexContent>
			<xs:extension base="aors:InternalEvent.type"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="PeriodicTimeEvent" substitutionGroup="aors:TimeEvent"
		type="aors:PeriodicTimeEvent.type"/>
	<xs:complexType name="PeriodicTimeEvent.type">
		<xs:complexContent>
			<xs:extension base="aors:TimeEvent.type"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="ReminderEvent" substitutionGroup="aors:TimeEvent" type="aors:ReminderEvent.type"/>
	<xs:complexType name="ReminderEvent.type">
		<xs:complexContent>
			<xs:extension base="aors:ReminderEvent-0.type">
				<xs:sequence>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ReminderMsg"
						type="aors:OpaqueExpression"/>
				</xs:sequence>
				<xs:attribute form="unqualified" name="reminderMsg" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ReminderEvent-0.type">
		<xs:complexContent>
			<xs:restriction base="aors:TimeEvent.type">
				<xs:sequence>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="OccurrenceTime"
						type="aors:OpaqueExpression"/>
				</xs:sequence>
				<xs:attribute fixed="ReminderEvent" form="unqualified" name="type" type="ers:CanonicalName"
					use="required"/>
				<xs:attribute form="unqualified" name="occurrenceTime" type="xs:positiveInteger"
					use="optional"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** ActualPerceptionEvent  *** -->
	<!-- =================================================================== -->
	<xs:element name="ActualPerceptionEvent" substitutionGroup="aors:InternalEvent"
		type="aors:ActualPerceptionEvent.type"/>
	<xs:complexType name="ActualPerceptionEvent.type">
		<xs:complexContent>
			<xs:extension base="aors:InternalEvent.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="ActualInMessageEvent" substitutionGroup="aors:ActualPerceptionEvent"
		type="aors:ActualInMessageEvent.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="ActualInMessageEvent.type">
		<xs:complexContent>
			<xs:extension base="aors:ActualPerceptionEvent.type">
				<xs:attribute form="unqualified" name="sender" type="xs:string" use="required"/>
				<xs:attribute form="unqualified" name="message" type="xs:string" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** Message  *** -->
	<!-- =================================================================== -->
	<xs:element name="Message" substitutionGroup="ers:Entity" type="aors:Message.type"/>
	<xs:complexType name="Message.type">
		<xs:complexContent>
			<xs:extension base="ers:Entity.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- ***  Agents *** -->
	<!-- =================================================================== -->
	<xs:element name="Agents" substitutionGroup="ers:Objects">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="ers:ObjectSet.type">
					<xs:sequence>
						<xs:group ref="aors:Agent.elements"/>
					</xs:sequence>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<!-- ***  Physical Agents  *** -->
	<xs:element name="PhysicalAgents" substitutionGroup="ers:PhysicalObjects">
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="ers:PhysicalObjectSet.type">
					<xs:sequence>
						<xs:group ref="aors:Agent.elements"/>
					</xs:sequence>
					<xs:attribute default="100" form="unqualified" name="perceptionRadius" type="xs:double"
						use="optional"/>
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<!-- =================================================================== -->
	<xs:complexType name="TriggeringAtomicEventExpr.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexContent>
			<xs:extension base="ers:TriggeringAtomicEventExpr.type_Redefined0">
				<xs:attribute form="unqualified" name="messageType" type="ers:CanonicalName" use="optional">
					<xs:annotation>
						<xs:documentation>Message type is only allowed for
							eventType="InMessageEvent".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute form="unqualified" name="messageVariable" type="ers:CanonicalName"
					use="optional">
					<xs:annotation>
						<xs:documentation>Message variable is only allowed for
							eventType="InMessageEvent".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TriggeringAtomicEventExpr.type_Redefined0">
		<xs:attribute form="unqualified" name="eventType" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="eventVariable" type="ers:CanonicalName" use="optional"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="ResEnvEvtExpr.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexContent>
			<xs:extension base="ers:ResEnvEvtExpr.type_Redefined0">
				<xs:sequence>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
						name="PerceptionEventExpr">
						<xs:annotation>
							<xs:documentation xml:lang="en">Allows to specify a set of perceivers either as a set
								of agent IDs or as a set of perceiver child elements with parametrized ID
								expressions.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Condition"/>
								<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
									name="PerceiverIdRef" type="ers:OpaqueExpression"/>
								<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Delay"/>
								<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
							</xs:sequence>
							<xs:attribute form="unqualified" name="eventType" type="ers:CanonicalName"
								use="required"/>
							<xs:attribute form="unqualified" name="perceiverIdRefs" type="ers:ListOfLong"
								use="optional"/>
							<xs:attribute default="0" form="unqualified" name="delay" type="xs:nonNegativeInteger"
								use="optional"/>
						</xs:complexType>
					</xs:element>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="InMessageEventExpr">
						<xs:complexType>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Condition"/>
								<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="SenderIdRef"
									type="ers:OpaqueExpression"/>
								<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
									name="ReceiverIdRef" type="ers:OpaqueExpression"/>
								<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Delay"/>
								<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
							</xs:sequence>
							<xs:attribute form="unqualified" name="messageType" type="ers:CanonicalName"
								use="required"/>
							<xs:attribute form="unqualified" name="senderIdRef" type="xs:long" use="optional"/>
							<xs:attribute form="unqualified" name="receiverIdRefs" type="ers:ListOfLong"
								use="optional"/>
							<xs:attribute default="0" form="unqualified" name="delay" type="xs:nonNegativeInteger"
								use="optional"/>
						</xs:complexType>
					</xs:element>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
						name="ActivityStartEventExpr">
						<xs:complexType>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Condition"/>
								<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
									name="CorrelationValue" type="ers:OpaqueExpression"/>
								<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ActorRef"
									type="ers:OpaqueExpression"/>
								<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ActorIdRef"
									type="ers:OpaqueExpression"/>
								<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Delay"/>
							</xs:sequence>
							<xs:attribute form="unqualified" name="activityType" type="ers:CanonicalName"
								use="required"/>
							<xs:attribute form="unqualified" name="actorIdRef" type="xs:long" use="optional"/>
							<xs:attribute default="0" form="unqualified" name="delay" type="xs:nonNegativeInteger"
								use="optional"/>
							<xs:attribute form="unqualified" name="correlationValue" type="xs:string"
								use="optional"/>
						</xs:complexType>
					</xs:element>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
						name="ActivityEndEventExpr">
						<xs:complexType>
							<xs:sequence>
								<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Condition"/>
								<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
									name="CorrelationValue" type="ers:OpaqueExpression"/>
								<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Delay"/>
							</xs:sequence>
							<xs:attribute form="unqualified" name="activityType" type="ers:CanonicalName"
								use="required"/>
							<xs:attribute default="0" form="unqualified" name="delay" type="xs:nonNegativeInteger"
								use="optional"/>
							<xs:attribute form="unqualified" name="correlationValue" type="xs:string"
								use="optional"/>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ResEnvEvtExpr.type_Redefined0">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="CausedEventExpr">
				<xs:complexType>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Condition"/>
						<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Delay"/>
						<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
					</xs:sequence>
					<xs:attribute form="unqualified" name="eventType" type="ers:CanonicalName" use="required"/>
					<xs:attribute form="unqualified" name="delay" type="xs:positiveInteger" use="optional"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- ==================================================================== -->
	<!-- ==================================================================== -->
	<xs:complexType name="TriggeringEnvironmentRuleEventExpr.type">
		<!-- ==================================================================== -->
		<xs:complexContent>
			<xs:extension base="ers:TriggeringAtomicEventExpr.type">
				<!-- TODO		
	<xs:attribute name="actorVariable" type="ers:CanonicalName" use="optional"/>
-->
				<xs:attribute form="unqualified" name="activityType" type="ers:CanonicalName" use="optional"
				/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- ==================================================================== -->
	<xs:element name="ON-EACH-SIMULATION-STEP">
		<!-- ==================================================================== -->
		<xs:complexType/>
	</xs:element>
	<xs:element name="IF" type="ers:Condition.type"/>
	<!-- =================================================================== -->
	<xs:element name="EnvironmentRules">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:EnvironmentRule"/>
			</xs:sequence>
		</xs:complexType>
		<xs:key name="RuleName">
			<xs:selector xpath="ers:EnvironmentRule"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<!-- ==================================================================== -->
	<xs:element name="EnvironmentRule" type="ers:EnvironmentRule.type"/>
	<!-- ==================================================================== -->
	<xs:complexType name="EnvironmentRule.type">
		<xs:sequence>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:documentation"/>
				<xs:choice>
					<xs:element form="qualified" name="WHEN"
						type="ers:TriggeringEnvironmentRuleEventExpr.type"/>
					<xs:element ref="ers:ON-EACH-SIMULATION-STEP"/>
				</xs:choice>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:FOR"/>
				<xs:group maxOccurs="unbounded" minOccurs="0" ref="ers:FOR.grp"/>
				<xs:element form="qualified" minOccurs="0" name="DO" type="ers:EnvRuleDO.type"/>
				<xs:sequence minOccurs="0">
					<xs:element maxOccurs="unbounded" ref="ers:IF"/>
					<xs:element form="qualified" name="THEN" type="ers:EnvRuleDO.type"/>
					<xs:element form="qualified" minOccurs="0" name="ELSE" type="ers:EnvRuleDO.type"/>
				</xs:sequence>
			</xs:sequence>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="EnvRuleDO.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:UPDATE-ENV"/>
			<xs:element form="qualified" minOccurs="0" name="SCHEDULE-EVT" type="ers:ResEnvEvtExpr.type"/>
		</xs:sequence>
	</xs:complexType>
	<!-- ==================================================================== -->
	<xs:element name="InitializationRule">
		<!-- ==================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:documentation"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:FOR"/>
				<xs:group maxOccurs="unbounded" minOccurs="0" ref="ers:FOR.grp"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:IF"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:UpdateObject"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:UpdateObjects"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:UpdateGridCell"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ForEachGridCell"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="FOR" type="ers:VariableDeclaration.type"/>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="VariableDeclaration.type">
		<xs:annotation>
			<xs:documentation>A FOR element declares either a data variable or an object variable using
				the corresponding subelements and attributes. A data variable must be bound to a value. An
				object variable can be bound to a single object or to an object type. In the latter case the
				FOR element defines a loop over all instances of the object type. It's an option to refine
				this loop by providing a selection condition. </xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0">
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectRef"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectIdRef"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="SelectionCondition"
				type="ers:OpaqueExpression"/>
		</xs:choice>
		<xs:attribute form="unqualified" name="dataVariable" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="dataType" type="ers:PrimitiveDataType" use="optional"/>
		<xs:attribute form="unqualified" name="refDataType" type="ers:CanonicalName" use="optional">
			<xs:annotation>
				<xs:documentation>A reference datatype (i.e. a class or array type). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="objectIdRef" type="xs:long" use="optional">
			<xs:annotation>
				<xs:documentation>If used without specifying an @objectType, then the object vaiable is
					declared to be of type Objekt, otherwise of @objectType.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="objectName" type="xs:NCName" use="optional">
			<xs:annotation>
				<xs:documentation>If used without specifying an @objectType, then the object vaiable is
					declared to be of type Objekt, otherwise of @objectType.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="rangeStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="rangeEndID" type="xs:long" use="optional"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="FOR.grp">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:element form="qualified" name="FOR-DataVariable" type="ers:FOR-DataVariable.type">
				<xs:annotation>
					<xs:documentation>Not yet implemented! Declares a data variable that must be bound to a
						value. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="FOR-ObjectVariable" type="ers:FOR-ObjectVariable.type">
				<xs:annotation>
					<xs:documentation>Not yet implemented! Declares an object variable, which may be bound to
						a single object or to an object type. In the latter case the element defines a loop over
						all instances of the object type. It's an option to refine this loop by providing a
						selection condition. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element form="qualified" name="FOR-ListItemVariable" type="ers:FOR-ListItemVariable.type">
				<xs:annotation>
					<xs:documentation>Not yet implemented!</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="FOR-DataVariable.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element maxOccurs="unbounded" ref="ers:ValueExpr"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="dataType" type="ers:PrimitiveDataType" use="optional"/>
		<xs:attribute form="unqualified" name="refDataType" type="ers:CanonicalName" use="optional">
			<xs:annotation>
				<xs:documentation>A class or array type.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="FOR-ObjectVariable.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectRef"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectIdRef"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="SelectionCondition"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="objectIdRef" type="xs:long" use="optional">
			<xs:annotation>
				<xs:documentation>If used without specifying an @objectType, then the object vaiable is
					declared to be of type Objekt, otherwise of @objectType.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="objectName" type="xs:NCName" use="optional">
			<xs:annotation>
				<xs:documentation>If used without specifying an @objectType, then the object vaiable is
					declared to be of type Objekt, otherwise of @objectType.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="rangeStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="rangeEndID" type="xs:long" use="optional"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="FOR-ListItemVariable.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ListExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="listItemType" type="ers:PathName" use="required"/>
		<xs:attribute form="unqualified" name="listValuedGlobalVariable" type="ers:CanonicalName"
			use="optional"/>
	</xs:complexType>
	<!-- ==================================================================== -->
	<!-- *** SCHEDULE-EVT for Environment Rules *** -->
	<!-- ==================================================================== -->
	<xs:element name="Delay" type="ers:DiscreteRandomVariable-OR-ValueExpr"/>
	<!-- =========================================================== -->
	<xs:element name="UPDATE-ENV" type="ers:UpdateObjectiveStateExpr.type"/>
	<!-- =========================================================== -->
	<xs:complexType name="UpdateObjectiveStateExpr.type">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded" minOccurs="0">
				<xs:element ref="ers:UpdateGlobalVariable"/>
				<xs:element ref="ers:IncrementGlobalVariable"/>
				<xs:element ref="ers:UpdateMultiValuedGlobalVariable"/>
				<xs:element ref="ers:UpdateObject"/>
				<xs:element ref="ers:UpdateGridCell"/>
				<xs:element ref="ers:ForEachGridCell"/>
				<xs:element ref="ers:UpdateStatisticsVariable"/>
				<xs:element ref="ers:Create"/>
				<xs:element ref="ers:DestroyObject"/>
				<xs:element ref="ers:Call"/>
			</xs:choice>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:UpdateObjects"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:DestroyObjects"/>
		</xs:sequence>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateGlobalVariable" type="ers:UpdateGlobalVariable.type"/>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="UpdateGlobalVariable.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="value" type="xs:string" use="optional"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="IncrementGlobalVariable">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="value" type="xs:long" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateMultiValuedGlobalVariable">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>For changing the value of a list-valued global variable.</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:group maxOccurs="unbounded" ref="ers:ChangeMultiValuedProperty.group"/>
			<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateObject">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectRef">
					<xs:complexType>
						<xs:simpleContent>
							<xs:extension base="ers:OpaqueExpression">
								<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName"
									use="required"/>
							</xs:extension>
						</xs:simpleContent>
					</xs:complexType>
				</xs:element>
				<xs:choice maxOccurs="unbounded" minOccurs="0">
					<xs:element ref="ers:Increment"/>
					<xs:element ref="ers:Decrement"/>
					<xs:element ref="ers:Slot"/>
					<xs:element ref="ers:MultiValuedSlot"/>
					<xs:element ref="ers:Call"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName" use="optional"
			/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateGridCell">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="1" name="XCoordinate"
					type="ers:OpaqueExpression"/>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="1" name="YCoordinate"
					type="ers:OpaqueExpression"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Increment"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Decrement"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:MultiValuedSlot"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="gridCellVariable" type="ers:CanonicalName"
				use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ForEachGridCell">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:Selection"/>
				<xs:choice>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Code"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Increment"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Decrement"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
				</xs:choice>
			</xs:sequence>
			<xs:attribute form="unqualified" name="gridCellVariable" type="ers:CanonicalName"
				use="optional"/>
			<xs:attribute form="unqualified" name="startX" type="xs:nonNegativeInteger" use="optional"/>
			<xs:attribute form="unqualified" name="endX" type="xs:nonNegativeInteger" use="optional"/>
			<xs:attribute form="unqualified" name="startY" type="xs:nonNegativeInteger" use="optional"/>
			<xs:attribute form="unqualified" name="endY" type="xs:nonNegativeInteger" use="optional"/>
			<xs:attribute form="unqualified" name="selectionList" type="ers:PathName" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateObjects">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeStartID"
					type="ers:OpaqueExpression"/>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeEndID"
					type="ers:OpaqueExpression"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Increment"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Decrement"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="rangeStartID" type="xs:long" use="optional"/>
			<xs:attribute form="unqualified" name="rangeEndID" type="xs:long" use="optional"/>
			<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="loopVariable" type="ers:CanonicalName" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DROPPED in 0.8.4
	<xs:element name="AddObjectToCollection">

		<xs:complexType>
			<xs:sequence>
				<xs:element name="ItemObjectRef" type="ers:OpaqueExpression" minOccurs="0" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attribute name="collectionName" type="ers:CanonicalName" use="optional"/>
			<xs:attribute name="collectionID" type="xs:long" use="optional"/>
			<xs:attribute name="collectionObjectVariable" type="ers:CanonicalName" use="optional"/>
			<xs:attribute name="itemObjectVariable" type="ers:CanonicalName" use="optional"/>
		</xs:complexType>
	</xs:element>

	<xs:element name="RemoveObjectFromCollection">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="ItemObjectRef" type="ers:OpaqueExpression" minOccurs="0" maxOccurs="unbounded"/>
			</xs:sequence>
			<xs:attribute name="collectionName" type="ers:CanonicalName" use="optional"/>
			<xs:attribute name="collectionID" type="xs:long" use="optional"/>
			<xs:attribute name="collectionObjectVariable" type="ers:CanonicalName" use="optional"/>
			<xs:attribute name="itemObjectVariable" type="ers:CanonicalName" use="optional"/>
			<xs:attribute name="destroyObject" type="xs:boolean" use="optional"/>
		</xs:complexType>
	</xs:element>
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Increment" type="ers:Increment.type"/>
	<xs:element name="Decrement" type="ers:Increment.type"/>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="Increment.type">
		<xs:attribute form="unqualified" name="property" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="value" type="xs:long" use="required"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateStatisticsVariable">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:ValueExpr"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Call">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Argument">
					<xs:complexType>
						<xs:sequence>
							<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
						</xs:sequence>
						<xs:attribute form="unqualified" name="parameter" type="xs:string" use="required"/>
						<xs:attribute form="unqualified" name="value" type="xs:string" use="optional"/>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute form="unqualified" name="procedure" type="ers:CanonicalName" use="required">
				<xs:annotation>
					<xs:documentation>A function/procedure defined in an object type.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute form="unqualified" name="contextObjectVariable" type="ers:CanonicalName"
				use="required">
				<xs:annotation>
					<xs:documentation>This variable must have been declared by a FOR element, or, in a
						reaction rule,       it can be the agent variable.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ==================================== -->
	<!-- *** Create & Destroy *** -->
	<!-- ==================================== -->
	<xs:element name="Create">
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Object"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Objects"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:element name="DestroyObject">
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectRef"
					type="ers:OpaqueExpression"/>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ObjectIdRef"
					type="ers:OpaqueExpression"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName" use="optional"/>
			<xs:attribute form="unqualified" name="objectIdRef" type="xs:long" use="optional"/>
			<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName" use="optional"/>
			<xs:attribute form="unqualified" name="removeFromCollection" type="ers:CanonicalName"
				use="optional"/>
			<xs:attribute default="false" form="unqualified" name="deferred" type="xs:boolean"
				use="optional">
				<xs:annotation>
					<xs:documentation>If this attribute is set to true, the object will only be destroyed at
						the end of the rule execution after the resulting events have been
						created.</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<xs:element name="DestroyObjects" type="ers:DestroyObjects.type"/>
	<xs:complexType name="DestroyObjects.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeStartID"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="RangeEndID"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName"/>
		<xs:attribute form="unqualified" name="rangeStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="rangeEndID" type="xs:long" use="optional"/>
		<xs:attribute default="false" form="unqualified" name="deferred" type="xs:boolean"
			use="optional">
			<xs:annotation>
				<xs:documentation>If this attribute is set to true, the objects will only be destroyed at
					the end of the rule execution after the resulting events have been
					created.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- 
	<xs:group name="AgentRule.sharedElements">
		<xs:sequence>
			<xs:element ref="ers:documentation" minOccurs="0"/>
			<xs:choice>
				<xs:element name="WHEN" type="aors:TriggeringEnvironmentRuleAtomicEventExpr.type"/>
				<xs:element ref="ers:ON-EACH-SIMULATION-STEP"/>
			</xs:choice>
			<xs:element name="FOR" type="aors:DataVariable-OR-BeliefEntityVariable-Declaration.type" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:group>
-->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="DataVariable-OR-BeliefEntityVariable-Declaration.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="BeliefEntityIdRef"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="BeliefEntityType"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="dataVariable" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="dataType" type="ers:PrimitiveDataType" use="optional"/>
		<xs:attribute form="unqualified" name="refDataType" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="beliefEntityVariable" type="ers:CanonicalName"
			use="optional"/>
		<xs:attribute form="unqualified" name="beliefEntityType" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="beliefEntityIdRef" type="xs:long" use="optional"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="FOR-AgentRuleListItemVariable.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ListExpr"
				type="ers:OpaqueExpression"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="listItemType" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="listValuedAgentProperty" type="ers:CanonicalName"
			use="optional"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="CreateDescription">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="descriptionVariable" type="ers:CanonicalName"
				use="required"/>
			<xs:attribute form="unqualified" name="beliefEntityVariable" type="ers:CanonicalName"
				use="required"/>
			<xs:attribute form="unqualified" name="properties" type="ers:ListOfCanonicalName"
				use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ==================================================================== -->
	<xs:element name="ReactionRule" type="aors:ReactionRule.type"/>
	<!-- ==================================================================== -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="TriggeringAgentRuleEventExpr.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexContent>
			<xs:extension base="aors:TriggeringAtomicEventExpr.type">
				<xs:attribute form="unqualified" name="reminderMsg" type="ers:CanonicalName" use="optional">
					<xs:annotation>
						<xs:documentation>The reminderMsg attribute must only be used in case
							eventType="ReminderEvent".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute form="unqualified" name="physicalObjectType" type="aors:JavaTypeName"
					use="optional">
					<xs:annotation>
						<xs:documentation>The physicalObjectType attribute must only be used in case
							eventType="PhysicalObjectPerceptionEvent".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute form="unqualified" name="perceivedObjectVariable" type="ers:CanonicalName"
					use="optional">
					<xs:annotation>
						<xs:documentation>The perceivedObjectVariable attribute must only be used in case
							eventType="PhysicalObjectPerceptionEvent".</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="AgtRuleDO.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element minOccurs="0" ref="aors:UPDATE-AGT"/>
			<xs:element form="qualified" minOccurs="0" name="SCHEDULE-EVT"
				type="aors:AgtRuleResEvtExpr.type"/>
		</xs:sequence>
	</xs:complexType>
	<!-- ==================================================================== -->
	<!-- *** SCHEDULE-EVT for Physical Agent Rules *** -->
	<!-- ==================================================================== -->
	<xs:complexType name="AgtRuleResEvtExpr.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:CreateDescription"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:ActionEventExpr"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:OutMessageEventExpr"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:ReminderEventExpr"/>
		</xs:sequence>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ActionEventExpr">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Condition"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Delay"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="actionEventType" type="ers:CanonicalName"
				use="required"/>
			<xs:attribute default="0" form="unqualified" name="delay" type="xs:nonNegativeInteger"
				use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="OutMessageEventExpr">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Condition"/>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ReceiverIdRef"
					type="ers:OpaqueExpression"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Delay"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="messageType" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="receiverIdRefs" type="ers:ListOfLong" use="optional"/>
			<xs:attribute default="0" form="unqualified" name="delay" type="xs:nonNegativeInteger"
				use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ReminderEventExpr">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ReminderMsg"
					type="ers:OpaqueExpression"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Condition"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Delay"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="reminderMsg" type="xs:string" use="optional"/>
			<xs:attribute default="0" form="unqualified" name="delay" type="xs:nonNegativeInteger"
				use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ============================================================== -->
	<xs:element name="UPDATE-AGT" type="aors:UpdateSubjectiveStateExpr.type"/>
	<!-- ============================================================== -->
	<xs:complexType name="UpdateSubjectiveStateExpr.type">
		<xs:choice maxOccurs="unbounded" minOccurs="0">
			<xs:element ref="ers:Slot"/>
			<xs:element ref="ers:MultiValuedSlot"/>
			<xs:element ref="ers:Call"/>
			<xs:element ref="aors:UpdateComplexDataPropertyValue"/>
			<xs:element ref="aors:SelfBeliefSlot"/>
			<xs:element ref="aors:CreateBeliefEntity"/>
			<xs:element ref="aors:UpdateBeliefEntity"/>
			<xs:element ref="aors:DestroyBeliefEntity"/>
		</xs:choice>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateComplexDataPropertyValue">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Argument">
					<xs:complexType>
						<xs:sequence>
							<xs:element maxOccurs="unbounded" minOccurs="1" ref="ers:ValueExpr"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute form="unqualified" name="complexDataProperty" type="ers:CanonicalName"
				use="required"/>
			<xs:attribute form="unqualified" name="procedure" type="ers:CanonicalName" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="CreateBeliefEntity">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>Creates a new belief entity. When no ID is specified for this belief entity,
				an auto-generated one is assigned.     This ID is unique and it is contained into the most
				negative quarter or the most positive quarter of the primitive long type values range
				interval.     It is also checked if a belief with that ID already exists, so this ranges may
				also be used, but considering the limitation that no other     belief entity with this ID
				was added before in the beliefs storage of the agent (which applies for the whole range of
				IDs).     If try to create a belief entity with an ID and another belief entity with that ID
				is found in the agent beliefs storage,     then no action is performed (the belief entity is
				not created).     </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="BeliefEntityIdRef"
					type="ers:OpaqueExpression"/>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="BeliefEntityType"
					type="ers:OpaqueExpression"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:BeliefSlot"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="beliefEntityType" type="ers:CanonicalName"
				use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UpdateBeliefEntity">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="BeliefEntityIdRef"
					type="ers:OpaqueExpression"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:BeliefSlot"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Increment"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Decrement"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="beliefEntityType" type="ers:CanonicalName"
				use="required"/>
			<xs:attribute form="unqualified" name="beliefEntityIdRef" type="xs:long" use="optional"/>
			<xs:attribute form="unqualified" name="beliefEntityVariable" type="ers:CanonicalName"
				use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="DestroyBeliefEntity">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="BeliefEntityIdRef"
					type="ers:OpaqueExpression"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="beliefEntityIdRef" type="xs:long" use="optional"/>
			<xs:attribute form="unqualified" name="beliefEntityVariable" type="ers:CanonicalName"
				use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="BeliefEntityRef">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:simpleContent>
				<xs:extension base="ers:OpaqueExpression">
					<xs:attribute form="unqualified" name="beliefEntityType" type="ers:CanonicalName"
						use="required"/>
				</xs:extension>
			</xs:simpleContent>
		</xs:complexType>
	</xs:element>
	<!-- ==================================================================== -->
	<!-- *** ActualPerceptionRule *** -->
	<!-- ==================================================================== -->
	<xs:element name="ActualPerceptionRule">
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:documentation"/>
				<xs:element form="qualified" name="WHEN" type="aors:TriggeringPerceptionEventExpr.type"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:IF"/>
				<xs:element form="qualified" name="CREATE-EVT" type="aors:ResultingActualPercEvtExpr.type"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
			<xs:attribute form="unqualified" name="agentVariable" type="ers:CanonicalName" use="optional"
			/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="TriggeringPerceptionEventExpr.type">
		<xs:attribute form="unqualified" name="perceptionEventType" type="ers:CanonicalName"
			use="optional"/>
		<xs:attribute form="unqualified" name="eventVariable" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="messageType" type="ers:CanonicalName" use="optional"/>
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="ResultingActualPercEvtExpr.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="SenderIdRef"
				type="ers:OpaqueExpression"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="actualPercEvtType" type="ers:CanonicalName"/>
		<xs:attribute form="unqualified" name="messageType" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="senderIdRef" type="xs:long" use="optional"/>
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	</xs:complexType>
	<xs:element name="ELSE-IF" type="ers:Condition.type"/>
	<!-- ==================================================================== -->
	<xs:element abstract="true" name="AbstractActionRule" type="aors:AbstractActionRule.type"/>
	<!-- ==================================================================== -->
	<xs:complexType abstract="true" name="AbstractActionRule.type">
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:documentation"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="agentVariable" type="aors:CanonicalName" use="optional"/>
		<xs:attribute default="none" form="unqualified" name="inheritanceMethod">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="none"/>
					<xs:enumeration value="disjunctive"/>
					<xs:enumeration value="conjunctive"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute default="focusOnEventType" form="unqualified" name="inheritanceStrategy">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="focusOnAgentType"/>
					<xs:enumeration value="focusOnEventType"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<!-- ==================================================================== -->
	<xs:element name="ActionRule" substitutionGroup="aors:AbstractActionRule">
		<!-- ==================================================================== -->
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="aors:AbstractActionRule.type">
					<xs:sequence>
						<xs:element form="qualified" minOccurs="0" name="DO" type="aors:ActionRuleDO.type"/>
						<xs:sequence minOccurs="0">
							<xs:element maxOccurs="unbounded" ref="ers:IF"/>
							<xs:element form="qualified" name="THEN" type="aors:ActionRuleDO.type"/>
							<xs:sequence maxOccurs="unbounded" minOccurs="0">
								<xs:element maxOccurs="unbounded" ref="ers:ELSE-IF"/>
								<xs:element form="qualified" name="THEN" type="aors:ActionRuleDO.type"/>
							</xs:sequence>
							<xs:element form="qualified" minOccurs="0" name="ELSE" type="aors:ActionRuleDO.type"/>
						</xs:sequence>
					</xs:sequence>
					<xs:attribute form="unqualified" name="actionEventType" type="ers:CanonicalName"
						use="required"/>
					<xs:attribute form="unqualified" name="eventVariable" type="ers:CanonicalName"
						use="optional"/>
					<!--xs:assert test="@agentVariable != @eventVariable"/-->
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="ActionRuleDO.type">
		<xs:choice maxOccurs="unbounded" minOccurs="0">
			<xs:element ref="aors:UPDATE-AGT"/>
			<xs:element ref="aors:UPDATE-EVT"/>
		</xs:choice>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UPDATE-EVT">
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="1" ref="aors:Slot"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- ==================================================================== -->
	<xs:element name="OutMessageActionRule" substitutionGroup="aors:AbstractActionRule">
		<!-- ==================================================================== -->
		<xs:complexType>
			<xs:complexContent>
				<xs:extension base="aors:AbstractActionRule.type">
					<xs:sequence>
						<xs:element form="qualified" minOccurs="0" name="DO"
							type="aors:OutMessageActionRuleDO.type"/>
						<xs:sequence minOccurs="0">
							<xs:element maxOccurs="unbounded" ref="ers:IF"/>
							<xs:element form="qualified" name="THEN" type="aors:OutMessageActionRuleDO.type"/>
							<xs:sequence maxOccurs="unbounded" minOccurs="0">
								<xs:element maxOccurs="unbounded" ref="ers:ELSE-IF"/>
								<xs:element form="qualified" name="THEN" type="aors:OutMessageActionRuleDO.type"/>
							</xs:sequence>
							<xs:element form="qualified" minOccurs="0" name="ELSE"
								type="aors:OutMessageActionRuleDO.type"/>
						</xs:sequence>
					</xs:sequence>
					<xs:attribute form="unqualified" name="messageType" type="ers:CanonicalName"
						use="required"/>
					<xs:attribute form="unqualified" name="messageVariable" type="ers:CanonicalName"
						use="optional"/>
					<!--xs:assert test="@messageVariable != @agentVariable"/-->
				</xs:extension>
			</xs:complexContent>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="OutMessageActionRuleDO.type">
		<xs:choice maxOccurs="unbounded" minOccurs="0">
			<xs:element ref="aors:UPDATE-AGT"/>
			<xs:element ref="aors:UPDATE-MSG"/>
		</xs:choice>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="UPDATE-MSG">
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="1" ref="aors:Slot"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- ==================================================================== -->
	<xs:attributeGroup name="ActionRulesUsage.attributes">
		<!-- ==================================================================== -->
		<xs:attribute default="false" form="unqualified" name="useActionRules" type="xs:boolean"/>
		<xs:attributeGroup ref="aors:ActionRuleEvaluation.attributes"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="ActionRuleEvaluation.attributes">
		<xs:attribute default="until-1st-fail" form="unqualified" name="actionRuleEvaluation">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="all-or-nothing"/>
					<xs:enumeration value="until-1st-fail"/>
					<xs:enumeration value="as-much-as-possible"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<!-- *** AgentType *** -->
	<!-- =================================================================== -->
	<xs:element name="AgentType" substitutionGroup="ers:ObjectType" type="aors:AgentType.type">
		<xs:unique name="UniqueOutMessageActionRule">
			<xs:selector xpath="aors:OutMessageActionRule"/>
			<xs:field xpath="@messageType"/>
		</xs:unique>
		<xs:key name="AgentType-PropertyKey">
			<xs:selector xpath="aors:Attribute | aors:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="AgentType.type">
		<xs:complexContent>
			<xs:extension base="ers:ObjectType.type">
				<xs:sequence>
					<xs:group ref="aors:AgentType.elements"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:ReactionRule">
						<xs:annotation>
							<xs:documentation>For definiing a reactive behavior in response to an event of a
								certain type. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:OutMessageActionRule"/>
				</xs:sequence>
				<xs:attributeGroup ref="aors:AgentType.attributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:attributeGroup name="AgentType.attributes">
		<xs:attribute default="0" form="unqualified" name="memorySize" type="xs:integer" use="optional"/>
		<xs:attribute default="FIXED_VOCABULARY" form="unqualified" name="beliefRepresentationStyle"
			use="optional">
			<xs:annotation>
				<xs:documentation>NOT YET IMPLEMENTED!</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="FIXED_VOCABULARY">
						<xs:annotation>
							<xs:documentation>Beliefs are expressed with a fixed vocabulary defined at design
								time.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="OPEN_VOCABULARY">
						<xs:annotation>
							<xs:documentation>Beliefs can be expressed with arbitrary names (so the vocabulary is
								open).</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:group name="AgentType.elements">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:SelfBeliefProperty"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:BeliefEntityType"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="SubjectiveFunction"
				type="ers:Function.type"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:TimeEventType"/>
		</xs:sequence>
	</xs:group>
	<!-- =================================================================== -->
	<!-- *** PhysicalAgentType *** -->
	<!-- =================================================================== -->
	<xs:element name="PhysicalAgentType" substitutionGroup="ers:PhysicalObjectType"
		type="aors:PhysicalAgentType.type">
		<xs:unique name="UniqueActionRule">
			<xs:selector xpath="aors:ActionRule"/>
			<xs:field xpath="@actionEventType"/>
		</xs:unique>
		<xs:unique name="UniqueOutMessageActionRule2">
			<xs:selector xpath="aors:OutMessageActionRule"/>
			<xs:field xpath="@messageType"/>
		</xs:unique>
		<xs:key name="PhysicalAgentType-PropertyKey">
			<xs:selector xpath="aors:Attribute | aors:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="ActualPerceptionEventTypeKey">
			<xs:selector xpath="aors:ActualPerceptionEventType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="ActualPerceptionEventTypeReference" refer="aors:ActualPerceptionEventTypeKey">
			<xs:selector xpath="aors:ActualPerceptionRule/aors:CREATE-EVT"/>
			<xs:field xpath="@actualPercEvtType"/>
		</xs:keyref>
		<!--xs:keyref name="MessageTypeReference" refer="aors:ActualPerceptionEventTypeKey">
      <xs:selector xpath="aors:ActualPerceptionRule/aors:CREATE-EVT"/>
      <xs:field xpath="@messageType"/>
    </xs:keyref-->
	</xs:element>
	<xs:complexType name="PhysicalAgentType.type">
		<xs:complexContent>
			<xs:extension base="ers:PhysicalObjectType.type">
				<xs:sequence>
					<xs:group ref="aors:AgentType.elements"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:ActualPerceptionEventType">
						<xs:annotation>
							<xs:documentation>Only relevant for modeling cognitive agents and their perception
								capabilities. For such agents, the actual perception event may depart from the
								potential perception event due to imperfect perception capabilities. This kind of
								distortion of a potential perception event of type ET can be modeled by defining a
								corresponding actual perception event type ET' with possibly different properties,
								and then mapping any potential perception event of type ET to a corresponding actual
								perception event of type ET' with the help of an actual perceptio rule.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:ActualPerceptionRule">
						<xs:annotation>
							<xs:documentation>Only relevant for modeling cognitive agents and their perception
								capabilities. For such agents, the actual perception event may depart from the
								potential perception event due to imperfect perception capabilities. This kind of
								distortion of a potential perception event of type ET can be modeled by defining a
								corresponding actual perception event type ET' with possibly different properties,
								and then mapping any potential perception event of type ET to a corresponding actual
								perception event of type ET' with the help of an actual perceptio rule.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:ReactionRule">
						<xs:annotation>
							<xs:documentation>For definiing a reactive behavior in response to an event of a
								certain type. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:AbstractActionRule"/>
				</xs:sequence>
				<xs:attribute default="false" form="unqualified" name="autoPerception" type="xs:boolean"
					use="optional"/>
				<xs:attributeGroup ref="aors:AgentType.attributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** SelfBeliefProperty *** -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="SelfBeliefProperty" type="ers:Property.type"/>
	<xs:element name="SelfBeliefAttribute" substitutionGroup="aors:SelfBeliefProperty"
		type="ers:Attribute.type"/>
	<xs:element name="SelfBeliefReferenceProperty" substitutionGroup="aors:SelfBeliefProperty"
		type="ers:ReferenceProperty.type"/>
	<!-- =================================================================== -->
	<!-- *** SubjectiveFunction *** -->
	<!-- =================================================================== -->
	<xs:element name="SubjectiveFunction" type="ers:Function.type"/>
	<!-- =================================================================== -->
	<!-- *** BeliefEntityType *** -->
	<!-- =================================================================== -->
	<xs:element name="BeliefEntityType" type="aors:BeliefEntityType.type"/>
	<xs:complexType name="BeliefEntityType.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:BeliefProperty"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="name" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="superType" type="ers:CanonicalName" use="optional"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** BeliefProperty ** -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="BeliefProperty" type="ers:Property.type"/>
	<xs:element name="BeliefAttribute" substitutionGroup="aors:BeliefProperty"
		type="ers:Attribute.type"/>
	<xs:element name="BeliefReferenceProperty" substitutionGroup="aors:BeliefProperty"
		type="ers:ReferenceProperty.type"/>
	<!-- =================================================================== -->
	<!-- *** MessageType *** -->
	<!-- =================================================================== -->
	<xs:element name="MessageType" substitutionGroup="ers:EntityType" type="aors:MessageType.type">
		<xs:key name="MessageType-PropertyKey">
			<xs:selector xpath="aors:Attribute | aors:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="MessageType.type">
		<xs:complexContent>
			<xs:extension base="ers:EntityType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** Environment Event Types *** -->
	<!-- =================================================================== -->
	<!-- *** PerceptionEventType *** -->
	<xs:element name="PerceptionEventType" substitutionGroup="ers:CausedEventType"
		type="aors:PerceptionEventType.type">
		<xs:key name="PerceptionEventType-PropertyKey">
			<xs:selector xpath="aors:Attribute | aors:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="PerceptionEventType.type">
		<xs:complexContent>
			<xs:extension base="ers:CausedEventType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- *** ActionEventType *** -->
	<xs:element name="ActionEventType" substitutionGroup="ers:EnvironmentEventType"
		type="aors:ActionEventType.type">
		<xs:key name="ActionEventType-PropertyKey">
			<xs:selector xpath="aors:Attribute | aors:ReferenceProperty"/>
			<xs:field xpath="@name"/>
		</xs:key>
	</xs:element>
	<xs:complexType name="ActionEventType.type">
		<xs:complexContent>
			<xs:extension base="ers:EnvironmentEventType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** Internal Event Types *** -->
	<!-- =================================================================== -->
	<xs:element abstract="true" name="InternalEventType" substitutionGroup="ers:EventType"
		type="aors:InternalEventType.type"/>
	<xs:complexType name="InternalEventType.type">
		<xs:complexContent>
			<xs:extension base="ers:EventType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- *** ActualPerceptionEventType *** -->
	<xs:element name="ActualPerceptionEventType" substitutionGroup="aors:InternalEventType"
		type="aors:ActualPerceptionEventType.type"/>
	<xs:complexType name="ActualPerceptionEventType.type">
		<xs:complexContent>
			<xs:extension base="aors:InternalEventType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- *** TimeEventType *** -->
	<xs:element name="TimeEventType" substitutionGroup="aors:InternalEventType"
		type="aors:TimeEventType.type"/>
	<xs:complexType name="TimeEventType.type">
		<xs:complexContent>
			<xs:extension base="aors:InternalEventType.type"/>
		</xs:complexContent>
	</xs:complexType>
	<!-- *** PeriodicTimeEventType *** -->
	<xs:element name="PeriodicTimeEventType" substitutionGroup="aors:TimeEventType"
		type="aors:PeriodicTimeEventType.type"/>
	<xs:complexType name="PeriodicTimeEventType.type">
		<xs:complexContent>
			<xs:extension base="aors:TimeEventType.type">
				<xs:sequence>
					<xs:element minOccurs="0" ref="ers:Periodicity"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:StopCondition"/>
				</xs:sequence>
				<xs:attribute form="unqualified" name="periodicity" type="xs:positiveInteger" use="optional"
				/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** Activity Types *** -->
	<!-- =================================================================== -->
	<xs:element name="ActivityType" substitutionGroup="ers:EventType" type="ers:ActivityType.type"/>
	<xs:complexType name="ActivityType.type">
		<xs:complexContent>
			<xs:extension base="ers:EventType.type">
				<xs:sequence>
					<xs:choice maxOccurs="unbounded" minOccurs="0">
						<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="FOR">
							<xs:complexType>
								<xs:complexContent>
									<xs:restriction base="ers:VariableDeclaration.type">
										<xs:annotation>
											<xs:documentation>We use here a restricted version of
												VariableDeclaration.type, because we don't use sets</xs:documentation>
										</xs:annotation>
										<xs:choice minOccurs="0">
											<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ValueExpr"/>
											<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
												name="ObjectRef" type="ers:OpaqueExpression"/>
											<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
												name="ObjectIdRef" type="ers:OpaqueExpression"/>
										</xs:choice>
										<xs:attribute form="unqualified" name="dataVariable" type="ers:CanonicalName"
											use="optional"/>
										<xs:attribute form="unqualified" name="dataType" type="ers:PrimitiveDataType"
											use="optional"/>
										<xs:attribute form="unqualified" name="refDataType" type="ers:CanonicalName"
											use="optional"/>
										<xs:attribute form="unqualified" name="objectVariable" type="ers:CanonicalName"
											use="optional"/>
										<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName"
											use="optional"/>
										<xs:attribute form="unqualified" name="objectIdRef" type="xs:long"
											use="optional"/>
										<xs:attribute form="unqualified" name="objectName" type="xs:NCName"
											use="optional"/>
									</xs:restriction>
								</xs:complexContent>
							</xs:complexType>
						</xs:element>
					</xs:choice>
					<xs:element form="qualified" maxOccurs="1" minOccurs="0" name="Duration"
						type="ers:DiscreteRandomVariable-OR-ValueExpr"/>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ActorIdRef"
						type="ers:OpaqueExpression"/>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ActorRef"
						type="ers:OpaqueExpression"/>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ResourceIdRef"
						type="ers:ResourceReferenceType"/>
					<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="ResourceRef"
						type="ers:ResourceReferenceType"/>
					<xs:element form="qualified" minOccurs="0" name="ActivityStartEffect"
						type="ers:ActivityEffect.type"/>
					<xs:element form="qualified" minOccurs="0" name="ActivityEndEffect"
						type="ers:ActivityEffect.type"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:SuccessorActivityType"/>
				</xs:sequence>
				<xs:attribute form="unqualified" name="duration" type="xs:long" use="optional"/>
				<xs:attribute form="unqualified" name="startEventType" type="ers:CanonicalName"
					use="optional"/>
				<xs:attribute form="unqualified" name="startEventVariable" type="ers:CanonicalName"
					use="optional"/>
				<xs:attribute form="unqualified" name="startEventCorrelationProperty"
					type="ers:CanonicalName" use="optional"/>
				<xs:attribute form="unqualified" name="endEventType" type="ers:ListOfCanonicalName"
					use="optional"/>
				<xs:attribute form="unqualified" name="endEventVariable" type="ers:CanonicalName"
					use="optional"/>
				<xs:attribute form="unqualified" name="endEventCorrelationProperty" type="ers:CanonicalName"
					use="optional"/>
				<xs:attribute form="unqualified" name="actorIdRef" type="xs:long" use="optional"/>
				<xs:attribute form="unqualified" name="actorVariable" type="ers:CanonicalName"
					use="optional"/>
				<xs:attribute form="unqualified" name="actorType" type="ers:CanonicalName" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ActorReferenceType">
		<xs:simpleContent>
			<xs:extension base="ers:OpaqueExpression">
				<xs:attribute form="unqualified" name="actorVariable" type="ers:CanonicalName"
					use="optional"/>
				<xs:attribute form="unqualified" name="type" type="ers:CanonicalName" use="optional"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:complexType name="ResourceReferenceType">
		<xs:simpleContent>
			<xs:extension base="ers:OpaqueExpression">
				<xs:attribute form="unqualified" name="resourceVariable" type="ers:CanonicalName"
					use="optional"/>
				<xs:attribute form="unqualified" name="type" type="ers:CanonicalName" use="optional"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!-- ==================================== -->
	<!-- *** ActivityEffect.type *** -->
	<!-- ==================================== -->
	<xs:complexType name="ActivityEffect.type">
		<xs:sequence>
			<xs:choice maxOccurs="unbounded" minOccurs="0">
				<xs:element ref="ers:UpdateGlobalVariable"/>
				<xs:element ref="ers:IncrementGlobalVariable"/>
				<xs:element ref="ers:UpdateObject"/>
				<xs:element ref="ers:UpdateGridCell"/>
				<xs:element ref="ers:UpdateStatisticsVariable"/>
				<xs:element ref="ers:UpdateActor"/>
			</xs:choice>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:UpdateObjects"/>
		</xs:sequence>
	</xs:complexType>
	<!-- ==================================== -->
	<!-- *** SuccessorActivity *** -->
	<!-- ==================================== -->
	<xs:element name="SuccessorActivityType" type="ers:SuccessorActivityType.type"/>
	<xs:complexType name="SuccessorActivityType.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Delay"
				type="ers:OpaqueExpression"/>
			<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="CorrelationValue"
				type="ers:OpaqueExpression"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="activityName" type="ers:CanonicalName" use="required"/>
		<xs:attribute form="unqualified" name="delay" type="xs:positiveInteger" use="optional"/>
	</xs:complexType>
	<!-- ==================================== -->
	<!-- *** UpdateActorObject *** -->
	<!-- ==================================== -->
	<xs:element name="UpdateActor" type="ers:UpdateActor.type">
		<xs:annotation>
			<xs:documentation>A possibilitie to change the actorObject (as a simplification to
				UpdateObject)</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="UpdateActor.type">
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Increment"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Decrement"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Slot"/>
		</xs:sequence>
		<xs:attribute form="unqualified" name="actorType" type="xs:NCName" use="required"/>
		<xs:attribute form="unqualified" name="actorVariable" type="ers:CanonicalName" use="optional"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="SpaceView" type="ers:SpaceView.type">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>
				<h:p>A space view allows to define in which way the space model will be visualized. If no
					space view is defined, the default visualization applies. By default, the entire display
					area will be used. The space parameters <h:code>xMax</h:code> and <h:code>yMax</h:code>
					(representing spatial distance units such as mm or m) are mapped to the space view
					parameters displayWidth and displayHeight (representing screen pixels). For physical
					objects in a non-discrete space, the resulting scale factors scaleX =
						displayWidth/<h:code>xMax</h:code> and scaleY = displayHeight/<h:code>yMax</h:code> are
					applied to the position coordinates <h:code>x</h:code> and <h:code>y</h:code> (of the
					object's center), as well as to the physical extension parameters <h:code>width</h:code>
					and <h:code>height</h:code>.</h:p>
				<h:p>In the case of a discrete space model, object view shapes are positioned by placing
					them somewhere in the cell corresponding to the object's coordinates. The physical size
					and shape of an object are not significant, since these space models abtsracts away from
					them.</h:p>
				<h:p>For more information about the concepts of color and opacity, and the related
					attributes <h:code>stroke</h:code>, <h:code>fill</h:code>, <h:code>opacity</h:code> and
						<h:code>fill-opacity</h:code>, see also the <h:a
						href="http://www.w3.org/TR/SVGTiny12/painting.html#ColorProperty">SVG
						specification</h:a>. </h:p>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="SpaceView.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:choice>
			<xs:sequence>
				<xs:element form="qualified" minOccurs="0" name="OneDimensionalSpaceView2D"
					type="ers:OneDimensionalSpaceView2D.type">
					<xs:annotation>
						<xs:documentation>A 2D visualization of a 1D space, which can be visualized in 3 ways:
							as a horizontal, vertical or circular track, using a birds-eye view.
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element form="qualified" minOccurs="0" name="OneDimensionalSpaceView3D"
					type="ers:OneDimensionalSpaceView3D.type">
					<xs:annotation>
						<xs:documentation>A 3D visualization of a 1D space, which can be visualized in 3 ways:
							as a horizontal, vertical or circular track, using a birds-eye view.
						</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:sequence>
				<xs:element form="qualified" minOccurs="0" name="TwoDimensionalSpaceView2D"
					type="ers:TwoDimensionalSpaceView2D.type">
					<xs:annotation>
						<xs:documentation>A 2D visualization of a 2D space. </xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element form="qualified" minOccurs="0" name="TwoDimensionalSpaceView3D"
					type="ers:TwoDimensionalSpaceView3D.type">
					<xs:annotation>
						<xs:documentation>A 3D visualization of a 2D space. </xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:sequence>
				<xs:element form="qualified" minOccurs="0" name="TwoDimensionalGridSpaceView2D"
					type="ers:TwoDimensionalGridSpaceView2D.type">
					<xs:annotation>
						<xs:documentation>A 2D visualization of a 2D grid space, which allows to define grid
							cell property maps for visualizing grid cell properties (by mapping them to one of the
							cell view properties <h:code>fill</h:code> and <h:code>fill-opacity</h:code>).
						</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element form="qualified" minOccurs="0" name="TwoDimensionalGridSpaceView3D"
					type="ers:TwoDimensionalGridSpaceView3D.type">
					<xs:annotation>
						<xs:documentation>A 3D visualization of a 2D grid space, which allows to define grid
							cell property maps for visualizing grid cell properties (by mapping them to one of the
							cell view properties <h:code>fill</h:code> and <h:code>fill-opacity</h:code>).
						</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
		</xs:choice>
		<xs:attribute form="unqualified" name="canvasColor" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the fill color of the canvas with a color name.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="canvasColorRGB" type="ers:RGB.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the fill color of the canvas with an RGB triple.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="canvasWidth" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the width of the canvas (in pixels). Will be scaled, if it exceeds
					the screen size. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="canvasHeight" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the height of the canvas (in pixels). Will be scaled, if it
					exceeds the screen size. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="OneDimensionalSpaceView2D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="mode" type="ers:OneDimensionalMode.type" use="required">
			<xs:annotation>
				<xs:documentation>A 1D space can be visualized in 3 ways: as a horizontal, vertical or
					circular track, using a birds-eye view. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="trackWidth" type="ers:Pixel-OR-Percent.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>Defines the width of the track(s). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="trackColor" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the track(s). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="trackColorRGB" type="ers:RGB.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the track(s). </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="OneDimensionalMode.type">
		<xs:restriction base="xs:string">
			<xs:enumeration value="horizontal"/>
			<xs:enumeration value="vertical"/>
			<xs:enumeration value="circular"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="OneDimensionalSpaceView3D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexContent>
			<xs:extension base="ers:OneDimensionalSpaceView2D.type">
				<xs:sequence>
					<xs:element minOccurs="0" ref="ers:Skybox"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="TwoDimensionalSpaceView2D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:SpaceViewPropertyVisualizationMap"/>
			<xs:element form="qualified" minOccurs="0" name="OverlayGrid">
				<xs:complexType>
					<xs:attribute form="unqualified" name="numberOfGridCellsX" use="required">
						<xs:annotation>
							<xs:documentation xml:lang="en">The number of grid cells in X direction.
							</xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:integer">
								<xs:minInclusive value="2"/>
								<xs:maxInclusive value="150"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="numberOfGridCellsY" use="required">
						<xs:annotation>
							<xs:documentation xml:lang="en">The number of grid cells in X direction.
							</xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:integer">
								<xs:minInclusive value="2"/>
								<xs:maxInclusive value="100"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="gridOriginX" use="optional">
						<xs:annotation>
							<xs:documentation xml:lang="en">The horizontal pixel number of the left lower corner
								of the grid. </xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:integer">
								<xs:minInclusive value="0"/>
								<xs:maxInclusive value="1500"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="gridOriginY" use="optional">
						<xs:annotation>
							<xs:documentation xml:lang="en">The vertical pixel number of the left lower corner of
								the grid. </xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:integer">
								<xs:minInclusive value="0"/>
								<xs:maxInclusive value="1000"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="gridCellWidth" type="ers:GridCellSize.type"
						use="optional">
						<xs:annotation>
							<xs:documentation xml:lang="en">The width of a grid cell in pixels.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute form="unqualified" name="gridCellHeight" type="ers:GridCellSize.type"
						use="optional">
						<xs:annotation>
							<xs:documentation xml:lang="en">The height of a grid cell in pixels.
							</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attributeGroup ref="ers:GridStroke.attributes"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="ers:SpaceViewBackground.attributes"/>
		<xs:attributeGroup ref="ers:SpaceViewBorder.attributes"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="GridCellSize.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:integer">
			<xs:minInclusive value="10"/>
			<xs:maxInclusive value="200"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="TwoDimensionalSpaceView3D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:Skybox"/>
			<xs:choice minOccurs="0">
				<xs:element ref="ers:GlobalCamera"/>
				<xs:element ref="ers:AgentCamera"/>
			</xs:choice>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:SpaceViewPropertyVisualizationMap"/>
		</xs:sequence>
		<xs:attributeGroup ref="ers:SpaceViewBackground.attributes"/>
		<xs:attributeGroup ref="ers:SpaceViewBorder.attributes"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="ThreeDimensionalSpaceView.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element minOccurs="0" ref="ers:Skybox"/>
			<xs:choice minOccurs="0">
				<xs:element ref="ers:GlobalCamera"/>
				<xs:element ref="ers:AgentCamera"/>
			</xs:choice>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:SpaceViewPropertyVisualizationMap"/>
		</xs:sequence>
		<xs:attributeGroup ref="ers:SpaceViewBackground.attributes"/>
		<xs:attributeGroup ref="ers:SpaceViewBorder.attributes"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="GlobalCamera">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="position" type="ers:DoubleTriple.type" use="required"/>
			<xs:attribute form="unqualified" name="viewVector" type="ers:DoubleTriple.type" use="required"/>
			<xs:attribute form="unqualified" name="upVector" type="ers:DoubleTriple.type" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="AgentCamera">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="agentIdRef" type="xs:long" use="required"/>
			<xs:attribute form="unqualified" name="viewType" use="required">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="FIRST_PERSON"/>
						<xs:enumeration value="THIRD_PERSON"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attribute form="unqualified" name="defaultViewVector" type="ers:DoubleTriple.type"
				use="required"/>
			<xs:attribute form="unqualified" name="upVector" type="ers:DoubleTriple.type" use="required"/>
			<xs:attribute form="unqualified" name="cameraOrientationMode" use="required">
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="FIXED"/>
						<xs:enumeration value="BODY_ROTATION"/>
						<xs:enumeration value="MOVING_DIRECTION"/>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="TwoDimensionalGridSpaceView2D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="4" minOccurs="0"
				name="GridCellPropertyVisualizationMap">
				<xs:annotation>
					<xs:documentation>A function that maps an object property to a grid cell view property for
						visualizing it. The <h:code>mapType</h:code> attribute allows to specify the type of
						function: polynomial, casewise constant, equality-casewise or enumeration. A polynomial
						function has the form y = a<h:sub>3</h:sub>x<h:sup>3</h:sup> +
							a<h:sub>2</h:sub>x<h:sup>2</h:sup> + a<h:sub>1</h:sub>x + a<h:sub>0</h:sub>, where x
						is the object property and y is the grid cell view property. The casewise constant
						function is defined by y = v<h:sub>0</h:sub> if x &lt; a<h:sub>0</h:sub>, y =
							v<h:sub>1</h:sub> if a<h:sub>0</h:sub> &lt;= x &lt; a<h:sub>1</h:sub>, etc. A map may be
						defined by equality cases as y = v<h:sub>0</h:sub> if  x = a<h:sub>0</h:sub>, y =
							v<h:sub>1</h:sub> if x = a<h:sub>1</h:sub>, etc. Finally, a map may be defined on an
						enumeration property by equality cases as y = v<h:sub>0</h:sub> if  x = enumLit(1), y =
							v<h:sub>1</h:sub> if x = enumLit(2), etc. </xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:attribute form="unqualified" name="cellViewProperty" type="ers:CellViewProperty.type"
						use="required"/>
					<xs:attributeGroup ref="ers:Map.attrgrp"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="fill1" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">The cells of a grid can be colored like a chess board (with
					colors <h:code>fill1</h:code> and <h:code>fill2</h:code>).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="fill1RGB" type="ers:RGB.type" use="optional"/>
		<xs:attribute form="unqualified" name="fill2" type="ers:Color.type" use="optional"/>
		<xs:attribute form="unqualified" name="fill2RGB" type="ers:RGB.type" use="optional"/>
		<!-- 
		<xs:attribute name="fillOpacity" type="ers:Probability" use="optional"/>
-->
		<xs:attributeGroup ref="ers:SpaceViewBackground.attributes"/>
		<xs:attributeGroup ref="ers:GridStroke.attributes"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="CellViewProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:NCName">
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<!-- 
				<xs:enumeration value="fillOpacity"/>
-->
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="TwoDimensionalGridSpaceView3D.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexContent>
			<xs:extension base="ers:TwoDimensionalGridSpaceView2D.type">
				<xs:sequence>
					<xs:element minOccurs="0" ref="ers:Skybox"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="SpaceViewPropertyVisualizationMap">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>A function that maps a global variable or an object property to a space view
				property for visualizing it. The <h:code>mapType</h:code> attribute allows to specify the
				type of function: polynomial, casewise constant, equality-casewise or enumeration. A
				polynomial function has the form y = a<h:sub>3</h:sub>x<h:sup>3</h:sup> +
					a<h:sub>2</h:sub>x<h:sup>2</h:sup> + a<h:sub>1</h:sub>x + a<h:sub>0</h:sub>, where x is
				the object property and y is the grid cell view property. The casewise constant function is
				defined by y = v<h:sub>0</h:sub> if x &lt; a<h:sub>0</h:sub>, y = v<h:sub>1</h:sub> if
					a<h:sub>0</h:sub> &lt;= x &lt; a<h:sub>1</h:sub>, etc. A map may be defined by equality cases as y
				= v<h:sub>0</h:sub> if  x = a<h:sub>0</h:sub>, y = v<h:sub>1</h:sub> if x =
					a<h:sub>1</h:sub>, etc. Finally, a map may be defined on an enumeration property by
				equality cases as y = v<h:sub>0</h:sub> if  x = enumLit(1), y = v<h:sub>1</h:sub> if x =
				enumLit(2), etc. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute form="unqualified" name="spaceViewProperty" type="ers:SpaceViewProperty.type"
				use="required"/>
			<xs:attribute form="unqualified" name="globalVariable" type="ers:CanonicalName" use="required"/>
			<xs:attributeGroup ref="ers:MapParameters.attrgrp"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="SpaceViewProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:NCName">
			<xs:enumeration value="backgroundColor"/>
			<xs:enumeration value="backgroundImage"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Skybox">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="top" type="xs:anyURI" use="optional"/>
			<xs:attribute form="unqualified" name="bottom" type="xs:anyURI" use="optional"/>
			<xs:attribute form="unqualified" name="left" type="xs:anyURI" use="optional"/>
			<xs:attribute form="unqualified" name="right" type="xs:anyURI" use="optional"/>
			<xs:attribute form="unqualified" name="front" type="xs:anyURI" use="optional"/>
			<xs:attribute form="unqualified" name="back" type="xs:anyURI" use="optional"/>
			<!--			<xs:attribute name="cubicTexture" type="xs:anyURI" use="optional"/>
-->
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="SpaceViewBackground.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="backgroundColor" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the background color of the space view area with a color name.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="backgroundColorRGB" type="ers:RGB.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the background color of the space view area with a Red-Green-Blue
					value triple. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="backgroundImage" type="xs:anyURI" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">Allows to load an image as the background of the space view
					area. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="SpaceViewBorder.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="borderColor" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the border line. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="borderColorRGB" type="ers:RGB.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the border line. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="GridStroke.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="stroke" type="ers:Color.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the grid lines with a color name. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="strokeRGB" type="ers:RGB.type" use="optional">
			<xs:annotation>
				<xs:documentation>Defines the color of the grid lines with a Red-Green-Blue value triple.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="strokeWidth" type="ers:Pixel-OR-Percent.type"
			use="optional">
			<xs:annotation>
				<xs:documentation>Defines the width of the grid stroke. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:attributeGroup name="Map.attrgrp">
		<!-- =================================================================== -->
		<xs:attribute form="unqualified" name="property" type="ers:CanonicalName" use="required"/>
		<xs:attributeGroup ref="ers:MapParameters.attrgrp"/>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="MapParameters.attrgrp">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="mapType" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="polynomial">
						<xs:annotation>
							<xs:documentation>A polynomial map with y = a<h:sub>3</h:sub>x<h:sup>3</h:sup> +
									a<h:sub>2</h:sub>x<h:sup>2</h:sup> + a<h:sub>1</h:sub>x + a<h:sub>0</h:sub>, where
								x is the physical object property and y is the shape property.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="caseWise">
						<xs:annotation>
							<xs:documentation>A casewise constant function with y = v<h:sub>0</h:sub> if  x &lt;
									a<h:sub>0</h:sub>, y = v<h:sub>1</h:sub> if  a<h:sub>0</h:sub> &lt;= x &lt;
									a<h:sub>1</h:sub>, etc.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="equalityCaseWise">
						<xs:annotation>
							<xs:documentation>A function defined by equality cases as y = v<h:sub>0</h:sub> if  x
								= a<h:sub>0</h:sub>, y = v<h:sub>1</h:sub> if x = a<h:sub>1</h:sub>,
								etc.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="enumerationMap">
						<xs:annotation>
							<xs:documentation>A function on an enumeration property defined by equality cases as y
								= v<h:sub>0</h:sub> if  x = enumLit(1), y = v<h:sub>1</h:sub> if x = enumLit(2),
								etc.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute form="unqualified" name="a0" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="a1" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="a2" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="a3" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="v0" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="v1" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="v2" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="v3" type="xs:string" use="optional"/>
		<xs:attribute form="unqualified" name="v4" type="xs:string" use="optional"/>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="ShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="z"/>
			<xs:enumeration value="width"/>
			<xs:enumeration value="height"/>
			<xs:enumeration value="depth"/>
			<xs:enumeration value="r"/>
			<xs:enumeration value="rx"/>
			<xs:enumeration value="ry"/>
			<xs:enumeration value="rotX"/>
			<xs:enumeration value="rotY"/>
			<xs:enumeration value="rotZ"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="stroke-width"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fill-opacity"/>
			<xs:enumeration value="url"/>
			<xs:enumeration value="textureFile"/>
			<xs:enumeration value="surface-color"/>
			<xs:enumeration value="text"/>
			<xs:enumeration value="points"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- =================================================================== -->
	<xs:element name="PhysicalObjectView" type="ers:PhysicalObjectView.type">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Defines a view for physical objects.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="PhysicalObjectView.type">
		<xs:sequence>
			<xs:choice maxOccurs="2" minOccurs="1">
				<xs:choice minOccurs="0">
					<xs:element ref="ers:PhysicalShape2D"/>
					<xs:element form="qualified" name="PhysicalShape2dVisualizationMap">
						<xs:annotation>
							<xs:documentation>Defines a "dynamic shape" that may change when the value of a
								specific object property changes. </xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element form="qualified" maxOccurs="unbounded" name="Case">
									<xs:complexType>
										<xs:sequence>
											<xs:element ref="ers:PhysicalShape2D"/>
										</xs:sequence>
										<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
									</xs:complexType>
								</xs:element>
							</xs:sequence>
							<xs:attribute form="unqualified" name="property" type="ers:CanonicalName"
								use="required"/>
						</xs:complexType>
					</xs:element>
				</xs:choice>
				<xs:element minOccurs="0" ref="ers:PhysicalShape3D"/>
			</xs:choice>
			<xs:group ref="ers:ViewAnnotation.elements"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:AttachedShape2D">
				<xs:annotation>
					<xs:documentation>Allows defining nested 2D shapes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:AttachedShape3D">
				<xs:annotation>
					<xs:documentation>Allows defining nested 3D shapes. Not yet
						implemented!</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="physicalObjectType" type="ers:CanonicalName"
			use="optional"/>
		<xs:attribute form="unqualified" name="physicalObjectIdRef" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="physicalObjectStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="physicalObjectEndID" type="xs:long" use="optional"/>
		<xs:attributeGroup ref="ers:ViewDisplay.attributes"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<xs:element name="ObjectView" type="ers:ObjectView.type">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Defines a view for non-physical objects.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="ObjectView.type">
		<xs:sequence>
			<xs:choice maxOccurs="2" minOccurs="1">
				<xs:choice minOccurs="0">
					<xs:element minOccurs="0" ref="ers:Shape2D"/>
					<xs:element form="qualified" minOccurs="0" name="Shape2dVisualizationMap">
						<xs:annotation>
							<xs:documentation>Defines a "dynamic shape" that may change when the value of a
								specific object property changes. </xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element form="qualified" maxOccurs="unbounded" name="Case">
									<xs:complexType>
										<xs:sequence>
											<xs:element ref="ers:Shape2D"/>
										</xs:sequence>
										<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
									</xs:complexType>
								</xs:element>
							</xs:sequence>
							<xs:attribute form="unqualified" name="property" type="ers:CanonicalName"
								use="required"/>
						</xs:complexType>
					</xs:element>
				</xs:choice>
				<xs:element minOccurs="0" ref="ers:Shape3D"/>
			</xs:choice>
			<xs:group ref="ers:ViewAnnotation.elements"/>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:AttachedShape2D">
				<xs:annotation>
					<xs:documentation>Allows defining nested 2D shapes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:AttachedShape3D">
				<xs:annotation>
					<xs:documentation>Allows defining nested 3D shapes. Not yet
						implemented!</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName" use="optional"/>
		<xs:attribute form="unqualified" name="objectIdRef" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="objectStartID" type="xs:long" use="optional"/>
		<xs:attribute form="unqualified" name="objectEndID" type="xs:long" use="optional"/>
		<xs:attributeGroup ref="ers:ViewDisplay.attributes"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="ViewAnnotation.elements">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element form="qualified" minOccurs="0" name="DisplayInfo">
				<xs:annotation>
					<xs:documentation>Allows to display either the value of an object property or a fixed
						piece of text content near the object.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="Content"
							type="ers:OpaqueExpression"/>
					</xs:sequence>
					<xs:attribute form="unqualified" name="property" type="ers:CanonicalName" use="optional"/>
					<xs:attribute form="unqualified" name="content" type="xs:string" use="optional"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="ViewDisplay.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="displayID" type="xs:boolean" use="optional"/>
		<xs:attribute form="unqualified" name="displayName" type="xs:boolean" use="optional"/>
		<!--
			<xs:attribute name="scale" type="ers:CanonicalName" use="optional"/>
			<xs:attribute name="scaleValue" type="xs:NCName" use="optional"/>
		-->
	</xs:attributeGroup>
	<!-- =================================================================== -->
	<xs:element name="AttachedShape2D">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Defines a (possibly dynamic) shape that is attached to a view or another
				attached shape. An attached shape is either a shape or a dynamic shape (i.e. a shape
				visualization map), and possibly has other attached shapes. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:choice>
					<xs:element minOccurs="0" ref="ers:Shape2D"/>
					<xs:element form="qualified" minOccurs="0" name="Shape2dVisualizationMap">
						<xs:annotation>
							<xs:documentation>Defines a "dynamic shape" that may change when the value of a
								specific object property changes. </xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element form="qualified" maxOccurs="unbounded" name="Case">
									<xs:complexType>
										<xs:sequence>
											<xs:element ref="ers:Shape2D"/>
										</xs:sequence>
										<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
									</xs:complexType>
								</xs:element>
							</xs:sequence>
							<xs:attribute form="unqualified" name="property" type="ers:CanonicalName"
								use="required"/>
						</xs:complexType>
					</xs:element>
				</xs:choice>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:AttachedShape2D">
					<xs:annotation>
						<xs:documentation>Allows defining nested shapes.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:attribute form="unqualified" name="offsetX" type="ers:Pixel-OR-Percent.type"
				use="required"/>
			<xs:attribute form="unqualified" name="offsetY" type="ers:Pixel-OR-Percent.type"
				use="required"/>
			<xs:attribute form="unqualified" name="label" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="AttachedShape3D">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Defines a (possibly dynamic) shape that is attached to the main shape of a
				view or to another attached shape. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:sequence>
				<xs:choice>
					<xs:element minOccurs="0" ref="ers:Shape3D"/>
					<xs:element form="qualified" minOccurs="0" name="Shape3dVisualizationMap">
						<xs:complexType>
							<xs:sequence>
								<xs:element form="qualified" maxOccurs="unbounded" name="Case">
									<xs:complexType>
										<xs:sequence>
											<xs:element ref="ers:Shape3D"/>
										</xs:sequence>
										<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
									</xs:complexType>
								</xs:element>
							</xs:sequence>
							<xs:attribute form="unqualified" name="property" type="ers:CanonicalName"
								use="required"/>
						</xs:complexType>
					</xs:element>
				</xs:choice>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:AttachedShape3D">
					<xs:annotation>
						<xs:documentation>Allows defining nested shapes.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:sequence>
			<xs:attribute form="unqualified" name="offsetX" type="ers:Pixel-OR-Percent.type"
				use="required"/>
			<xs:attribute form="unqualified" name="offsetY" type="ers:Pixel-OR-Percent.type"
				use="required"/>
			<xs:attribute form="unqualified" name="offsetZ" type="ers:Pixel-OR-Percent.type"
				use="required"/>
			<xs:attribute form="unqualified" name="label" type="xs:string"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="PhysicalShape2D">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice>
				<xs:element form="qualified" name="Square">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:SquareShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute default="CenterCenter" form="unqualified" name="positioning"
							use="optional">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="LeftBottom"/>
									<xs:enumeration value="LeftCenter"/>
									<xs:enumeration value="LeftTop"/>
									<xs:enumeration value="CenterTop"/>
									<xs:enumeration value="RightTop"/>
									<xs:enumeration value="RightCenter"/>
									<xs:enumeration value="RightBottom"/>
									<xs:enumeration value="CenterBottom"/>
									<xs:enumeration value="CenterCenter"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Rectangle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:RectangleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute default="CenterCenter" form="unqualified" name="positioning"
							use="optional">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="LeftBottom"/>
									<xs:enumeration value="LeftCenter"/>
									<xs:enumeration value="LeftTop"/>
									<xs:enumeration value="CenterTop"/>
									<xs:enumeration value="RightTop"/>
									<xs:enumeration value="RightCenter"/>
									<xs:enumeration value="RightBottom"/>
									<xs:enumeration value="CenterBottom"/>
									<xs:enumeration value="CenterCenter"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Triangle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:RectangleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Arc">
					<xs:annotation>
						<xs:documentation>        Defines a circle arc shape. Allows to draw pies like shapes.
							Notice that the space         coordinates (x,y) refers to the center of the circle to
							which this arc belongs to.        The arc is drawn counterclockwise.
						</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ArcShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="angle" type="xs:double" use="optional">
							<xs:annotation>
								<xs:documentation>          The opening angle of the arc shape in degrees.
									Default is 360 degrees, that means a full circle.         </xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="startAngle" type="xs:double" use="optional">
							<xs:annotation>
								<xs:documentation>          The angle (degrees) where the arc starts. Default is 0
									degrees.         </xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="endAngle" type="xs:double" use="optional">
							<xs:annotation>
								<xs:documentation>          The angle (degrees) where the arc shape ends. Default is
									360 degrees.           If set, then the value of @angle will be ignored while an
									automatic           computation will apply based on @startAngle and @endAngle
									values.         </xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Circle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:CircleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Ellipse">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:EllipseShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="RegularPolygon">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:RegularPolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="numberOfPoints" use="required">
							<xs:simpleType>
								<xs:restriction base="xs:integer">
									<xs:minInclusive value="3"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Polygon">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:PolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Polyline">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:PolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
			</xs:choice>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="Shape2D">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice>
				<xs:element form="qualified" name="Square">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:SquareShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute default="CenterCenter" form="unqualified" name="positioning"
							use="optional">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="LeftBottom"/>
									<xs:enumeration value="LeftCenter"/>
									<xs:enumeration value="LeftTop"/>
									<xs:enumeration value="CenterTop"/>
									<xs:enumeration value="RightTop"/>
									<xs:enumeration value="RightCenter"/>
									<xs:enumeration value="RightBottom"/>
									<xs:enumeration value="CenterBottom"/>
									<xs:enumeration value="CenterCenter"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Rectangle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:RectangleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="height"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute default="CenterCenter" form="unqualified" name="positioning"
							use="optional">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="LeftBottom"/>
									<xs:enumeration value="LeftCenter"/>
									<xs:enumeration value="LeftTop"/>
									<xs:enumeration value="CenterTop"/>
									<xs:enumeration value="RightTop"/>
									<xs:enumeration value="RightCenter"/>
									<xs:enumeration value="RightBottom"/>
									<xs:enumeration value="CenterBottom"/>
									<xs:enumeration value="CenterCenter"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Triangle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:RectangleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="height"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Arc">
					<xs:annotation>
						<xs:documentation>        Defines a circle arc shape. Allows to draw pies like shapes.
							Notice that the space         coordinates (x,y) refers to the center of the circle to
							which this arc belongs to.        The arc is drawn counterclockwise.
						</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ArcShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="r"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional">
							<xs:annotation>
								<xs:documentation>          The radius of the Arc shape. The position (x,y) refers
									to the circle origin           to which this arc belongs to.
								</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="angle" type="xs:double" use="optional">
							<xs:annotation>
								<xs:documentation>          The opening angle of the arc shape in degrees.
									Default is 360 degrees, that means a full circle.         </xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="startAngle" type="xs:double" use="optional">
							<xs:annotation>
								<xs:documentation>          The angle (degrees) where the arc starts. Default is 0
									degrees.         </xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="endAngle" type="xs:double" use="optional">
							<xs:annotation>
								<xs:documentation>          The angle (degrees) where the arc shape ends. Default is
									360 degrees.           If set, then the value of @angle will be ignored while an
									automatic           computation will apply based on @startAngle and @endAngle
									values.         </xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Circle">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:CircleShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="r"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Ellipse">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:EllipseShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="rx"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="ry"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="RegularPolygon">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:RegularPolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="numberOfPoints" use="required">
							<xs:simpleType>
								<xs:restriction base="xs:integer">
									<xs:minInclusive value="3"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
						<xs:attribute form="unqualified" name="diameter" type="xs:positiveInteger"
							use="optional"/>
						<xs:attribute form="unqualified" name="sideLength" type="xs:positiveInteger"
							use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Polygon">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:PolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="points" type="ers:CoordinatePairSequence.type"
							use="required"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Polyline">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:PolygonShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="points" type="ers:CoordinatePairSequence.type"
							use="required"/>
						<xs:attributeGroup ref="ers:ShapeStrokeAttributes"/>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:attribute form="unqualified" name="x" type="ers:PositiveInteger-OR-Pixel-OR-Percent.type"
				use="optional"/>
			<xs:attribute form="unqualified" name="y" type="ers:PositiveInteger-OR-Pixel-OR-Percent.type"
				use="optional"/>
			<xs:attribute form="unqualified" name="rotX" type="xs:double" use="optional"/>
			<xs:attribute form="unqualified" name="rotY" type="xs:double" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="ShapeFillAttributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="fill" type="ers:Color.type" use="optional"/>
		<xs:attribute form="unqualified" name="fillRGB" type="ers:RGB.type" use="optional"/>
		<xs:attribute form="unqualified" name="fillOpacity" type="ers:Probability" use="optional"/>
		<xs:attribute form="unqualified" name="texture" type="xs:anyURI" use="optional"/>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="ShapeStrokeAttributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="stroke" type="ers:Color.type" use="optional"/>
		<xs:attribute form="unqualified" name="strokeRGB" type="ers:RGB.type" use="optional"/>
		<xs:attribute form="unqualified" name="strokeWidth" type="xs:nonNegativeInteger" use="optional"/>
		<xs:attribute form="unqualified" name="strokeOpacity" type="ers:Probability" use="optional"/>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="Color.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="white"/>
			<xs:enumeration value="black"/>
			<xs:enumeration value="lightgrey"/>
			<xs:enumeration value="grey"/>
			<xs:enumeration value="darkgrey"/>
			<xs:enumeration value="lightred"/>
			<xs:enumeration value="red"/>
			<xs:enumeration value="darkred"/>
			<xs:enumeration value="lightgreen"/>
			<xs:enumeration value="green"/>
			<xs:enumeration value="darkgreen"/>
			<xs:enumeration value="lightblue"/>
			<xs:enumeration value="blue"/>
			<xs:enumeration value="darkblue"/>
			<xs:enumeration value="lightyellow"/>
			<xs:enumeration value="yellow"/>
			<xs:enumeration value="orange"/>
			<xs:enumeration value="brown"/>
			<xs:enumeration value="pink"/>
			<xs:enumeration value="purple"/>
			<xs:enumeration value="aqua"/>
			<xs:enumeration value="purple"/>
			<xs:enumeration value="magenta"/>
			<xs:enumeration value="violet"/>
			<xs:enumeration value="fuchsia"/>
			<xs:enumeration value="lime"/>
			<xs:enumeration value="maroon"/>
			<xs:enumeration value="navi"/>
			<xs:enumeration value="olive"/>
			<xs:enumeration value="silver"/>
			<xs:enumeration value="teal"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="RGB.type">
		<xs:restriction base="ers:ListOfBytes">
			<xs:length value="3"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="SquareShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="width"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
			<xs:enumeration value="rot"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="RectangleShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="width"/>
			<xs:enumeration value="height"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
			<xs:enumeration value="rot"/>
			<xs:enumeration value="texture"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="ArcShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="r"/>
			<xs:enumeration value="angle"/>
			<xs:enumeration value="startAngle"/>
			<xs:enumeration value="endAngle"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
			<xs:enumeration value="rot"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="CircleShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="r"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
			<xs:enumeration value="rot"/>
			<xs:enumeration value="texture"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="EllipseShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="rx"/>
			<xs:enumeration value="ry"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
			<xs:enumeration value="rot"/>
			<xs:enumeration value="texture"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="PolygonShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="points"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
			<xs:enumeration value="rot"/>
			<xs:enumeration value="texture"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="RegularPolygonShapeProperty.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="numberOfPoints"/>
			<xs:enumeration value="diameter"/>
			<xs:enumeration value="sideLength"/>
			<!-- shared shape properties -->
			<xs:enumeration value="x"/>
			<xs:enumeration value="y"/>
			<xs:enumeration value="fill"/>
			<xs:enumeration value="fillR"/>
			<xs:enumeration value="fillG"/>
			<xs:enumeration value="fillB"/>
			<xs:enumeration value="stroke"/>
			<xs:enumeration value="strokeR"/>
			<xs:enumeration value="strokeG"/>
			<xs:enumeration value="strokeB"/>
			<xs:enumeration value="strokeWidth"/>
			<xs:enumeration value="opacity"/>
			<xs:enumeration value="fillOpacity"/>
			<xs:enumeration value="rot"/>
			<xs:enumeration value="texture"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ShapeSlot">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:attribute form="unqualified" name="shapeProperty" type="ers:ShapeProperty.type"
				use="required"/>
			<xs:attribute form="unqualified" name="value" type="xs:string" use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ShapePropertyVisualizationMap">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:annotation>
			<xs:documentation>Allows to define the dynamic visualization of object properties by mapping
				them to shape properties. The map can be defined either as a polynomial or a casewise
				constant function, or a function defined by equality cases (either of integers resp.
				strings, or of enumeration literals).</xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute form="unqualified" name="shapeProperty" type="ers:ShapeProperty.type"
				use="required"/>
			<xs:attributeGroup ref="ers:Map.attrgrp"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="PhysicalShape3D">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice>
				<xs:element form="qualified" name="Cube">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:SquareShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Cuboid">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Cone">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Cylinder">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Mesh">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="file" type="xs:anyURI" use="required"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Pyramid">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="RegularTriangularPrism">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Sphere">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Tetrahedra">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
			</xs:choice>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="Shape3D">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:choice>
				<xs:element form="qualified" name="Cube">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:SquareShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Cuboid">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="depth"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="height"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Cone">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="r"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="height"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Cylinder">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="r"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="height"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Mesh">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="file" type="xs:anyURI" use="required"/>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="depth"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="height"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Pyramid">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="depth"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="height"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="RegularTriangularPrism">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="depth"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="height"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Sphere">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="r"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
				<xs:element form="qualified" name="Tetrahedra">
					<xs:complexType>
						<xs:sequence>
							<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
								name="ShapePropertyVisualizationMap">
								<xs:complexType>
									<xs:attribute form="unqualified" name="shapeProperty"
										type="ers:ShapeProperty.type" use="required"/>
									<xs:attributeGroup ref="ers:Map.attrgrp"/>
								</xs:complexType>
							</xs:element>
						</xs:sequence>
						<xs:attribute form="unqualified" name="width"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="depth"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attribute form="unqualified" name="height"
							type="ers:PositiveInteger-OR-Pixel-OR-Percent.type" use="optional"/>
						<xs:attributeGroup ref="ers:ShapeFillAttributes"/>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:attribute form="unqualified" name="x" type="ers:PositiveInteger-OR-Pixel-OR-Percent.type"
				use="optional"/>
			<xs:attribute form="unqualified" name="y" type="ers:PositiveInteger-OR-Pixel-OR-Percent.type"
				use="optional"/>
			<xs:attribute form="unqualified" name="z" type="ers:PositiveInteger-OR-Pixel-OR-Percent.type"
				use="optional"/>
			<xs:attribute form="unqualified" name="rotX" type="xs:double" use="optional"/>
			<xs:attribute form="unqualified" name="rotY" type="xs:double" use="optional"/>
			<xs:attribute form="unqualified" name="rotZ" type="xs:double" use="optional"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<!--	
	<xs:element name="Scales" type="ers:Scales.type"/>
	<xs:complexType name="Scales.type">
		<xs:sequence>
			<xs:element name="Scale" type="ers:Enumeration.type" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
-->
	<!-- =================================================================== -->
	<xs:element name="EventAppearance" type="ers:EventAppearance.type">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Associates all events of a certain type with some form of sound: either a
				MIDI note sequence or an MP3 sound file. Event properties may be sonified with the help of a
				SonificationMap.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="EventAppearance.type">
		<xs:sequence>
			<xs:element form="qualified" maxOccurs="16" minOccurs="0" name="MidiSound">
				<xs:complexType>
					<xs:sequence>
						<xs:element maxOccurs="3" minOccurs="0" ref="ers:SonificationMap"/>
					</xs:sequence>
					<xs:attribute form="unqualified" name="instrumentName" type="ers:Instrument.type"
						use="optional"/>
					<xs:attribute form="unqualified" name="instrumentNo" use="optional">
						<xs:simpleType>
							<xs:restriction base="xs:integer">
								<xs:minInclusive value="0"/>
								<xs:maxInclusive value="127"/>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
					<xs:attribute form="unqualified" name="noteSequence" type="ers:NoteSequence.type"
						use="optional">
						<xs:annotation>
							<xs:documentation>         A note sequence is a list of note/duration/volume triples
								where the note is an integer between 0          (corresponding to a low C) and 127
								(in half-tones) and the duration (in ms) and          volume (in range 0 = mute to
								127 = MAX_VOLUME) are positive integers.          An example is "12/300/80
								14/200/90"        </xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="eventType" type="ers:CanonicalName" use="required"/>
		<!-- TO BE MOVED to AORSL -->
		<xs:attribute form="unqualified" name="messageType" type="ers:CanonicalName" use="optional"/>
		<!--  -->
		<xs:attribute form="unqualified" name="duration" type="xs:positiveInteger" use="optional">
			<xs:annotation>
				<xs:documentation>The duration of the sound. If the sound source is a file and if no
					duration if specified, then the entire file is played. If deal with a sound file and a
					duration is specified with a value lower than the sound file duration then only the
					"duration" time is played from that file. If the source is a note sequence and no duration
					is specified, then the duration is computed as the sum of all note durations. If the
					source is a note sequence and a duration is defined then the duration of each note from
					sequence is multipled with a factor that ensures that the total notes duration equals with
					the value of the @duration attribute. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute form="unqualified" name="soundFile" type="xs:anyURI" use="optional">
			<xs:annotation>
				<xs:documentation>The source file can be mp3 or midi. It is identified by its extension
					(.mp3 or .mid). The file is searched first in the project directory under "media/sounds".
					If the file is not found then it is searched in the media/sounds global directory. If
					still not found, then no sound is played. Note that the path is relativ to "media/sounds"
					(of the project or the global one). So a value @introSoundFile="/mySounds/background.mid"
					will be searched in "media/sounds/mySounds/background.mid" (global or the project one).
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:simpleType name="Instrument.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:restriction base="xs:string">
			<xs:enumeration value="PIANO_AcousticGrand"/>
			<xs:enumeration value="PIANO_BrightAcoustic"/>
			<xs:enumeration value="PIANO_ElectricGrand"/>
			<xs:enumeration value="PIANO_HonkyTonk"/>
			<xs:enumeration value="PIANO_EPiano1"/>
			<xs:enumeration value="PIANO_EPiano2"/>
			<xs:enumeration value="PIANO_Harpsichord"/>
			<xs:enumeration value="PIANO_Clav"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Celesta"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Glockenspiel"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_MusicBox"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Vibraphone"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Marimba"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Xylophone"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_TubularBells"/>
			<xs:enumeration value="CHROMATIC_PERCUSSION_Dulcimer"/>
			<xs:enumeration value="ORGAN_DrawbarOrgan"/>
			<xs:enumeration value="ORGAN_PercussiveOrgan"/>
			<xs:enumeration value="ORGAN_RockOrgan"/>
			<xs:enumeration value="ORGAN_ChurchOrgan"/>
			<xs:enumeration value="ORGAN_ReedOrgan"/>
			<xs:enumeration value="ORGAN_Accoridan"/>
			<xs:enumeration value="ORGAN_Harmonica"/>
			<xs:enumeration value="ORGAN_TangoAccordian"/>
			<xs:enumeration value="GUITAR_AcousticGuitar_nylon"/>
			<xs:enumeration value="GUITAR_AcousticGuitar_steel"/>
			<xs:enumeration value="GUITAR_ElectricGuitar_jazz"/>
			<xs:enumeration value="GUITAR_ElectricGuitar_clean"/>
			<xs:enumeration value="GUITAR_ElectricGuitar_muted"/>
			<xs:enumeration value="GUITAR_OverdrivenGuitar"/>
			<xs:enumeration value="GUITAR_DistortionGuitar"/>
			<xs:enumeration value="GUITAR_GuitarHarmonics"/>
			<xs:enumeration value="BASS_AcousticBass"/>
			<xs:enumeration value="BASS_ElectricBass_finger"/>
			<xs:enumeration value="BASS_ElectricBass_pick"/>
			<xs:enumeration value="BASS_FretlessBass"/>
			<xs:enumeration value="BASS_SlapBass1"/>
			<xs:enumeration value="BASS_SlapBass2"/>
			<xs:enumeration value="BASS_SynthBass1"/>
			<xs:enumeration value="BASS_SynthBass2"/>
			<xs:enumeration value="STRINGS_Violin"/>
			<xs:enumeration value="STRINGS_Viola"/>
			<xs:enumeration value="STRINGS_Cello"/>
			<xs:enumeration value="STRINGS_Contrabass"/>
			<xs:enumeration value="STRINGS_TremoloStrings"/>
			<xs:enumeration value="STRINGS_PizzicatoStrings"/>
			<xs:enumeration value="STRINGS_OrchestralStrings"/>
			<xs:enumeration value="STRINGS_Timpani"/>
			<xs:enumeration value="ENSEMBLE_StringEnsemble1"/>
			<xs:enumeration value="ENSEMBLE_StringEnsemble2"/>
			<xs:enumeration value="ENSEMBLE_SynthStrings1"/>
			<xs:enumeration value="ENSEMBLE_SynthStrings2"/>
			<xs:enumeration value="ENSEMBLE_ChoirAahs"/>
			<xs:enumeration value="ENSEMBLE_VoiceOohs"/>
			<xs:enumeration value="ENSEMBLE_SynthVoice"/>
			<xs:enumeration value="ENSEMBLE_OrchestraHit"/>
			<xs:enumeration value="BRASS_Trumpet"/>
			<xs:enumeration value="BRASS_Trombone"/>
			<xs:enumeration value="BRASS_Tuba"/>
			<xs:enumeration value="BRASS_MutedTrumpet"/>
			<xs:enumeration value="BRASS_FrenchHorn"/>
			<xs:enumeration value="BRASS_BrassSection"/>
			<xs:enumeration value="BRASS_SynthBrass1"/>
			<xs:enumeration value="BRASS_SynthBrass2"/>
			<xs:enumeration value="REED_SopranoSax"/>
			<xs:enumeration value="REED_AltoSax"/>
			<xs:enumeration value="REED_TenorSax"/>
			<xs:enumeration value="REED_BaritoneSax"/>
			<xs:enumeration value="REED_Oboe"/>
			<xs:enumeration value="REED_EnglishHorn"/>
			<xs:enumeration value="REED_Bassoon"/>
			<xs:enumeration value="REED_Clarinet"/>
			<xs:enumeration value="PIPE_Piccolo"/>
			<xs:enumeration value="PIPE_Flute"/>
			<xs:enumeration value="PIPE_Recorder"/>
			<xs:enumeration value="PIPE_PanFlute"/>
			<xs:enumeration value="PIPE_BlownBottle"/>
			<xs:enumeration value="PIPE_Shakuhachi"/>
			<xs:enumeration value="PIPE_Whistle"/>
			<xs:enumeration value="PIPE_Ocarina"/>
			<xs:enumeration value="SYNTH_LEAD_Lead1"/>
			<xs:enumeration value="SYNTH_LEAD_Lead2"/>
			<xs:enumeration value="SYNTH_LEAD_Lead3"/>
			<xs:enumeration value="SYNTH_LEAD_Lead4"/>
			<xs:enumeration value="SYNTH_LEAD_Lead5"/>
			<xs:enumeration value="SYNTH_LEAD_Lead6"/>
			<xs:enumeration value="SYNTH_LEAD_Lead7"/>
			<xs:enumeration value="SYNTH_LEAD_Lead8"/>
			<xs:enumeration value="SYNTH_PAD_Pad1"/>
			<xs:enumeration value="SYNTH_PAD_Pad2"/>
			<xs:enumeration value="SYNTH_PAD_Pad3"/>
			<xs:enumeration value="SYNTH_PAD_Pad4"/>
			<xs:enumeration value="SYNTH_PAD_Pad5"/>
			<xs:enumeration value="SYNTH_PAD_Pad6"/>
			<xs:enumeration value="SYNTH_PAD_Pad7"/>
			<xs:enumeration value="SYNTH_PAD_Pad8"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX1"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX2"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX3"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX4"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX5"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX6"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX7"/>
			<xs:enumeration value="SYNTH_EFFECTS_FX8"/>
			<xs:enumeration value="ETHNIC_Sitar"/>
			<xs:enumeration value="ETHNIC_Banjo"/>
			<xs:enumeration value="ETHNIC_Shamisen"/>
			<xs:enumeration value="ETHNIC_Koto"/>
			<xs:enumeration value="ETHNIC_Kalimba"/>
			<xs:enumeration value="ETHNIC_Bagpipe"/>
			<xs:enumeration value="ETHNIC_Fiddle"/>
			<xs:enumeration value="ETHNIC_Shanai"/>
			<xs:enumeration value="PERCUSSIVE_TinkleBell"/>
			<xs:enumeration value="PERCUSSIVE_Agogo"/>
			<xs:enumeration value="PERCUSSIVE_SteelDrums"/>
			<xs:enumeration value="PERCUSSIVE_Woodblock"/>
			<xs:enumeration value="PERCUSSIVE_TaikoDrum"/>
			<xs:enumeration value="PERCUSSIVE_MelodicTom"/>
			<xs:enumeration value="PERCUSSIVE_SynthDrum"/>
			<xs:enumeration value="PERCUSSIVE_ReverseCymbal"/>
			<xs:enumeration value="SOUND_EFFECTS_GuitarFretNoise"/>
			<xs:enumeration value="SOUND_EFFECTS_BreathNoise"/>
			<xs:enumeration value="SOUND_EFFECTS_Seashore"/>
			<xs:enumeration value="SOUND_EFFECTS_BirdTweet"/>
			<xs:enumeration value="SOUND_EFFECTS_TelephoneRing"/>
			<xs:enumeration value="SOUND_EFFECTS_Helicopter"/>
			<xs:enumeration value="SOUND_EFFECTS_Applause"/>
			<xs:enumeration value="SOUND_EFFECTS_Gunshot"/>
		</xs:restriction>
	</xs:simpleType>
	<!-- =================================================================== -->
	<xs:element name="SonificationMap">
		<!-- =================================================================== -->
		<xs:annotation>
			<xs:documentation>Allows to map an object property to a MIDI sound property. Either a casewise
				constant function or a polynomial function with y = a3x^3 + a2x^2 + a1x+ a0, where x is the
				event/object property and y is one of the four sound properties instrumentNo, note,
				duration, volume. The casewise constant function is defined by y = v0 if  x &lt; a0, y = v1 if
				a0 &lt;= x &lt; a1, etc. </xs:documentation>
		</xs:annotation>
		<xs:complexType>
			<xs:attribute form="unqualified" name="soundProperty" use="required">
				<xs:annotation>
					<xs:documentation>       The sound property that will be affected by this sonification
						map.        </xs:documentation>
				</xs:annotation>
				<xs:simpleType>
					<xs:restriction base="xs:string">
						<xs:enumeration value="instrumentNo">
							<xs:annotation>
								<xs:documentation>          The instrument number (allowed resulting values ar in
									range of 0-127).         </xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="note">
							<xs:annotation>
								<xs:documentation>          The note number - resulting note value must be in range
									of 0-127.         </xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="duration">
							<xs:annotation>
								<xs:documentation>          The note duration. The resulting value must be positive
									or equal to 0 and is expressed in milliseconds.         </xs:documentation>
							</xs:annotation>
						</xs:enumeration>
						<xs:enumeration value="volume">
							<xs:annotation>
								<xs:documentation>          The resulting value must be in range 0-127 (0 = mute,
									127 = MAX_VOLUME).         </xs:documentation>
							</xs:annotation>
						</xs:enumeration>
					</xs:restriction>
				</xs:simpleType>
			</xs:attribute>
			<xs:attributeGroup ref="ers:Map.attrgrp"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<!-- *** Special Data Types  *** -->
	<!-- =================================================================== -->
	<xs:simpleType name="PositiveInteger-OR-Pixel-OR-Percent.type">
		<xs:union memberTypes="ers:Pixel-OR-Percent.type xs:positiveInteger"/>
	</xs:simpleType>
	<xs:simpleType name="Pixel-OR-Percent.type">
		<xs:restriction base="xs:string">
			<xs:pattern value="\-?(([0-9])*px|[1-9]?[0-9]%)"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="NoteSequence.type">
		<xs:list itemType="ers:NoteDurationVolumeTriple.type"/>
	</xs:simpleType>
	<xs:simpleType name="NoteDurationVolumeTriple.type">
		<xs:annotation>
			<xs:documentation>A note/duration/volume triple has the form N[[/D]/V] where N=0..127 (note),
				D=Integer (duration), and V=0..127 (volume). </xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:pattern
				value="(([1-9]?|1[0-1])[0-9]|12[0-7])(/([1-9][0-9]*)(/((([1-9]?|1[0-1])[0-9]|12[0-7])))?)?"
			/>
		</xs:restriction>
	</xs:simpleType>
	<!-- =================================================================== -->
	<xs:element name="StatisticsUI">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0" name="StatisticsVariableUI">
					<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
					<xs:complexType>
						<xs:sequence>
							<xs:element ref="ers:Label"/>
							<xs:element ref="ers:Hint"/>
							<xs:element minOccurs="0" ref="ers:Format"/>
						</xs:sequence>
						<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
						<xs:attribute form="unqualified" name="comparisonGroup" type="ers:CanonicalName"
							use="optional">
							<xs:annotation>
								<xs:documentation>Allows to assign a user-defined comparison group name to a
									variable, such that all variables with this comparison group name will be charted
									in a single comparison chart.</xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="showChart" type="xs:boolean" use="optional">
							<xs:annotation>
								<xs:documentation>Allows to specify that the variable's time series should be shown
									in a chart. Makes only sense for variables that have distinct values at different
									simulations steps such that their temporal variation is of interest.
								</xs:documentation>
							</xs:annotation>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
				<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
				<xs:element form="qualified" maxOccurs="unbounded" minOccurs="0"
					name="FrequencyDistributionChart">
					<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->
					<xs:annotation>
						<xs:documentation>Shows the relative frequencies of object property values for the
							population/extension of an object type at the end of a simulation run. For a property
							of type Float, value intervals have to be defined with the help of the intervalSize
							attribute.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attribute form="unqualified" name="objectPropertyStatisticsVariable"
							type="ers:CanonicalName" use="required">
							<xs:annotation>
								<xs:documentation>Refers to a statistics variable that is bound to an object
									property as its <h:code>Source</h:code>. </xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="minValue" type="xs:double" use="optional"/>
						<xs:attribute form="unqualified" name="maxValue" type="xs:double" use="optional"/>
						<xs:attribute form="unqualified" name="intervalSize" type="xs:double" use="optional">
							<xs:annotation>
								<xs:documentation>The <h:code>intervalSize</h:code> attribute allows to define a
									sequence of intervals based on <h:code>minValue</h:code> and
										<h:code>maxValue</h:code>. E.g., the attribute settings minValue="10"
									intervalSize="2" maxValue="16" defines the 3 intervals (10,12], (12,14] and
									(14,16]. </xs:documentation>
							</xs:annotation>
						</xs:attribute>
						<xs:attribute form="unqualified" name="chartType" use="optional">
							<xs:simpleType>
								<xs:restriction base="xs:string">
									<xs:enumeration value="BAR"/>
									<xs:enumeration value="PIE"/>
									<xs:enumeration value="PIE3D"/>
									<xs:enumeration value="AREA"/>
									<xs:enumeration value="LINE"/>
									<xs:enumeration value="STEP"/>
									<xs:enumeration value="STEP_AREA"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:attribute>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:group name="Units.elemGrp">
		<xs:choice>
			<xs:element form="qualified" minOccurs="0" name="Currency" type="ers:CurrencySymbol"/>
			<xs:element form="qualified" minOccurs="0" name="Length" type="ers:LengthUnit"/>
			<xs:element form="qualified" minOccurs="0" name="Weight" type="ers:WeightUnit"/>
			<xs:element form="qualified" minOccurs="0" name="Time" type="ers:TimeUnit"/>
			<xs:element form="qualified" minOccurs="0" name="Area" type="ers:AreaUnit"/>
			<xs:element form="qualified" minOccurs="0" name="Volume" type="ers:VolumeUnit"/>
			<xs:element form="qualified" minOccurs="0" name="Math" type="ers:MathUnit"/>
			<xs:element form="qualified" minOccurs="0" name="Physics" type="ers:PhysicalUnit"/>
			<xs:element form="qualified" minOccurs="0" name="PackagingUnits" type="ers:PackagingUnit"/>
		</xs:choice>
	</xs:group>
	<!-- =================================================================== -->
	<xs:element name="InitialStateUI">
		<!-- =================================================================== -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:GlobalVariableUI"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:EventUI"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ObjectUI"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:AgentUI"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="EventUI">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:PropertyUI"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="eventType" type="ers:CanonicalName"/>
			<xs:attributeGroup ref="ers:EntityUI.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="EntityUI.attributes">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="minNmrOfInstances" type="xs:nonNegativeInteger"
			use="optional"/>
		<xs:attribute form="unqualified" name="maxNmrOfInstances" use="optional">
			<xs:simpleType>
				<xs:restriction base="xs:integer">
					<xs:minInclusive value="1"/>
					<xs:maxInclusive value="7"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="ObjectUI">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:PropertyUI"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="objectType" type="ers:CanonicalName"/>
			<xs:attributeGroup ref="ers:EntityUI.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="AgentUI">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:PropertyUI"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:SelfBeliefPropertyUI"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:BeliefEntityUI"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="agentType" type="ers:CanonicalName"/>
			<xs:attributeGroup ref="ers:EntityUI.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="PropertyUI" type="ers:PropertyUI.type"/>
	<xs:element name="SelfBeliefPropertyUI" type="ers:PropertyUI.type"/>
	<xs:element name="BeliefPropertyUI" type="ers:PropertyUI.type"/>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:complexType name="PropertyUI.type">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:group ref="ers:Field.CommonElem"/>
		<xs:attribute form="unqualified" name="property" type="ers:CanonicalName" use="required"/>
		<xs:attributeGroup ref="ers:PropertyAndVariableInputField.attrGrp"/>
	</xs:complexType>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:group name="Field.CommonElem">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:sequence>
			<xs:element ref="ers:Label"/>
			<xs:element minOccurs="0" ref="ers:Hint"/>
			<xs:element minOccurs="0" ref="ers:Format"/>
		</xs:sequence>
	</xs:group>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:attributeGroup name="PropertyAndVariableInputField.attrGrp">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:attribute form="unqualified" name="label" type="xs:string" use="optional"/>
		<xs:attribute default="false" form="unqualified" name="readonly" type="xs:boolean"
			use="optional"/>
		<xs:attribute form="unqualified" name="inputFieldLength" use="optional">
			<xs:annotation>
				<xs:documentation>The length of the property input field in cm. </xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:float">
					<xs:minExclusive value="0.0"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute form="unqualified" name="widget" use="optional">
			<xs:simpleType>
				<xs:restriction base="xs:string">
					<xs:enumeration value="Slider"/>
					<!--<xs:enumeration value="Meter"/>-->
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute form="unqualified" name="sliderStepSize" use="optional">
			<xs:annotation>
				<xs:documentation>The step size of a slider. </xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:float">
					<xs:minExclusive value="0.0"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:attributeGroup>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Format">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:group ref="ers:Units.elemGrp"/>
			<xs:attribute form="unqualified" name="decimalPlaces" type="xs:nonNegativeInteger"
				use="required"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Unit">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:group ref="ers:Units.elemGrp"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Label">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:Text"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="Hint">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:Text"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="FlyOver">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:Text"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="GlobalVariableUI">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:group ref="ers:Field.CommonElem"/>
			<xs:attribute form="unqualified" name="variable" type="ers:CanonicalName" use="required"/>
			<xs:attributeGroup ref="ers:PropertyAndVariableInputField.attrGrp"/>
		</xs:complexType>
	</xs:element>
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<xs:element name="BeliefEntityUI">
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" ref="ers:BeliefPropertyUI"/>
			</xs:sequence>
			<xs:attribute form="unqualified" name="beliefEntityType" type="ers:CanonicalName"/>
			<xs:attributeGroup ref="ers:EntityUI.attributes"/>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<xs:element name="AnimationUI" type="ers:AnimationUI.type"/>
	<!-- =================================================================== -->
	<xs:complexType name="AnimationUI.type">
		<xs:sequence>
			<xs:element form="qualified" minOccurs="0" name="DisplayDescription">
				<xs:complexType>
					<xs:sequence>
						<xs:element maxOccurs="unbounded" ref="ers:HtmlText"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element form="qualified" name="Views">
				<xs:complexType>
					<xs:sequence>
						<xs:element minOccurs="0" ref="ers:SpaceView"/>
						<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ObjectView"/>
						<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:PhysicalObjectView"/>
						<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:EventAppearance"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute form="unqualified" name="introSoundFile" type="xs:anyURI" use="optional">
			<xs:annotation>
				<xs:documentation>The sound file can be mp3 or midi, as identified by its extension (.mp3 or
					.mid). The file is searched first in the project folder under "media/sounds". If the file
					is not found in this folder, then it is searched in the global media/sounds folder. If
					still not found, then no sound is played. Note that the path is relative to the
					media/sounds folder. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!-- to be dropped when AgentControlUserInterface -->
	<!--
  <xs:include schemaLocation="AgentControlUserInterface.xsd"/>
-->
	<!-- =================================================================== -->
	<!-- *** Root element *** -->
	<!-- *** SimulationScenario *** -->
	<!-- =================================================================== -->
	<xs:element id="SimulationScenario" name="SimulationScenario" type="aors:SimulationScenario.type">
		<xs:annotation>
			<xs:documentation>
				<h:p>Consists essentially of a <h:code>SimulationModel</h:code>, an
						<h:code>InitialState</h:code>, and an <h:code>UserInterface</h:code> (including a
					statistics user interface and an animation user interface).</h:p>
			</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="SimulationScenario.type">
		<xs:sequence>
			<xs:element minOccurs="0" ref="aors:documentation"/>
			<xs:element ref="aors:SimulationParameters"/>
			<xs:choice>
				<xs:group ref="aors:include"/>
				<xs:element ref="aors:SimulationModel"/>
			</xs:choice>
			<xs:element ref="aors:InitialState"/>
			<xs:element minOccurs="0" ref="aors:UserInterface"/>
		</xs:sequence>
		<xs:attributeGroup ref="aors:SimulationScenario.attributes"/>
	</xs:complexType>
	<!-- =================================================================== -->
	<!-- *** SimulationModel *** -->
	<!-- =================================================================== -->
	<xs:element id="SimulationModel" name="SimulationModel">
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:documentation"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:SimulationParameterDeclaration"/>
				<xs:element minOccurs="0" ref="ers:SpaceModel"/>
				<xs:element minOccurs="0" ref="ers:Statistics"/>
				<xs:element minOccurs="0" ref="ers:DataTypes"/>
				<xs:element minOccurs="0" ref="ers:Globals"/>
				<xs:element minOccurs="0" ref="ers:EntityTypes"/>
				<xs:element minOccurs="0" ref="ers:EnvironmentRules"/>
			</xs:sequence>
			<xs:attributeGroup ref="ers:SimulationModel.basic-attributes"/>
			<xs:attribute name="baseURI" type="xs:anyURI" use="optional">
				<xs:annotation>
					<xs:documentation>The base URI is used in the URIs of agent vocabulary elements.
					</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
		<xs:unique name="uniqueNames">
			<xs:selector xpath="ers:EntityTypes/* | ers:EnvironmentRules | ers:DataTypes"/>
			<xs:field xpath="@name"/>
		</xs:unique>
		<!-- =================================================================== -->
		<!-- KEY and KEYREF constraints  -->
		<!-- =================================================================== -->
		<xs:key name="ExternalEntityTypeKey">
			<xs:selector
				xpath="ers:EntityTypes/ers:ObjectType | ers:EntityTypes/ers:PhysicalObjectType | ers:EntityTypes/ers:PhysicalAgentType | ers:EntityTypes/ers:MessageType | ers:EntityTypes/ers:CausedEventType | ers:EntityTypes/ers:PerceptionEventType | ers:EntityTypes/ers:ActionEventType | ers:EntityTypes/ers:ExogenousEventType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:key name="ObjectTypeKey">
			<xs:selector
				xpath="ers:EntityTypes/ers:ObjectType | ers:EntityTypes/ers:AgentType | ers:EntityTypes/ers:PhysicalObjectType | ers:EntityTypes/ers:PhysicalAgentType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="ObjectTypeReference" refer="ers:ObjectTypeKey">
			<!--
			<xs:selector xpath="ers:EnvironmentRules/ers:EnvironmentRule/ers:VariableDeclaration[@objectType != 'Collection'] | ers:EnvironmentRules/ers:EnvironmentRule/ers:UPDATE-ENV/ers:UpdateObjects"/>
-->
			<xs:selector
				xpath="ers:EnvironmentRules/ers:EnvironmentRule/ers:DO/ers:UPDATE-ENV/ers:UpdateObjects | ers:EnvironmentRules/ers:EnvironmentRule/ers:THEN/ers:UPDATE-ENV/ers:UpdateObjects | ers:EnvironmentRules/ers:EnvironmentRule/ers:ELSE/ers:UPDATE-ENV/ers:UpdateObjects"/>
			<xs:field xpath="@objectType"/>
		</xs:keyref>
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:key name="ReferenceTypeKey">
			<xs:selector
				xpath="ers:EntityTypes/ers:ObjectType | ers:EntityTypes/ers:AgentType | ers:EntityTypes/ers:MessageType | ers:EntityTypes/ers:PhysicalObjectType | ers:EntityTypes/ers:PhysicalAgentType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="ReferenceProperty-TypeReference" refer="ers:ReferenceTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:*/ers:ReferenceProperty"/>
			<xs:field xpath="@type"/>
		</xs:keyref>
		<!--
		The following keyref cannot be used as there are predfined superclass types (such as the agent type for sincere and trustful communication)
		<xs:keyref name="ObjectType-SuperTypeReference" refer="ers:ObjectTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:ObjectType | ers:EntityTypes/ers:PhysicalObjectType | ers:EntityTypes/ers:PhysicalAgentType"/>
			<xs:field xpath="@superType"/>
		</xs:keyref>
-->
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:key name="EnvironmentEventTypeKey">
			<xs:selector
				xpath="ers:EntityTypes/ers:ExogenousEventType | ers:EntityTypes/ers:CausedEventType | ers:EntityTypes/ers:PerceptionEventType | ers:EntityTypes/ers:ActionEventType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<!--
		The following keyref cannot be used as there are predfined event types such as OutMessageEvent
		<xs:keyref name="EnvironmentEventTypeReference" refer="ers:EnvironmentEventTypeKey">
			<xs:selector xpath="ers:EnvironmentRules/ers:EnvironmentRule/ers:TriggeringAtomicEventExpr"/>
			<xs:field xpath="@eventType"/>
		</xs:keyref>
-->
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:key name="CausedEventTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:CausedEventType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<!--
		The following keyref cannot be used as there are predfined event types such as StopSimulation
		<xs:keyref name="CausedEventTypeReference" refer="ers:CausedEventTypeKey">
			<xs:selector xpath="ers:EnvironmentRules/ers:EnvironmentRule/ers:ResultingEventExpr/ers:CausedEventExpr"/>
			<xs:field xpath="@eventType"/>
		</xs:keyref>
-->
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:key name="PerceptionEventTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:PerceptionEventType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="ResultingPerceptionEventExpr-PerceptionEventTypeReference"
			refer="ers:PerceptionEventTypeKey">
			<xs:selector
				xpath="ers:EnvironmentRules/ers:EnvironmentRule/ers:DO/ers:SCHEDULE-EVT/ers:PerceptionEventExpr | ers:EnvironmentRules/ers:EnvironmentRule/ers:THEN/ers:SCHEDULE-EVT/ers:PerceptionEventExpr | ers:EnvironmentRules/ers:EnvironmentRule/ers:ELSE/ers:SCHEDULE-EVT/ers:PerceptionEventExpr"/>
			<xs:field xpath="@eventType"/>
		</xs:keyref>
		<xs:keyref name="TriggeringPerceptionEventExpr-PerceptionEventTypeReference"
			refer="ers:PerceptionEventTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:PhysicalAgentType/ers:ActualPerceptionRule/ers:WHEN"/>
			<xs:field xpath="@perceptionEventType"/>
		</xs:keyref>
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:key name="ActionEventTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:ActionEventType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="EntityTypesActionEventTypeReference" refer="ers:ActionEventTypeKey">
			<xs:selector
				xpath="ers:EntityTypes/ers:PhysicalAgentType/ers:ReactionRule/ers:DO/ers:SCHEDULE-EVT/ers:ActionEventExpr | ers:EntityTypes/ers:PhysicalAgentType/ers:ReactionRule/ers:THEN/ers:SCHEDULE-EVT/ers:ActionEventExpr | ers:EntityTypes/ers:PhysicalAgentType/ers:ReactionRule/ers:ELSE/ers:SCHEDULE-EVT/ers:ActionEventExpr"/>
			<xs:field xpath="@actionEventType"/>
		</xs:keyref>
		<xs:keyref name="ActionRuleActionEventTypeReference" refer="ers:ActionEventTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:PhysicalAgentType/ers:ActionRule"/>
			<xs:field xpath="@actionEventType"/>
		</xs:keyref>
		<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
		<xs:key name="MessageTypeKey">
			<xs:selector xpath="ers:EntityTypes/ers:MessageType"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="EnvironmentRule-MessageTypeReference" refer="ers:MessageTypeKey">
			<xs:selector
				xpath="ers:EnvironmentRules/ers:EnvironmentRule/ers:WHEN | ers:EnvironmentRules/ers:EnvironmentRule/ers:DO/ers:SCHEDULE-EVT/ers:InMessageEventExpr | ers:EnvironmentRules/ers:EnvironmentRule/ers:THEN/ers:SCHEDULE-EVT/ers:InMessageEventExpr | ers:EnvironmentRules/ers:EnvironmentRule/ers:ELSE/ers:SCHEDULE-EVT/ers:InMessageEventExpr"/>
			<xs:field xpath="@messageType"/>
		</xs:keyref>
		<xs:keyref name="AgentRule-MessageTypeReference" refer="ers:MessageTypeKey">
			<xs:selector
				xpath="ers:EntityTypes/ers:PhysicalAgentType/ers:ReactionRule/ers:WHEN | ers:EntityTypes/ers:PhysicalAgentType/ers:ReactionRule/ers:DO/ers:SCHEDULE-EVT/ers:OutMessageEventExpr | ers:EntityTypes/ers:PhysicalAgentType/ers:ReactionRule/ers:THEN/ers:SCHEDULE-EVT/ers:OutMessageEventExpr | ers:EntityTypes/ers:PhysicalAgentType/ers:ReactionRule/ers:ELSE/ers:SCHEDULE-EVT/ers:OutMessageEventExpr"/>
			<xs:field xpath="@messageType"/>
		</xs:keyref>
		<xs:keyref name="OutMessageActionRuleMessageTypeReference" refer="aors:MessageTypeKey">
			<xs:selector
				xpath="ers:EntityTypes/ers:AgentType/ers:OutMessageActionRule | ers:EntityTypes/ers:PhysicalAgentType/ers:OutMessageActionRule"/>
			<xs:field xpath="@messageType"/>
		</xs:keyref>
	</xs:element>
	<!-- =================================================================== -->
	<!-- *** The EntityTypes container *** -->
	<!-- =================================================================== -->
	<xs:element name="EntityTypes">
		<xs:complexType>
			<xs:sequence>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:MessageType"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:EnvironmentEventType"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="aors:ActivityType"/>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ObjectType"/>
			</xs:sequence>
			<!-- checks if for each aors:ActionRule that does not refer to an OutMessageEvent an ActionEventType exists whose name equals to the refered action event type -->
			<!-- no longer needed but remains as an example for using assertions -->
			<!--xs:assert test="if(exists(.//aors:ActionRule/@actionEventType != 'OutMessageEvent')) then count(.//aors:ActionRule[@actionEventType != 'OutMessageEvent']) = count(.//aors:ActionRule[@actionEventType = ancestor-or-self::aors:EntityTypes/aors:ActionEventType/@name]) else true()"/-->
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<!-- *** InitialState *** -->
	<!-- =================================================================== -->
	<xs:element id="InitialState" name="InitialState">
		<xs:complexType>
			<xs:sequence>
				<xs:choice maxOccurs="unbounded" minOccurs="0">
					<xs:element maxOccurs="unbounded" minOccurs="0" name="GlobalVariable"
						type="ers:UpdateGlobalVariable.type"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Object"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:ExogenousEvent"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:CausedEvent"/>
					<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:Objects"/>
					<xs:element minOccurs="0" ref="ers:GridCells"/>
				</xs:choice>
				<xs:element maxOccurs="unbounded" minOccurs="0" ref="ers:InitializationRule"/>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<!-- =================================================================== -->
	<!-- *** UserInterface *** -->
	<!-- =================================================================== -->
	<xs:element id="UserInterface" name="UserInterface">
		<xs:complexType>
			<xs:sequence>
				<xs:element minOccurs="0" ref="ers:InitialStateUI"/>
				<xs:element minOccurs="0" ref="ers:StatisticsUI"/>
				<xs:element minOccurs="0" ref="ers:AnimationUI"/>
			</xs:sequence>
			<xs:attribute name="supportedLanguages" type="ers:ListOfLanguages" use="required"/>
		</xs:complexType>
	</xs:element>
</xs:schema>
